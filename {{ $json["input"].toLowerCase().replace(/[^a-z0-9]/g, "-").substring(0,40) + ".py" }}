```python
#
# EMR Backend Service: Patient Demographics Management
#
# This service provides secure, HIPAA-compliant CRUD operations for patient
# demographic data. It includes JWT-based authentication, role-based access
# control, and comprehensive audit logging for all PHI access.
#
# File Structure:
# /
# ├── main.py
# ├── api/
# │   └── v1/
# │       ├── api.py
# │       └── endpoints/
# │           ├── patients.py
# │           └── auth.py
# ├── core/
# │   ├── config.py
# │   └── security.py
# ├── crud/
# │   ├── crud_audit.py
# │   └── crud_patient.py
# │   └── crud_user.py
# ├── db/
# │   └── session.py
# ├── models/
# │   ├── audit_log.py
# │   ├── patient.py
# │   └── user.py
# └── schemas/
#     ├── audit_log.py
#     ├── patient.py
#     ├── token.py
#     └── user.py
#

# --- /core/config.py ---
# Description: Manages application settings and secrets using Pydantic's BaseSettings.
#
import os
from pydantic_settings import BaseSettings
from typing import List

class Settings(BaseSettings):
    """Application settings loaded from environment variables."""
    PROJECT_NAME: str = "EMR_Backend_Service"
    API_V1_STR: str = "/api/v1"
    
    # Security settings
    # In production, use a strong, randomly generated secret.
    # e.g., openssl rand -hex 32
    SECRET_KEY: str = os.environ.get("SECRET_KEY", "b4f2c815b3a3a4b9e8f1a1c3d5a7b9e2d7f8c6a5b3e4d2c1a0b9e8f7d6e5c4a3")
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # Database settings
    # Ensure the PostgreSQL server is configured for encryption at rest.
    # Format: postgresql+asyncpg://user:password@host:port/dbname
    DATABASE_URL: str = os.environ.get("DATABASE_URL", "postgresql+asyncpg://emr_user:secure_password@localhost:5432/emr_db")

    # Allowed user roles for PHI access
    # This enforces role-based access control.
    PHI_ACCESS_ROLES: List[str] = ["clinician", "admin"]
    
    class Config:
        case_sensitive = True

settings = Settings()


# --- /db/session.py ---
# Description: Handles database session management and engine creation.
#
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from core.config import settings

# The async engine allows for non-blocking database operations.
async_engine = create_async_engine(settings.DATABASE_URL, pool_pre_ping=True, echo=False)

# The sessionmaker provides a factory for creating new AsyncSession objects.
AsyncSessionLocal = sessionmaker(
    bind=async_engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autocommit=False,
    autoflush=False
)

# Base class for declarative SQLAlchemy models.
Base = declarative_base()

async def get_db_session() -> AsyncSession:
    """Dependency to get a database session for a single request."""
    async with AsyncSessionLocal() as session:
        yield session


# --- /models/user.py ---
# Description: SQLAlchemy model for system users (e.g., clinicians, admins).
#
import uuid
from sqlalchemy import Column, String, DateTime, func, Boolean
from sqlalchemy.dialects.postgresql import UUID
from db.session import Base

class User(Base):
    """Represents a system user with credentials and role."""
    __tablename__ = "users"
    
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username = Column(String(255), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    full_name = Column(String(255), nullable=True)
    role = Column(String(50), nullable=False, index=True) # e.g., 'clinician', 'admin', 'billing'
    is_active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())


# --- /models/patient.py ---
# Description: SQLAlchemy model for patient demographic data.
#
import uuid
from sqlalchemy import Column, String, Date, DateTime, func, Enum
from sqlalchemy.dialects.postgresql import UUID
from db.session import Base
import enum

class Gender(str, enum.Enum):
    MALE = "Male"
    FEMALE = "Female"
    OTHER = "Other"
    UNKNOWN = "Unknown"

class Patient(Base):
    """Represents patient demographic information (PHI)."""
    __tablename__ = "patients"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    mrn = Column(String(50), unique=True, index=True, nullable=False) # Medical Record Number
    first_name = Column(String(255), nullable=False)
    last_name = Column(String(255), nullable=False)
    date_of_birth = Column(Date, nullable=False)
    gender = Column(Enum(Gender), nullable=False)
    contact_phone = Column(String(50), nullable=True)
    contact_email = Column(String(255), nullable=True)
    address_line1 = Column(String(255), nullable=True)
    address_line2 = Column(String(255), nullable=True)
    city = Column(String(100), nullable=True)
    state = Column(String(100), nullable=True)
    postal_code = Column(String(20), nullable=True)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())


# --- /models/audit_log.py ---
# Description: SQLAlchemy model for HIPAA audit trails.
#
import uuid
from sqlalchemy import Column, String, DateTime, func, JSON
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql.schema import ForeignKey
from db.session import Base

class AuditLog(Base):
    """Represents an audit log entry for tracking PHI access and system events."""
    __tablename__ = "audit_logs"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    timestamp = Column(DateTime(timezone=True), server_default=func.now(), index=True)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    action = Column(String(255), nullable=False, index=True) # e.g., PATIENT_VIEW, PATIENT_UPDATE
    resource_type = Column(String(100), nullable=True) # e.g., Patient, User
    resource_id = Column(String(255), nullable=True) # e.g., Patient MRN or UUID
    details = Column(JSON, nullable=True) # Additional context, like changed fields
    ip_address = Column(String(50), nullable=True)
    user_agent = Column(String(500), nullable=True)
    status = Column(String(50), nullable=False) # e.g., 'SUCCESS', 'FAILURE'


# --- /schemas/token.py ---
# Description: Pydantic schemas for JWT token data.
#
from pydantic import BaseModel
from typing import Optional

class Token(BaseModel):
    """Schema for the access token response."""
    access_token: str
    token_type: str

class TokenData(BaseModel):
    """Schema for data encoded within the JWT."""
    username: Optional[str] = None


# --- /schemas/user.py ---
# Description: Pydantic schemas for user data validation.
#
import uuid
from pydantic import BaseModel

class UserBase(BaseModel):
    username: str
    full_name: Optional[str] = None
    role: str

class UserCreate(UserBase):
    password: str

class UserInDB(UserBase):
    id: uuid.UUID
    is_active: bool

    class Config:
        from_attributes = True


# --- /schemas/audit_log.py ---
# Description: Pydantic schemas for audit log data.
#
import uuid
from pydantic import BaseModel
from datetime import datetime
from typing import Optional, Any

class AuditLogCreate(BaseModel):
    """Schema for creating a new audit log entry."""
    user_id: uuid.UUID
    action: str
    status: str
    resource_type: Optional[str] = None
    resource_id: Optional[str] = None
    ip_address: Optional[str] = None
    user_agent: Optional[str] = None
    details: Optional[dict[str, Any]] = None


# --- /schemas/patient.py ---
# Description: Pydantic schemas for patient data validation and serialization.
#
import uuid
from pydantic import BaseModel, Field
from datetime import date
from typing import Optional
from models.patient import Gender

class PatientBase(BaseModel):
    """Base schema for patient data, contains all PHI fields."""
    mrn: str = Field(..., description="Medical Record Number")
    first_name: str
    last_name: str
    date_of_birth: date
    gender: Gender
    contact_phone: Optional[str] = None
    contact_email: Optional[str] = None
    address_line1: Optional[str] = None
    address_line2: Optional[str] = None
    city: Optional[str] = None
    state: Optional[str] = None
    postal_code: Optional[str] = None

class PatientCreate(PatientBase):
    """Schema for creating a new patient record."""
    pass

class PatientUpdate(BaseModel):
    """Schema for updating a patient record. All fields are optional."""
    first_name: Optional[str] = None
    last_name: Optional[str] = None
    date_of_birth: Optional[date] = None
    gender: Optional[Gender] = None
    contact_phone: Optional[str] = None
    contact_email: Optional[str] = None
    address_line1: Optional[str] = None
    address_line2: Optional[str] = None
    city: Optional[str] = None
    state: Optional[str] = None
    postal_code: Optional[str] = None

class PatientInDB(PatientBase):
    """Schema representing a patient record as stored in the database."""
    id: uuid.UUID
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True


# --- /core/security.py ---
# Description: Handles password hashing, JWT creation/decoding, and user authentication.
#
from datetime import datetime, timedelta, timezone
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from core.config import settings

# Use bcrypt for password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifies a plain password against its hashed version."""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hashes a plain password."""
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Creates a JWT access token."""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt


# --- /crud/crud_user.py ---
# Description: CRUD operations for the User model.
#
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from models.user import User
from schemas.user import UserCreate
from core.security import get_password_hash
from typing import Optional

async def get_user_by_username(db: AsyncSession, username: str) -> Optional[User]:
    """Retrieves a user by their username."""
    result = await db.execute(select(User).filter(User.username == username))
    return result.scalars().first()

async def create_user(db: AsyncSession, user: UserCreate) -> User:
    """Creates a new user in the database."""
    hashed_password = get_password_hash(user.password)
    db_user = User(
        username=user.username,
        hashed_password=hashed_password,
        full_name=user.full_name,
        role=user.role,
        is_active=True
    )
    db.add(db_user)
    await db.commit()
    await db.refresh(db_user)
    return db_user


# --- /crud/crud_audit.py ---
# Description: CRUD operations for the AuditLog model.
#
from sqlalchemy.ext.asyncio import AsyncSession
from models.audit_log import AuditLog
from schemas.audit_log import AuditLogCreate

async def create_audit_log(db: AsyncSession, log_entry: AuditLogCreate) -> AuditLog:
    """Creates a new audit log entry."""
    db_log = AuditLog(**log_entry.model_dump())
    db.add(db_log)
    await db.commit()
    await db.refresh(db_log)
    return db_log


# --- /crud/crud_patient.py ---
# Description: CRUD operations for the Patient model.
#
import uuid
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from models.patient import Patient
from schemas.patient import PatientCreate, PatientUpdate
from typing import Optional, Dict, Any

async def get_patient_by_id(db: AsyncSession, patient_id: uuid.UUID) -> Optional[Patient]:
    """Retrieves a patient by their internal UUID."""
    result = await db.execute(select(Patient).filter(Patient.id == patient_id))
    return result.scalars().first()

async def get_patient_by_mrn(db: AsyncSession, mrn: str) -> Optional[Patient]:
    """Retrieves a patient by their Medical Record Number."""
    result = await db.execute(select(Patient).filter(Patient.mrn == mrn))
    return result.scalars().first()

async def create_patient(db: AsyncSession, patient: PatientCreate) -> Patient:
    """Creates a new patient record."""
    db_patient = Patient(**patient.model_dump())
    db.add(db_patient)
    await db.commit()
    await db.refresh(db_patient)
    return db_patient

async def update_patient(db: AsyncSession, db_patient: Patient, patient_in: PatientUpdate) -> Patient:
    """Updates an existing patient record."""
    update_data = patient_in.model_dump(exclude_unset=True)
    for field, value in update_data.items():
        setattr(db_patient, field, value)
    await db.commit()
    await db.refresh(db_patient)
    return db_patient

def get_patient_update_diff(db_patient: Patient, patient_in: PatientUpdate) -> Dict[str, Any]:
    """Compares the current patient data with the update data to find changes."""
    diff = {"changes": []}
    update_data = patient_in.model_dump(exclude_unset=True)
    for field, new_value in update_data.items():
        old_value = getattr(db_patient, field)
        if str(old_value) != str(new_value):
            diff["changes"].append({
                "field": field,
                "old_value": str(old_value),
                "new_value": str(new_value)
            })
    return diff


# --- /api/v1/endpoints/auth.py ---
# Description: API endpoints for user authentication and token generation.
#
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession
from datetime import timedelta
from core.config import settings
from core.security import create_access_token, verify_password
from schemas.token import Token
from schemas.user import UserCreate
from crud import crud_user
from db.session import get_db_session

router = APIRouter()

@router.post("/token", response_model=Token, tags=["Authentication"])
async def login_for_access_token(
    db: AsyncSession = Depends(get_db_session),
    form_data: OAuth2PasswordRequestForm = Depends()
):
    """Provides a JWT for valid user credentials."""
    user = await crud_user.get_user_by_username(db, username=form_data.username)
    if not user or not verify_password(form_data.password, user.hashed_password) or not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username, "role": user.role}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

@router.post("/users/create", response_model=UserInDB, status_code=status.HTTP_201_CREATED, include_in_schema=False)
async def create_system_user(user: UserCreate, db: AsyncSession = Depends(get_db_session)):
    """
    Endpoint to create system users (e.g., for system setup).
    In a real system, this would be heavily protected and restricted to super-admins.
    """
    db_user = await crud_user.get_user_by_username(db, username=user.username)
    if db_user:
        raise HTTPException(status_code=400, detail="Username already registered")
    return await crud_user.create_user(db=db, user=user)


# --- /api/v1/api.py ---
# Description: Defines API dependencies for security and auditing, and ties routers together.
#
from fastapi import APIRouter, Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.ext.asyncio import AsyncSession
from pydantic import ValidationError

from core.config import settings
from db.session import get_db_session
from models.user import User as UserModel
from schemas.token import TokenData
from schemas.audit_log import AuditLogCreate
from crud import crud_user, crud_audit

from api.v1.endpoints import patients, auth

# Main router for API v1
api_router = APIRouter()

# Authentication scheme
oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{settings.API_V1_STR}/auth/token")

async def get_current_user(
    db: AsyncSession = Depends(get_db_session), token: str = Depends(oauth2_scheme)
) -> UserModel:
    """Decodes JWT and retrieves the current authenticated user."""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except (JWTError, ValidationError):
        raise credentials_exception
        
    user = await crud_user.get_user_by_username(db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(
    current_user: UserModel = Depends(get_current_user)
) -> UserModel:
    """Ensures the retrieved user is active."""
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user

async def get_user_with_phi_access(
    current_user: UserModel = Depends(get_current_active_user)
) -> UserModel:
    """
    Ensures the user has a role permitted to access PHI,
    as defined in the application settings.
    """
    if current_user.role not in settings.PHI_ACCESS_ROLES:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="The user does not have sufficient privileges for this resource"
        )
    return current_user

class AuditLogger:
    """Dependency class to handle automatic audit logging for an endpoint."""
    def __init__(self, action: str, resource_type: str):
        self.action = action
        self.resource_type = resource_type

    async def __call__(
        self,
        request: Request,
        db: AsyncSession = Depends(get_db_session),
        user: UserModel = Depends(get_user_with_phi_access)
    ) -> None:
        async def log(status: str, resource_id: Optional[str] = None, details: Optional[dict] = None):
            log_entry = AuditLogCreate(
                user_id=user.id,
                action=self.action,
                resource_type=self.resource_type,
                resource_id=resource_id,
                status=status,
                ip_address=request.client.host,
                user_agent=request.headers.get("user-agent"),
                details=details or {}
            )
            await crud_audit.create_audit_log(db, log_entry)
        
        request.state.audit_log = log

# Include routers from endpoint modules
api_router.include_router(auth.router, prefix="/auth")
api_router.include_router(patients.router, prefix="/patients", tags=["Patients"])


# --- /api/v1/endpoints/patients.py ---
# Description: API endpoints for managing patient demographic data (PHI).
#
import uuid
from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Callable
from api.v1.api import get_user_with_phi_access, AuditLogger
from crud import crud_patient
from db.session import get_db_session
from models.user import User as UserModel
from schemas.patient import PatientCreate, PatientInDB, PatientUpdate

router = APIRouter()

@router.post("/", response_model=PatientInDB, status_code=status.HTTP_201_CREATED)
async def create_patient_record(
    patient_in: PatientCreate,
    request: Request,
    db: AsyncSession = Depends(get_db_session),
    audit_log: Callable = Depends(AuditLogger(action="PATIENT_CREATE", resource_type="Patient"))
):
    """
    Create a new patient record.
    Requires authenticated user with PHI access rights.
    """
    existing_patient = await crud_patient.get_patient_by_mrn(db, mrn=patient_in.mrn)
    if existing_patient:
        await audit_log(status="FAILURE", resource_id=patient_in.mrn, details={"error": "MRN already exists"})
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"Patient with MRN {patient_in.mrn} already exists."
        )
    
    patient = await crud_patient.create_patient(db=db, patient=patient_in)
    await audit_log(status="SUCCESS", resource_id=str(patient.id))
    return patient

@router.get("/{patient_id}", response_model=PatientInDB)
async def get_patient_by_id(
    patient_id: uuid.UUID,
    request: Request,
    db: AsyncSession = Depends(get_db_session),
    audit_log: Callable = Depends(AuditLogger(action="PATIENT_VIEW", resource_type="Patient"))
):
    """
    Retrieve a patient's demographic data by their internal ID.
    Requires authenticated user with PHI access rights.
    """
    patient = await crud_patient.get_patient_by_id(db, patient_id=patient_id)
    if not patient:
        await audit_log(status="FAILURE", resource_id=str(patient_id), details={"error": "Patient not found"})
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Patient not found")
    
    await audit_log(status="SUCCESS", resource_id=str(patient.id))
    return patient

@router.put("/{patient_id}", response_model=PatientInDB)
async def update_patient_record(
    patient_id: uuid.UUID,
    patient_in: PatientUpdate,
    request: Request,
    db: AsyncSession = Depends(get_db_session),
    audit_log: Callable = Depends(AuditLogger(action="PATIENT_UPDATE", resource_type="Patient"))
):
    """
    Update a patient's demographic information.
    Requires authenticated user with PHI access rights.
    """
    db_patient = await crud_patient.get_patient_by_id(db, patient_id=patient_id)
    if not db_patient:
        await audit_log(status="FAILURE", resource_id=str(patient_id), details={"error": "Patient not found"})
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Patient not found")
    
    # Do not allow MRN to be updated via this endpoint
    if patient_in.model_dump(exclude_unset=True).get("mrn"):
         await audit_log(status="FAILURE", resource_id=str(patient_id), details={"error": "MRN update not allowed"})
         raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="MRN updates are not permitted.")

    update_diff = crud_patient.get_patient_update_diff(db_patient, patient_in)
    
    if not update_diff["changes"]:
        await audit_log(status="SUCCESS", resource_id=str(patient_id), details={"info": "No changes detected"})
        return db_patient # Return original record if no changes
        
    updated_patient = await crud_patient.update_patient(db=db, db_patient=db_patient, patient_in=patient_in)
    await audit_log(status="SUCCESS", resource_id=str(patient_id), details=update_diff)
    return updated_patient


# --- /main.py ---
# Description: Main FastAPI application entry point.
#
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from starlette.middleware.cors import CORSMiddleware
from core.config import settings
from api.v1.api import api_router
from db.session import Base, async_engine
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_STR}/openapi.json"
)

# Exception handler to prevent leaking internal error details
@app.exception_handler(Exception)
async def validation_exception_handler(request: Request, exc: Exception):
    logger.error(f"An unhandled exception occurred for request {request.method} {request.url}: {exc}", exc_info=True)
    return JSONResponse(
        status_code=500,
        content={"detail": "An internal server error occurred. The incident has been logged."},
    )

# Set all CORS enabled origins
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], # In production, restrict this to known frontend domains.
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Startup event to create database tables
@app.on_event("startup")
async def on_startup():
    async with async_engine.begin() as conn:
        # The following command creates all tables defined by models
        # that inherit from Base. Use Alembic for production migrations.
        # await conn.run_sync(Base.metadata.drop_all) # Use for development reset
        await conn.run_sync(Base.metadata.create_all)
    logger.info("Database tables verified/created.")

# Include the main API router
app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/", include_in_schema=False)
def read_root():
    return {"status": "EMR Backend Service is running."}

# To run this application:
# 1. Set environment variables for SECRET_KEY and DATABASE_URL.
# 2. Install dependencies: uvicorn, fastapi, sqlalchemy[asyncpg], pydantic[email], python-jose[cryptography], passlib[bcrypt], pydantic-settings
# 3. Run with uvicorn: `uvicorn main:app --reload`

# Example of creating a user for testing (can be done via a script or the include_in_schema=False endpoint):
# curl -X POST "http://127.0.0.1:8000/api/v1/auth/users/create" \
# -H "Content-Type: application/json" \
# -d '{"username": "dr.house", "password": "securepassword123", "full_name": "Gregory House", "role": "clinician"}'

```