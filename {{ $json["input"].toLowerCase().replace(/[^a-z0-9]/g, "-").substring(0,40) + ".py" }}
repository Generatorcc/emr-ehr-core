```python
# /core/config.py
# Description: Centralized configuration management for the application.
# All settings, including secrets, are loaded from environment variables
# to adhere to 12-factor app principles.

import os
from pydantic import BaseSettings, PostgresDsn, AnyHttpUrl
from typing import List

class Settings(BaseSettings):
    """Application settings."""
    # Core settings
    API_V1_STR: str = "/api/v1"
    PROJECT_NAME: str = "EMR Backend System"

    # Security settings
    # The SECRET_KEY should be a long, random string.
    # In production, this MUST be loaded from a secure vault or environment variable.
    # Command to generate a key: `openssl rand -hex 32`
    SECRET_KEY: str = os.getenv("SECRET_KEY", "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7")
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30

    # CORS settings
    BACKEND_CORS_ORIGINS: List[AnyHttpUrl] = [
        "https://localhost:3000",
        "https://localhost:8080",
        "https://emr.clinic-domain.com",
    ]

    # Database settings
    # The DATABASE_URL must include the driver, user, password, host, port, and db name.
    # Example: postgresql+asyncpg://user:password@host:port/db
    DATABASE_URL: PostgresDsn = os.getenv("DATABASE_URL", "postgresql+asyncpg://postgres:changethis@localhost:5432/emr_db")

    # Encrypted storage settings (e.g., AWS S3)
    S3_BUCKET_NAME: str = os.getenv("S3_BUCKET_NAME", "emr-secure-documents")
    S3_ACCESS_KEY: str = os.getenv("S3_ACCESS_KEY", "your-access-key")
    S3_SECRET_KEY: str = os.getenv("S3_SECRET_KEY", "your-secret-key")
    S3_REGION: str = os.getenv("S3_REGION", "us-west-2")
    PRESIGNED_URL_EXPIRATION_SECONDS: int = 3600 # 1 hour

    class Config:
        case_sensitive = True

settings = Settings()

# /db/session.py
# Description: Database session management using SQLAlchemy's async capabilities.
# Creates a single engine and session factory to be used across the application.

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from core.config import settings

engine = create_async_engine(settings.DATABASE_URL, pool_pre_ping=True, echo=False)
AsyncSessionLocal = sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autocommit=False,
    autoflush=False
)

async def get_db_session() -> AsyncSession:
    """Dependency to get a database session."""
    async with AsyncSessionLocal() as session:
        yield session

# /models/base.py
# Description: Base model for all SQLAlchemy ORM models.

from sqlalchemy.ext.declarative import as_declarative, declared_attr

@as_declarative()
class Base:
    """Base class for SQLAlchemy models."""
    id: int
    __name__: str

    # Generate __tablename__ automatically
    @declared_attr
    def __tablename__(cls) -> str:
        return cls.__name__.lower() + "s"

# /models/user.py
# Description: SQLAlchemy model for a system user (e.g., clinician, admin).

import uuid
from sqlalchemy import Column, String, Boolean, DateTime, func, Enum as SQLAlchemyEnum
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from .base import Base

class User(Base):
    """Represents a system user."""
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username = Column(String, unique=True, index=True, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, index=True)
    role = Column(String, nullable=False) # e.g., 'physician', 'nurse', 'admin'
    is_active = Column(Boolean(), default=True)
    created_at = Column(DateTime, default=func.now())
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())

    # Relationships
    patient_associations = relationship("PatientClinicianAssociation", back_populates="clinician")
    audit_logs = relationship("AuditLog", back_populates="user")

# /models/patient.py
# Description: SQLAlchemy model for a patient.

import uuid
from sqlalchemy import Column, String, Date, DateTime, func, Enum as SQLAlchemyEnum
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from .base import Base

class Patient(Base):
    """Represents a patient in the EMR."""
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    mrn = Column(String, unique=True, index=True, nullable=False) # Medical Record Number
    first_name = Column(String, nullable=False)
    last_name = Column(String, nullable=False)
    date_of_birth = Column(Date, nullable=False)
    gender = Column(SQLAlchemyEnum('male', 'female', 'other', name='gender_enum'), nullable=False)
    created_at = Column(DateTime, default=func.now())
    updated_at = Column(DateTime, default=func.now(), onupdate=func.now())

    # Relationships
    clinician_associations = relationship("PatientClinicianAssociation", back_populates="patient")
    lab_results = relationship("LabResult", back_populates="patient")

# /models/lab_result.py
# Description: SQLAlchemy model for a patient's lab result.

import uuid
from sqlalchemy import Column, String, DateTime, func, ForeignKey, Text
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import relationship
from .base import Base

class LabResult(Base):
    """Represents a specific lab result for a patient."""
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    patient_id = Column(UUID(as_uuid=True), ForeignKey("patients.id"), nullable=False, index=True)
    ordering_clinician_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)

    loinc_code = Column(String, index=True, nullable=False) # LOINC for test type
    test_name = Column(String, nullable=False)
    result_value = Column(String)
    result_units = Column(String)
    reference_range = Column(String)
    abnormal_flag = Column(String) # e.g., 'H', 'L', 'A'
    observation_datetime = Column(DateTime, nullable=False)
    status = Column(String, default='final', nullable=False) # e.g., 'preliminary', 'final', 'corrected'
    notes = Column(Text)
    structured_data = Column(JSONB) # For complex, nested results
    report_document_s3_key = Column(String) # Key for the PDF report in encrypted S3

    created_at = Column(DateTime, default=func.now())

    # Relationships
    patient = relationship("Patient", back_populates="lab_results")
    ordering_clinician = relationship("User")

# /models/patient_clinician_association.py
# Description: Association table defining the relationship between patients and clinicians.
# This is crucial for HIPAA authorization logic.

import uuid
from sqlalchemy import Column, ForeignKey, String
from sqlalchemy.dialects.postgresql import UUID
from .base import Base

class PatientClinicianAssociation(Base):
    """Maps clinicians to patients with a specific relationship type."""
    patient_id = Column(UUID(as_uuid=True), ForeignKey('patients.id'), primary_key=True)
    clinician_id = Column(UUID(as_uuid=True), ForeignKey('users.id'), primary_key=True)
    relationship_type = Column(String, nullable=False) # e.g., 'PCP', 'Consulting', 'Ordering'

    patient = relationship("Patient", back_populates="clinician_associations")
    clinician = relationship("User", back_populates="patient_associations")


# /models/audit_log.py
# Description: SQLAlchemy model for HIPAA audit logs.

import uuid
from sqlalchemy import Column, String, DateTime, func, ForeignKey, Enum as SQLAlchemyEnum
from sqlalchemy.dialects.postgresql import UUID, INET
from sqlalchemy.orm import relationship
from .base import Base

class AuditAction(SQLAlchemyEnum):
    """Enum for audit log actions."""
    VIEW = "VIEW"
    CREATE = "CREATE"
    UPDATE = "UPDATE"
    DELETE = "DELETE"
    LOGIN_SUCCESS = "LOGIN_SUCCESS"
    LOGIN_FAIL = "LOGIN_FAIL"
    ACCESS_DENIED = "ACCESS_DENIED"

class AuditLog(Base):
    """Records security-relevant events as per HIPAA requirements."""
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True, index=True) # Nullable for system events
    patient_id = Column(UUID(as_uuid=True), ForeignKey("patients.id"), nullable=True, index=True) # Nullable if not patient-specific
    action = Column(SQLAlchemyEnum(AuditAction, name='audit_action_enum'), nullable=False)
    timestamp = Column(DateTime, default=func.now(), nullable=False)
    ip_address = Column(INET, nullable=True)
    resource_accessed = Column(String) # e.g., 'LabResult/uuid' or 'Patient/mrn'
    details = Column(String) # e.g., 'User viewed lab result'

    # Relationships
    user = relationship("User", back_populates="audit_logs")

# /schemas/token.py
# Description: Pydantic models for authentication tokens.

from pydantic import BaseModel
from typing import Optional

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

# /schemas/user.py
# Description: Pydantic models for user data serialization.

import uuid
from pydantic import BaseModel, EmailStr

class UserBase(BaseModel):
    username: str
    email: EmailStr
    full_name: Optional[str] = None
    role: str

class UserInDB(UserBase):
    id: uuid.UUID
    is_active: bool

    class Config:
        orm_mode = True

# /schemas/lab_result.py
# Description: Pydantic models for lab result data serialization.

import uuid
from pydantic import BaseModel
from datetime import datetime
from typing import Optional, Any

class LabResultBase(BaseModel):
    loinc_code: str
    test_name: str
    result_value: Optional[str]
    result_units: Optional[str]
    reference_range: Optional[str]
    abnormal_flag: Optional[str]
    observation_datetime: datetime
    status: str
    notes: Optional[str]

class LabResultResponse(LabResultBase):
    id: uuid.UUID
    patient_id: uuid.UUID
    ordering_clinician_id: uuid.UUID
    report_document_url: Optional[str] = None # Secure, time-limited URL

    class Config:
        orm_mode = True

# /schemas/audit_log.py
# Description: Pydantic model for creating audit log entries.

import uuid
from pydantic import BaseModel
from typing import Optional
from models.audit_log import AuditAction

class AuditLogCreate(BaseModel):
    user_id: uuid.UUID
    action: AuditAction
    ip_address: Optional[str] = None
    patient_id: Optional[uuid.UUID] = None
    resource_accessed: Optional[str] = None
    details: Optional[str] = None

# /core/security.py
# Description: Handles password hashing, JWT creation/verification, and OAuth2 flow.

from datetime import datetime, timedelta
from typing import Optional, Any
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.ext.asyncio import AsyncSession
from core.config import settings
from db.session import get_db_session
from models.user import User
from schemas.token import TokenData
import crud.crud_user as crud_user

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{settings.API_V1_STR}/auth/token")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifies a plain password against a hashed one."""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hashes a plain password."""
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Creates a JWT access token."""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

async def get_current_user(
    db: AsyncSession = Depends(get_db_session), token: str = Depends(oauth2_scheme)
) -> User:
    """Dependency to get the current authenticated user from a JWT."""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except JWTError:
        raise credentials_exception
    
    user = await crud_user.get_by_username(db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(current_user: User = Depends(get_current_user)) -> User:
    """Dependency to ensure the current user is active."""
    if not current_user.is_active:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")
    return current_user

# /services/secure_document_storage.py
# Description: Service for interacting with secure, encrypted storage like AWS S3.

import boto3
from botocore.exceptions import ClientError
from core.config import settings

class SecureDocumentService:
    """Service for handling documents in a secure S3 bucket."""
    def __init__(self):
        self.s3_client = boto3.client(
            's3',
            aws_access_key_id=settings.S3_ACCESS_KEY,
            aws_secret_access_key=settings.S3_SECRET_KEY,
            region_name=settings.S3_REGION
        )

    def generate_presigned_url(self, object_key: str) -> Optional[str]:
        """Generates a time-limited, pre-signed URL to access an S3 object."""
        if not object_key:
            return None
        try:
            url = self.s3_client.generate_presigned_url(
                'get_object',
                Params={'Bucket': settings.S3_BUCKET_NAME, 'Key': object_key},
                ExpiresIn=settings.PRESIGNED_URL_EXPIRATION_SECONDS
            )
            return url
        except ClientError as e:
            # In a real system, log this error appropriately
            print(f"Error generating pre-signed URL: {e}")
            return None

secure_document_service = SecureDocumentService()

# /crud/crud_user.py
# Description: CRUD operations for the User model.

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from models.user import User
from typing import Optional

async def get_by_username(db: AsyncSession, *, username: str) -> Optional[User]:
    """Retrieve a user by their username."""
    result = await db.execute(select(User).filter(User.username == username))
    return result.scalars().first()

# /crud/crud_audit_log.py
# Description: CRUD operations for the AuditLog model.

from sqlalchemy.ext.asyncio import AsyncSession
from models.audit_log import AuditLog
from schemas.audit_log import AuditLogCreate

async def create_audit_log(db: AsyncSession, *, obj_in: AuditLogCreate) -> AuditLog:
    """Create a new audit log entry."""
    db_obj = AuditLog(**obj_in.dict(exclude_unset=True))
    db.add(db_obj)
    await db.commit()
    await db.refresh(db_obj)
    return db_obj

# /crud/crud_lab_result.py
# Description: CRUD operations for the LabResult model, including authorization checks.

import uuid
from typing import Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from models.lab_result import LabResult
from models.patient_clinician_association import PatientClinicianAssociation
from models.user import User

async def get_by_id(db: AsyncSession, *, result_id: uuid.UUID) -> Optional[LabResult]:
    """Retrieve a lab result by its ID."""
    result = await db.execute(
        select(LabResult)
        .options(selectinload(LabResult.patient))
        .filter(LabResult.id == result_id)
    )
    return result.scalars().first()

async def is_clinician_authorized_for_patient(
    db: AsyncSession, *, clinician_id: uuid.UUID, patient_id: uuid.UUID
) -> bool:
    """
    Checks if a clinician has an established relationship with a patient.
    This is a critical HIPAA authorization check.
    """
    query = select(PatientClinicianAssociation).filter(
        PatientClinicianAssociation.clinician_id == clinician_id,
        PatientClinicianAssociation.patient_id == patient_id
    )
    result = await db.execute(query)
    return result.scalars().first() is not None

# /api/v1/dependencies.py
# Description: Shared API dependencies, including authorization checks.

import uuid
from fastapi import Depends, HTTPException, status, Request
from sqlalchemy.ext.asyncio import AsyncSession
from db.session import get_db_session
from core.security import get_current_active_user
from models.user import User
import crud.crud_lab_result as crud_lab_result
import crud.crud_audit_log as crud_audit_log
from schemas.audit_log import AuditLogCreate
from models.audit_log import AuditAction

async def get_authorized_patient_context(
    patient_id: uuid.UUID,
    current_user: User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db_session),
    request: Request = None
) -> uuid.UUID:
    """
    Dependency that verifies if the current clinician user is authorized
    to access data for the given patient_id.
    Logs failed access attempts.
    """
    is_authorized = await crud_lab_result.is_clinician_authorized_for_patient(
        db=db, clinician_id=current_user.id, patient_id=patient_id
    )
    if not is_authorized:
        # Create an audit log for the failed access attempt
        audit_log = AuditLogCreate(
            user_id=current_user.id,
            action=AuditAction.ACCESS_DENIED,
            ip_address=request.client.host if request else None,
            patient_id=patient_id,
            resource_accessed=f"Patient/{patient_id}",
            details="User attempted to access data for a patient they are not associated with."
        )
        await crud_audit_log.create_audit_log(db=db, obj_in=audit_log)
        
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User not authorized to access this patient's records."
        )
    
    return patient_id

# /api/v1/endpoints/lab_results.py
# Description: API endpoint for securely fetching patient lab results.

import uuid
from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.ext.asyncio import AsyncSession

from db.session import get_db_session
from models.user import User
from schemas.lab_result import LabResultResponse
from schemas.audit_log import AuditLogCreate
from models.audit_log import AuditAction
import crud.crud_lab_result as crud
import crud.crud_audit_log as crud_audit
from api.v1.dependencies import get_authorized_patient_context
from core.security import get_current_active_user
from services.secure_document_storage import secure_document_service

router = APIRouter()

@router.get(
    "/{lab_result_id}",
    response_model=LabResultResponse,
    summary="Fetch a Specific Lab Result for a Patient",
    description="""
    Retrieves the details of a single lab result.
    Access is strictly controlled:
    - User must be an authenticated, active clinician.
    - Clinician must have a pre-existing relationship with the patient.
    - All access is logged for HIPAA auditing purposes.
    """
)
async def read_lab_result(
    lab_result_id: uuid.UUID,
    patient_id: uuid.UUID = Depends(get_authorized_patient_context),
    db: AsyncSession = Depends(get_db_session),
    current_user: User = Depends(get_current_active_user),
    request: Request = None,
):
    """
    Securely fetches a lab result, performs authorization, and creates an audit log.
    """
    lab_result = await crud.get_by_id(db=db, result_id=lab_result_id)

    if not lab_result or lab_result.patient_id != patient_id:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Lab result not found for this patient")

    # Log the successful access event
    audit_log = AuditLogCreate(
        user_id=current_user.id,
        action=AuditAction.VIEW,
        ip_address=request.client.host if request else None,
        patient_id=patient_id,
        resource_accessed=f"LabResult/{lab_result_id}",
        details=f"User '{current_user.username}' viewed lab result '{lab_result.test_name}'."
    )
    await crud_audit.create_audit_log(db=db, obj_in=audit_log)

    # Prepare response, including generating a secure URL for any associated document
    response_data = LabResultResponse.from_orm(lab_result)
    if lab_result.report_document_s3_key:
        response_data.report_document_url = secure_document_service.generate_presigned_url(
            object_key=lab_result.report_document_s3_key
        )

    return response_data

# /api/v1/endpoints/auth.py
# Description: API endpoints for user authentication.

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Any

from db.session import get_db_session
from schemas.token import Token
from core.security import create_access_token, verify_password
import crud.crud_user as crud_user

router = APIRouter()

@router.post("/token", response_model=Token)
async def login_for_access_token(
    db: AsyncSession = Depends(get_db_session), form_data: OAuth2PasswordRequestForm = Depends()
) -> Any:
    """
    OAuth2 compatible token endpoint.
    """
    user = await crud_user.get_by_username(db, username=form_data.username)
    if not user or not verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    if not user.is_active:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")

    access_token = create_access_token(data={"sub": user.username})
    return {"access_token": access_token, "token_type": "bearer"}

# /api/v1/api.py
# Description: Aggregates all API routers for a specific version.

from fastapi import APIRouter
from api.v1.endpoints import lab_results, auth

api_router = APIRouter()
api_router.include_router(auth.router, prefix="/auth", tags=["Authentication"])
api_router.include_router(
    lab_results.router,
    prefix="/patients/{patient_id}/lab-results",
    tags=["Lab Results"],
)

# /main.py
# Description: Main application entry point.
# Initializes the FastAPI app, sets up middleware, and includes API routers.

from fastapi import FastAPI
from starlette.middleware.cors import CORSMiddleware
from core.config import settings
from api.v1.api import api_router

# Initialize FastAPI application
app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_STR}/openapi.json",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Set all CORS enabled origins
if settings.BACKEND_CORS_ORIGINS:
    app.add_middleware(
        CORSMiddleware,
        allow_origins=[str(origin) for origin in settings.BACKEND_CORS_ORIGINS],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

# Include API routers
app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/", summary="System Health Check")
def read_root():
    """Provides a basic health check endpoint for monitoring."""
    return {"status": "ok", "project": settings.PROJECT_NAME}

```