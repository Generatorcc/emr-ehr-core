```python
# /core/config.py

import os
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    """
    Application settings loaded from environment variables.
    """
    # Application
    PROJECT_NAME: str = "EMR Backend System"
    API_V1_STR: str = "/api/v1"

    # Database
    DATABASE_URL: str = os.getenv("DATABASE_URL", "postgresql+asyncpg://user:password@localhost/emr_db")
    
    # Security
    SECRET_KEY: str = os.getenv("SECRET_KEY", "a_very_secret_key_that_must_be_changed")
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # AWS S3 for Document Storage
    S3_BUCKET_NAME: str = os.getenv("S3_BUCKET_NAME", "emr-secure-documents")
    S3_ACCESS_KEY_ID: str = os.getenv("S3_ACCESS_KEY_ID", "minioadmin")
    S3_SECRET_ACCESS_KEY: str = os.getenv("S3_SECRET_ACCESS_KEY", "minioadmin")
    S3_ENDPOINT_URL: str | None = os.getenv("S3_ENDPOINT_URL", None) # For MinIO/LocalStack
    S3_PRESIGNED_URL_EXPIRATION_SECONDS: int = 3600 # 1 hour

    class Config:
        case_sensitive = True
        env_file = ".env"

settings = Settings()

# /db/database.py

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from core.config import settings

engine = create_async_engine(settings.DATABASE_URL, pool_pre_ping=True, echo=False)
AsyncSessionLocal = sessionmaker(
    autocommit=False, 
    autoflush=False, 
    bind=engine, 
    class_=AsyncSession
)

Base = declarative_base()

async def get_db() -> AsyncSession:
    """
    Dependency to get an async database session.
    """
    async with AsyncSessionLocal() as session:
        yield session

# /db/models.py

import uuid
from sqlalchemy import (
    Column, String, DateTime, ForeignKey, Text, Enum as SQLAlchemyEnum
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from enum import Enum

from db.database import Base

class UserRole(str, Enum):
    PHYSICIAN = "physician"
    NURSE = "nurse"
    ADMIN = "admin"
    PATIENT = "patient"

class AuditLogAction(str, Enum):
    DOCUMENT_UPLOAD = "DOCUMENT_UPLOAD"
    DOCUMENT_METADATA_VIEW = "DOCUMENT_METADATA_VIEW"
    DOCUMENT_DOWNLOAD = "DOCUMENT_DOWNLOAD"
    DOCUMENT_DELETE = "DOCUMENT_DELETE"
    PATIENT_RECORD_VIEW = "PATIENT_RECORD_VIEW"
    LOGIN_SUCCESS = "LOGIN_SUCCESS"
    LOGIN_FAILURE = "LOGIN_FAILURE"

class User(Base):
    __tablename__ = "users"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, nullable=False)
    role = Column(SQLAlchemyEnum(UserRole), nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

class Patient(Base):
    __tablename__ = "patients"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    first_name = Column(String, nullable=False)
    last_name = Column(String, nullable=False)
    date_of_birth = Column(Date, nullable=False)
    # Medical Record Number
    mrn = Column(String, unique=True, index=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    documents = relationship("Document", back_populates="patient", cascade="all, delete-orphan")

class Document(Base):
    __tablename__ = "documents"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    patient_id = Column(UUID(as_uuid=True), ForeignKey("patients.id"), nullable=False, index=True)
    uploader_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    
    document_type = Column(String, nullable=False)
    description = Column(Text)
    
    # S3 Storage Details
    s3_bucket = Column(String, nullable=False)
    s3_key = Column(String, unique=True, nullable=False)
    
    # File metadata
    filename = Column(String, nullable=False)
    content_type = Column(String, nullable=False)
    file_size = Column(Integer, nullable=False)
    checksum_sha256 = Column(String, nullable=False)
    
    is_deleted = Column(Boolean, default=False, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    deleted_at = Column(DateTime(timezone=True), nullable=True)

    patient = relationship("Patient", back_populates="documents")
    uploader = relationship("User")

class AuditLog(Base):
    __tablename__ = "audit_logs"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True, index=True) # Nullable for system events
    patient_id = Column(UUID(as_uuid=True), ForeignKey("patients.id"), nullable=True, index=True)
    action = Column(SQLAlchemyEnum(AuditLogAction), nullable=False)
    timestamp = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    details = Column(Text, nullable=True) # e.g., IP address, user agent
    target_resource_id = Column(String, nullable=True) # e.g., Document ID

# /schemas/user.py

import uuid
from pydantic import BaseModel
from db.models import UserRole

class UserBase(BaseModel):
    username: str
    full_name: str
    role: UserRole

class UserInDB(UserBase):
    id: uuid.UUID
    is_active: bool
    
    class Config:
        from_attributes = True

# /schemas/token.py

from pydantic import BaseModel

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: str | None = None

# /schemas/document.py

import uuid
from pydantic import BaseModel, Field
from datetime import datetime

class DocumentMetadataBase(BaseModel):
    document_type: str = Field(..., description="Type of the document, e.g., 'Lab Result', 'Imaging Report'.")
    description: str | None = Field(None, description="Optional description of the document.")

class DocumentMetadataResponse(DocumentMetadataBase):
    id: uuid.UUID
    patient_id: uuid.UUID
    uploader_id: uuid.UUID
    filename: str
    content_type: str
    file_size: int
    created_at: datetime
    
    class Config:
        from_attributes = True

class DocumentDownloadResponse(BaseModel):
    download_url: str = Field(..., description="A secure, time-limited URL to download the document.")
    expires_at: datetime = Field(..., description="The UTC timestamp when the URL will expire.")

# /services/s3_service.py

import boto3
from botocore.client import Config
from botocore.exceptions import ClientError
from fastapi import UploadFile, HTTPException, status
from typing import IO
import hashlib

from core.config import settings

class S3Service:
    def __init__(self):
        self.s3_client = boto3.client(
            "s3",
            aws_access_key_id=settings.S3_ACCESS_KEY_ID,
            aws_secret_access_key=settings.S3_SECRET_ACCESS_KEY,
            endpoint_url=settings.S3_ENDPOINT_URL,
            config=Config(signature_version="s3v4")
        )
        self.bucket_name = settings.S3_BUCKET_NAME

    def upload_file(
        self, file_object: IO, s3_key: str, content_type: str
    ) -> bool:
        """Uploads a file object to an S3 bucket."""
        try:
            self.s3_client.upload_fileobj(
                file_object,
                self.bucket_name,
                s3_key,
                ExtraArgs={"ContentType": content_type, "ServerSideEncryption": "AES256"}
            )
        except ClientError as e:
            # In a real system, log this error extensively.
            raise HTTPException(
                status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                detail="Could not upload file to secure storage."
            )
        return True

    def generate_presigned_url(self, s3_key: str) -> str | None:
        """Generate a presigned URL to share an S3 object."""
        try:
            response = self.s3_client.generate_presigned_url(
                'get_object',
                Params={'Bucket': self.bucket_name, 'Key': s3_key},
                ExpiresIn=settings.S3_PRESIGNED_URL_EXPIRATION_SECONDS
            )
        except ClientError as e:
            return None
        return response

    async def get_file_metadata(self, file: UploadFile):
        """Calculates file size and checksum without loading it all into memory."""
        sha256_hash = hashlib.sha256()
        size = 0
        while chunk := await file.read(8192):
            sha256_hash.update(chunk)
            size += len(chunk)
        await file.seek(0)
        return {"size": size, "checksum": sha256_hash.hexdigest()}

s3_service = S3Service()

# /services/audit_service.py

from sqlalchemy.ext.asyncio import AsyncSession
from db.models import AuditLog, AuditLogAction
from schemas.user import UserInDB
from uuid import UUID

class AuditService:
    async def log_event(
        self,
        db: AsyncSession,
        user: UserInDB,
        action: AuditLogAction,
        patient_id: UUID | None = None,
        target_resource_id: str | None = None,
        details: str | None = None
    ):
        """Creates an audit log entry."""
        log_entry = AuditLog(
            user_id=user.id,
            action=action,
            patient_id=patient_id,
            target_resource_id=target_resource_id,
            details=details,
        )
        db.add(log_entry)
        await db.commit()

audit_service = AuditService()

# /core/security.py

from datetime import datetime, timedelta, timezone
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from pydantic import ValidationError

from core.config import settings
from db.database import get_db
from db.models import User
from schemas.token import TokenData
from schemas.user import UserInDB

oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{settings.API_V1_STR}/auth/token")

async def get_user(db: AsyncSession, username: str) -> User | None:
    query = select(User).where(User.username == username)
    result = await db.execute(query)
    return result.scalars().first()

async def get_current_user(
    token: str = Depends(oauth2_scheme), db: AsyncSession = Depends(get_db)
) -> UserInDB:
    """Decodes JWT token and retrieves the current user."""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except (JWTError, ValidationError):
        raise credentials_exception
    
    user = await get_user(db, username=token_data.username)
    if user is None:
        raise credentials_exception
        
    return UserInDB.model_validate(user)

async def get_current_active_user(
    current_user: UserInDB = Depends(get_current_user),
) -> UserInDB:
    """Checks if the user retrieved from token is active."""
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user

# /db/crud.py

import uuid
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from fastapi import UploadFile

from db import models
from schemas import document as document_schemas
from core.config import settings

async def create_document(
    db: AsyncSession,
    patient_id: uuid.UUID,
    uploader_id: uuid.UUID,
    file: UploadFile,
    file_meta: dict,
    document_data: document_schemas.DocumentMetadataBase
) -> models.Document:
    """
    Creates a new document record in the database.
    """
    s3_key = f"{patient_id}/{uuid.uuid4()}-{file.filename}"
    
    db_document = models.Document(
        patient_id=patient_id,
        uploader_id=uploader_id,
        document_type=document_data.document_type,
        description=document_data.description,
        s3_bucket=settings.S3_BUCKET_NAME,
        s3_key=s3_key,
        filename=file.filename,
        content_type=file.content_type,
        file_size=file_meta["size"],
        checksum_sha256=file_meta["checksum"]
    )
    db.add(db_document)
    await db.commit()
    await db.refresh(db_document)
    return db_document

async def get_documents_by_patient_id(
    db: AsyncSession, patient_id: uuid.UUID, skip: int = 0, limit: int = 100
) -> list[models.Document]:
    """Retrieves a list of non-deleted documents for a given patient."""
    query = (
        select(models.Document)
        .where(models.Document.patient_id == patient_id, models.Document.is_deleted == False)
        .offset(skip)
        .limit(limit)
        .order_by(models.Document.created_at.desc())
    )
    result = await db.execute(query)
    return result.scalars().all()

async def get_document_by_id(
    db: AsyncSession, document_id: uuid.UUID
) -> models.Document | None:
    """Retrieves a single non-deleted document by its ID."""
    query = select(models.Document).where(
        models.Document.id == document_id, models.Document.is_deleted == False
    )
    result = await db.execute(query)
    return result.scalars().first()

# /api/v1/endpoints/documents.py

import uuid
from datetime import datetime, timedelta, timezone
from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Form
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List

from db import crud, models
from db.database import get_db
from schemas.user import UserInDB
from schemas import document as document_schemas
from core.config import settings
from core.security import get_current_active_user
from services.s3_service import s3_service
from services.audit_service import audit_service, AuditLogAction

router = APIRouter()

def check_authorization(user: UserInDB, patient_id: uuid.UUID):
    """
    Placeholder for a real authorization check.
    In a real system, this would query a relationship table to see if the user
    (e.g., a physician) is assigned to this patient.
    For this example, we'll allow physicians and admins to access any record.
    """
    if user.role not in [models.UserRole.PHYSICIAN, models.UserRole.ADMIN]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User does not have permission to access this patient's records."
        )

@router.post(
    "/patients/{patient_id}/documents",
    response_model=document_schemas.DocumentMetadataResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Upload a new medical document for a patient."
)
async def upload_document(
    patient_id: uuid.UUID,
    document_type: str = Form(...),
    description: str | None = Form(None),
    file: UploadFile = File(...),
    db: AsyncSession = Depends(get_db),
    current_user: UserInDB = Depends(get_current_active_user)
):
    check_authorization(current_user, patient_id)

    # Validate file type if necessary (e.g., only PDFs, DICOM, etc.)
    if file.content_type not in ["application/pdf", "image/jpeg", "image/png"]:
        raise HTTPException(status.HTTP_400_BAD_REQUEST, "Unsupported file type.")

    file_meta = await s3_service.get_file_metadata(file)

    document_data = document_schemas.DocumentMetadataBase(
        document_type=document_type, description=description
    )

    db_document = await crud.create_document(
        db, patient_id, current_user.id, file, file_meta, document_data
    )

    s3_service.upload_file(file.file, db_document.s3_key, file.content_type)
    
    await audit_service.log_event(
        db, current_user, AuditLogAction.DOCUMENT_UPLOAD, 
        patient_id=patient_id, target_resource_id=str(db_document.id)
    )

    return db_document

@router.get(
    "/patients/{patient_id}/documents",
    response_model=List[document_schemas.DocumentMetadataResponse],
    summary="List all document metadata for a patient."
)
async def list_patient_documents(
    patient_id: uuid.UUID,
    skip: int = 0,
    limit: int = 100,
    db: AsyncSession = Depends(get_db),
    current_user: UserInDB = Depends(get_current_active_user)
):
    check_authorization(current_user, patient_id)
    
    documents = await crud.get_documents_by_patient_id(db, patient_id, skip, limit)
    
    await audit_service.log_event(
        db, current_user, AuditLogAction.DOCUMENT_METADATA_VIEW, patient_id=patient_id
    )

    return documents

@router.get(
    "/documents/{document_id}/download",
    response_model=document_schemas.DocumentDownloadResponse,
    summary="Get a secure, time-limited download URL for a document."
)
async def get_document_download_url(
    document_id: uuid.UUID,
    db: AsyncSession = Depends(get_db),
    current_user: UserInDB = Depends(get_current_active_user)
):
    document = await crud.get_document_by_id(db, document_id)
    if not document:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Document not found")

    check_authorization(current_user, document.patient_id)

    url = s3_service.generate_presigned_url(document.s3_key)
    if not url:
        raise HTTPException(status.HTTP_503_SERVICE_UNAVAILABLE, "Could not generate download link.")

    await audit_service.log_event(
        db, current_user, AuditLogAction.DOCUMENT_DOWNLOAD, 
        patient_id=document.patient_id, target_resource_id=str(document.id)
    )

    expiration_time = datetime.now(timezone.utc) + timedelta(seconds=settings.S3_PRESIGNED_URL_EXPIRATION_SECONDS)

    return document_schemas.DocumentDownloadResponse(
        download_url=url,
        expires_at=expiration_time
    )

# /main.py

from fastapi import FastAPI
from core.config import settings
from api.v1.endpoints import documents

app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_STR}/openapi.json",
    description="Backend for a secure, HIPAA-compliant Electronic Medical Record system.",
    version="1.0.0"
)

# This would contain other routers like authentication, patients, etc.
# For this example, we only include the documents router.
app.include_router(
    documents.router, 
    prefix=settings.API_V1_STR, 
    tags=["Documents"]
)

@app.get("/", include_in_schema=False)
def read_root():
    return {"status": "EMR Service is running."}

# To run this application:
# 1. Install dependencies:
#    pip install fastapi "uvicorn[standard]" pydantic pydantic-settings python-jose[cryptography] passlib[bcrypt] sqlalchemy[asyncpg] boto3 python-multipart
# 2. Set up a PostgreSQL database and an S3-compatible object store (like AWS S3 or MinIO).
# 3. Create a .env file with your configuration (DATABASE_URL, SECRET_KEY, S3 settings).
# 4. Initialize the database tables. A tool like Alembic is recommended for production.
# 5. Run the server: uvicorn main:app --reload
```