```python
# /core/config.py
import os
from pydantic_settings import BaseSettings


class Settings(BaseSettings):
    """
    Application configuration settings.
    Values are loaded from environment variables.
    """
    PROJECT_NAME: str = "EMR Secure Messaging Service"
    API_V1_STR: str = "/api/v1"

    # Security settings
    # In production, use a secrets manager. Generate with:
    # openssl rand -hex 32
    SECRET_KEY: str
    PGCRYPTO_KEY: str # Key for field-level database encryption
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60

    # Database settings
    POSTGRES_SERVER: str
    POSTGRES_USER: str
    POSTGRES_PASSWORD: str
    POSTGRES_DB: str
    DATABASE_URL: str | None = None

    class Config:
        env_file = ".env"
        case_sensitive = True

    def __init__(self, **values):
        super().__init__(**values)
        self.DATABASE_URL = (
            f"postgresql+asyncpg://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}"
            f"@{self.POSTGRES_SERVER}/{self.POSTGRES_DB}"
        )


settings = Settings()

# /db/base_class.py
from typing import Any
from sqlalchemy.ext.declarative import as_declarative, declared_attr


@as_declarative()
class Base:
    """Base class for SQLAlchemy models."""
    id: Any
    __name__: str

    # Generate __tablename__ automatically
    @declared_attr
    def __tablename__(cls) -> str:
        return cls.__name__.lower() + "s"

# /db/session.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from sqlalchemy.exc import SQLAlchemyError
from core.config import settings

# Create an async engine to the database
engine = create_async_engine(settings.DATABASE_URL, pool_pre_ping=True, echo=False)
AsyncSessionLocal = sessionmaker(
    engine, class_=AsyncSession, expire_on_commit=False
)

async def get_db() -> AsyncSession:
    """
    Dependency function that yields an AsyncSession.
    Ensures the session is closed after the request is finished.
    """
    async with AsyncSessionLocal() as session:
        try:
            yield session
        except SQLAlchemyError as e:
            await session.rollback()
            raise e
        finally:
            await session.close()


# /models/user.py
import uuid
from sqlalchemy import Column, String, Boolean, Enum
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from db.base_class import Base


class User(Base):
    """Database model for a User (Patient, Provider, Admin)."""
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    full_name = Column(String(255), nullable=False)
    email = Column(String(255), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    role = Column(Enum("patient", "provider", "admin", name="user_role_enum"), nullable=False)
    is_active = Column(Boolean(), default=True)

    sent_messages = relationship("SecureMessage", foreign_keys="[SecureMessage.sender_id]", back_populates="sender")
    received_messages = relationship("SecureMessage", foreign_keys="[SecureMessage.recipient_id]", back_populates="recipient")

# /models/audit_log.py
import uuid
from sqlalchemy import Column, String, DateTime, Enum, JSON
from sqlalchemy.dialects.postgresql import UUID, INET
from sqlalchemy.sql import func
from db.base_class import Base


class AuditLog(Base):
    """Database model for HIPAA audit trails."""
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    timestamp = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    performing_user_id = Column(UUID(as_uuid=True), index=True, nullable=False)
    affected_patient_id = Column(UUID(as_uuid=True), index=True, nullable=True)
    client_ip_address = Column(INET, nullable=True)
    action_type = Column(
        Enum(
            "LOGIN_SUCCESS", "LOGIN_FAIL",
            "CREATE_MESSAGE", "VIEW_MESSAGE", "VIEW_MESSAGE_LIST",
            "ACCESS_PATIENT_RECORD", "MODIFY_PATIENT_RECORD",
            "EMERGENCY_ACCESS",
            name="audit_action_enum"
        ),
        nullable=False
    )
    details = Column(JSON, nullable=True) # For additional context, e.g., resource ID


# /models/message.py
import uuid
from sqlalchemy import Column, DateTime, ForeignKey, Text
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from sqlalchemy_utils import EncryptedType
from core.config import settings
from db.base_class import Base


class SecureMessage(Base):
    """Database model for secure messages between users."""
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    thread_id = Column(UUID(as_uuid=True), index=True, nullable=False, default=uuid.uuid4)

    sender_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    recipient_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)

    # Encrypted PHI content using pgcrypto extension
    subject = Column(EncryptedType(Text, settings.PGCRYPTO_KEY), nullable=False)
    body = Column(EncryptedType(Text, settings.PGCRYPTO_KEY), nullable=False)

    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    read_at = Column(DateTime(timezone=True), nullable=True)

    sender = relationship("User", foreign_keys=[sender_id], back_populates="sent_messages")
    recipient = relationship("User", foreign_keys=[recipient_id], back_populates="received_messages")


# /schemas/user.py
import uuid
from pydantic import BaseModel, EmailStr


class UserBase(BaseModel):
    email: EmailStr
    full_name: str
    role: str


class UserInDBBase(UserBase):
    id: uuid.UUID
    is_active: bool

    class Config:
        from_attributes = True


class User(UserInDBBase):
    pass


# /schemas/token.py
from pydantic import BaseModel


class Token(BaseModel):
    access_token: str
    token_type: str


class TokenData(BaseModel):
    user_id: str | None = None


# /schemas/message.py
import uuid
from pydantic import BaseModel
from datetime import datetime
from .user import User


class MessageBase(BaseModel):
    recipient_id: uuid.UUID
    subject: str
    body: str


class MessageCreate(MessageBase):
    pass


class MessageInDBBase(BaseModel):
    id: uuid.UUID
    thread_id: uuid.UUID
    sender_id: uuid.UUID
    recipient_id: uuid.UUID
    subject: str
    body: str
    created_at: datetime
    read_at: datetime | None = None

    class Config:
        from_attributes = True


class Message(MessageInDBBase):
    """Schema for returning a message to the client."""
    sender: User
    recipient: User


# /services/audit_service.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import insert
from models.audit_log import AuditLog
from models.user import User
from typing import Any, Dict
import uuid


class AuditService:
    """Service for handling HIPAA audit logging."""

    async def log_action(
        self,
        db: AsyncSession,
        performing_user: User,
        action_type: str,
        client_ip: str | None,
        affected_patient_id: uuid.UUID | None = None,
        details: Dict[str, Any] | None = None,
    ) -> None:
        """
        Creates an audit log entry.

        Args:
            db: The database session.
            performing_user: The user performing the action.
            action_type: The type of action from the audit_action_enum.
            client_ip: The IP address of the client.
            affected_patient_id: The ID of the patient whose data is being accessed/modified.
            details: A JSON-serializable dict for extra context.
        """
        audit_log_stmt = insert(AuditLog).values(
            performing_user_id=performing_user.id,
            affected_patient_id=affected_patient_id,
            client_ip_address=client_ip,
            action_type=action_type,
            details=details or {},
        )
        await db.execute(audit_log_stmt)
        await db.commit()

audit_service = AuditService()

# /core/security.py
from datetime import datetime, timedelta
from typing import Any
import uuid

from fastapi import Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select

from core.config import settings
from db.session import get_db
from models.user import User
from schemas.token import TokenData
from services.audit_service import audit_service


pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{settings.API_V1_STR}/login/token")

ALGORITHM = settings.ALGORITHM
SECRET_KEY = settings.SECRET_KEY


def create_access_token(data: dict, expires_delta: timedelta | None = None) -> str:
    """Creates a JWT access token."""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt


def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifies a plain password against a hashed one."""
    return pwd_context.verify(plain_password, hashed_password)


def get_password_hash(password: str) -> str:
    """Hashes a plain password."""
    return pwd_context.hash(password)


async def get_current_user(
    db: AsyncSession = Depends(get_db), token: str = Depends(oauth2_scheme)
) -> User:
    """
    Decodes JWT token to get the current user.
    Raises credentials exception if token is invalid or user not found.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        user_id: str | None = payload.get("sub")
        if user_id is None:
            raise credentials_exception
        token_data = TokenData(user_id=user_id)
    except JWTError:
        raise credentials_exception

    user_uuid = uuid.UUID(token_data.user_id)
    result = await db.execute(select(User).where(User.id == user_uuid))
    user = result.scalars().first()
    if user is None:
        raise credentials_exception
    return user


async def get_current_active_user(
    current_user: User = Depends(get_current_user),
    request: Request = None,
    db: AsyncSession = Depends(get_db)
) -> User:
    """
    Ensures the current user is active.
    This is the primary dependency for protected endpoints.
    """
    if not current_user.is_active:
        await audit_service.log_action(
            db=db,
            performing_user=current_user,
            action_type="LOGIN_FAIL",
            client_ip=request.client.host if request else None,
            details={"reason": "Inactive user attempted access."},
        )
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


# /crud/crud_message.py
import uuid
from datetime import datetime
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from sqlalchemy import and_, or_, update
from models.message import SecureMessage
from models.user import User
from schemas.message import MessageCreate


async def create_message(db: AsyncSession, *, obj_in: MessageCreate, sender: User) -> SecureMessage:
    """Creates a new secure message in the database."""
    db_obj = SecureMessage(
        sender_id=sender.id,
        recipient_id=obj_in.recipient_id,
        subject=obj_in.subject,
        body=obj_in.body,
    )
    db.add(db_obj)
    await db.commit()
    await db.refresh(db_obj)
    return db_obj


async def get_message_by_id(db: AsyncSession, *, message_id: uuid.UUID, user: User) -> SecureMessage | None:
    """
    Retrieves a message by ID, ensuring the requesting user is authorized.
    Marks the message as read if the user is the recipient.
    """
    stmt = (
        select(SecureMessage)
        .where(SecureMessage.id == message_id)
        .where(or_(SecureMessage.sender_id == user.id, SecureMessage.recipient_id == user.id))
        .options(selectinload(SecureMessage.sender), selectinload(SecureMessage.recipient))
    )
    result = await db.execute(stmt)
    message = result.scalars().first()

    if message and message.recipient_id == user.id and message.read_at is None:
        message.read_at = datetime.utcnow()
        await db.commit()
        await db.refresh(message)

    return message


async def get_user_inbox(db: AsyncSession, *, user: User, skip: int = 0, limit: int = 100) -> list[SecureMessage]:
    """Retrieves all messages where the user is the recipient (inbox)."""
    stmt = (
        select(SecureMessage)
        .where(SecureMessage.recipient_id == user.id)
        .order_by(SecureMessage.created_at.desc())
        .offset(skip)
        .limit(limit)
        .options(selectinload(SecureMessage.sender), selectinload(SecureMessage.recipient))
    )
    result = await db.execute(stmt)
    return result.scalars().all()


async def get_user_sent_messages(db: AsyncSession, *, user: User, skip: int = 0, limit: int = 100) -> list[SecureMessage]:
    """Retrieves all messages where the user is the sender."""
    stmt = (
        select(SecureMessage)
        .where(SecureMessage.sender_id == user.id)
        .order_by(SecureMessage.created_at.desc())
        .offset(skip)
        .limit(limit)
        .options(selectinload(SecureMessage.sender), selectinload(SecureMessage.recipient))
    )
    result = await db.execute(stmt)
    return result.scalars().all()


# /api/v1/endpoints/messaging.py
from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.ext.asyncio import AsyncSession
import uuid
from typing import List

from core.security import get_current_active_user
from crud import crud_message
from db.session import get_db
from models.user import User
from schemas.message import MessageCreate, Message
from services.audit_service import audit_service

router = APIRouter()

@router.post("/", response_model=Message, status_code=status.HTTP_201_CREATED)
async def send_message(
    *,
    request: Request,
    db: AsyncSession = Depends(get_db),
    message_in: MessageCreate,
    current_user: User = Depends(get_current_active_user),
):
    """
    Send a new secure message.
    The sender is the currently authenticated user.
    """
    message = await crud_message.create_message(db=db, obj_in=message_in, sender=current_user)
    
    # Audit PHI creation
    # Determine which user is the patient for audit logging purposes.
    affected_patient_id = None
    if current_user.role == 'patient':
        affected_patient_id = current_user.id
    elif message_in.recipient_id: # Assuming recipient is a patient, more complex logic for provider-provider msg needed
         # In a real system, you'd look up the recipient to check their role.
         affected_patient_id = message_in.recipient_id

    await audit_service.log_action(
        db=db,
        performing_user=current_user,
        action_type="CREATE_MESSAGE",
        client_ip=request.client.host,
        affected_patient_id=affected_patient_id,
        details={"message_id": str(message.id), "recipient_id": str(message_in.recipient_id)}
    )
    
    # Reload to populate relationships for the response model
    return await crud_message.get_message_by_id(db=db, message_id=message.id, user=current_user)

@router.get("/inbox", response_model=List[Message])
async def read_inbox(
    *,
    request: Request,
    db: AsyncSession = Depends(get_db),
    skip: int = 0,
    limit: int = 100,
    current_user: User = Depends(get_current_active_user),
):
    """
    Retrieve messages from the current user's inbox.
    """
    messages = await crud_message.get_user_inbox(db=db, user=current_user, skip=skip, limit=limit)
    
    # Audit PHI access
    affected_patient_id = current_user.id if current_user.role == 'patient' else None
    await audit_service.log_action(
        db=db,
        performing_user=current_user,
        action_type="VIEW_MESSAGE_LIST",
        client_ip=request.client.host,
        affected_patient_id=affected_patient_id,
        details={"type": "inbox", "count": len(messages)}
    )
    
    return messages

@router.get("/{message_id}", response_model=Message)
async def read_message(
    *,
    request: Request,
    message_id: uuid.UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_active_user),
):
    """
    Retrieve a single message by its ID.
    The user must be either the sender or the recipient.
    This action marks the message as read if the current user is the recipient.
    """
    message = await crud_message.get_message_by_id(db=db, message_id=message_id, user=current_user)
    if not message:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Message not found or access denied")
    
    # Audit PHI access
    # Determine patient context for the audit log
    affected_patient_id = None
    if message.sender.role == 'patient':
        affected_patient_id = message.sender.id
    elif message.recipient.role == 'patient':
        affected_patient_id = message.recipient.id

    await audit_service.log_action(
        db=db,
        performing_user=current_user,
        action_type="VIEW_MESSAGE",
        client_ip=request.client.host,
        affected_patient_id=affected_patient_id,
        details={"message_id": str(message.id)}
    )

    return message


# /api/v1/api.py
from fastapi import APIRouter
from api.v1.endpoints import messaging

api_router = APIRouter()
api_router.include_router(messaging.router, prefix="/messages", tags=["messaging"])


# /main.py
from fastapi import FastAPI, Depends, Request
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import text
from starlette.middleware.cors import CORSMiddleware
from core.config import settings
from api.v1.api import api_router
from db.session import get_db, engine

app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_STR}/openapi.json",
)

# Set all CORS enabled origins
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, restrict this to trusted domains
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.on_event("startup")
async def on_startup():
    """
    Application startup event handler.
    Checks for required database extensions like pgcrypto.
    """
    async with engine.begin() as conn:
        try:
            # Check for pgcrypto extension, essential for encrypted fields
            await conn.execute(text("CREATE EXTENSION IF NOT EXISTS pgcrypto;"))
        except Exception as e:
            # In a real system, use a structured logger
            print(f"Error enabling pgcrypto extension: {e}")
            # Depending on policy, you might want to exit if pgcrypto is not available
            # raise SystemExit("pgcrypto extension is required but could not be enabled.")

app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/health", status_code=status.HTTP_200_OK)
async def health_check(db: AsyncSession = Depends(get_db)):
    """
    Performs a health check of the API and its database connection.
    """
    try:
        await db.execute(text("SELECT 1"))
        return {"status": "ok", "database_connection": "ok"}
    except Exception:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail={"status": "error", "database_connection": "failed"}
        )
```