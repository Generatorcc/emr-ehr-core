```python
# /core/config.py

import os
from pydantic_settings import BaseSettings
from typing import List

class Settings(BaseSettings):
    """
    Manages application configuration using environment variables.
    """
    API_V1_STR: str = "/api/v1"
    
    # JWT Settings
    SECRET_KEY: str = os.environ.get("SECRET_KEY", "fallback_secret_for_dev_only_6a2b8e3d4c5f")
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60

    # Database Settings
    POSTGRES_SERVER: str = os.environ.get("POSTGRES_SERVER", "localhost")
    POSTGRES_USER: str = os.environ.get("POSTGRES_USER", "postgres")
    POSTGRES_PASSWORD: str = os.environ.get("POSTGRES_PASSWORD", "password")
    POSTGRES_DB: str = os.environ.get("POSTGRES_DB", "emr_db")
    DATABASE_URI: str = f"postgresql+asyncpg://{POSTGRES_USER}:{POSTGRES_PASSWORD}@{POSTGRES_SERVER}/{POSTGRES_DB}"

    # S3 Storage Settings (assumes IAM role for production)
    S3_BUCKET_NAME: str = os.environ.get("S3_BUCKET_NAME", "emr-clinical-documents-dev")
    S3_REGION: str = os.environ.get("S3_REGION", "us-east-1")
    S3_ACCESS_KEY_ID: str | None = os.environ.get("S3_ACCESS_KEY_ID")
    S3_SECRET_ACCESS_KEY: str | None = os.environ.get("S3_SECRET_ACCESS_KEY")
    S3_PRESIGNED_URL_EXPIRATION: int = 3600  # seconds

    # User Roles
    USER_ROLES: List[str] = ["clinician", "nurse", "admin", "patient"]

    class Config:
        case_sensitive = True

settings = Settings()

```

```python
# /db/session.py

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from core.config import settings

engine = create_async_engine(settings.DATABASE_URI, pool_pre_ping=True, echo=False)
AsyncSessionLocal = sessionmaker(
    autocommit=False, 
    autoflush=False, 
    bind=engine, 
    class_=AsyncSession,
    expire_on_commit=False
)

async def get_db() -> AsyncSession:
    """
    FastAPI dependency to provide a database session.
    """
    async with AsyncSessionLocal() as session:
        yield session

```

```python
# /db/base_class.py

from typing import Any
from sqlalchemy.ext.declarative import as_declarative, declared_attr

@as_declarative()
class Base:
    """
    Base class for SQLAlchemy models.
    """
    id: Any
    __name__: str
    
    @declared_attr
    def __tablename__(cls) -> str:
        return cls.__name__.lower() + "s"

```

```python
# /models/user.py

import uuid
from sqlalchemy import Column, String, DateTime, func, Enum
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from db.base_class import Base
from core.config import settings

class User(Base):
    """
    User model representing a clinician, staff member, or admin.
    """
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    full_name = Column(String(255), nullable=False)
    username = Column(String(100), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    role = Column(Enum(*settings.USER_ROLES, name="user_roles_enum"), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    uploaded_documents = relationship("ClinicalDocument", back_populates="uploader")
    audit_logs = relationship("AuditLog", back_populates="user")

```

```python
# /models/patient.py

import uuid
from sqlalchemy import Column, String, Date, DateTime, func
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from db.base_class import Base

class Patient(Base):
    """
    Patient model.
    """
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    first_name = Column(String(255), nullable=False)
    last_name = Column(String(255), nullable=False)
    date_of_birth = Column(Date, nullable=False)
    mrn = Column(String(50), unique=True, index=True, nullable=False) # Medical Record Number
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    documents = relationship("ClinicalDocument", back_populates="patient")

```

```python
# /models/document.py

import uuid
from sqlalchemy import Column, String, DateTime, func, ForeignKey
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from db.base_class import Base

class ClinicalDocument(Base):
    """
    Metadata for a clinical document stored in S3.
    """
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    patient_id = Column(UUID(as_uuid=True), ForeignKey("patients.id"), nullable=False, index=True)
    uploader_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    
    file_name = Column(String(255), nullable=False)
    s3_key = Column(String(1024), unique=True, nullable=False)
    mime_type = Column(String(100), nullable=False)
    file_hash = Column(String(256), nullable=False) # SHA-256 hash of the file
    description = Column(String(500), nullable=True)

    upload_timestamp = Column(DateTime(timezone=True), server_default=func.now())

    patient = relationship("Patient", back_populates="documents")
    uploader = relationship("User", back_populates="uploaded_documents")

```

```python
# /models/audit_log.py

import uuid
from sqlalchemy import Column, String, DateTime, func, ForeignKey, JSON
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from db.base_class import Base

class AuditLog(Base):
    """
    Audit trail for HIPAA compliance, logging significant events.
    """
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    action = Column(String(255), nullable=False) # e.g., 'VIEW_DOCUMENT', 'UPLOAD_DOCUMENT'
    details = Column(JSON, nullable=True) # e.g., {'patient_id': '...', 'document_id': '...'}
    timestamp = Column(DateTime(timezone=True), server_default=func.now(), index=True)

    user = relationship("User", back_populates="audit_logs")

```

```python
# /schemas/token.py

from pydantic import BaseModel
from typing import Optional
import uuid

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None
    user_id: Optional[uuid.UUID] = None
    role: Optional[str] = None

```

```python
# /schemas/user.py

from pydantic import BaseModel
import uuid
from typing import List
from core.config import settings

class UserBase(BaseModel):
    username: str
    full_name: str
    role: str

class UserCreate(UserBase):
    password: str

class UserInDB(UserBase):
    id: uuid.UUID
    
    class Config:
        from_attributes = True

```

```python
# /schemas/audit_log.py

from pydantic import BaseModel
import uuid
from datetime import datetime
from typing import Dict, Any

class AuditLogCreate(BaseModel):
    user_id: uuid.UUID
    action: str
    details: Dict[str, Any]

class AuditLogResponse(AuditLogCreate):
    id: uuid.UUID
    timestamp: datetime

    class Config:
        from_attributes = True

```

```python
# /schemas/document.py

from pydantic import BaseModel, Field
import uuid
from datetime import datetime

class DocumentUploadRequest(BaseModel):
    patient_id: uuid.UUID
    file_name: str
    mime_type: str
    description: str | None = None

class DocumentUploadURLResponse(BaseModel):
    upload_url: str
    s3_key: str

class DocumentCreate(BaseModel):
    patient_id: uuid.UUID
    s3_key: str
    file_name: str
    mime_type: str
    file_hash: str = Field(..., pattern=r"^[a-fA-F0-9]{64}$") # SHA-256
    description: str | None = None

class DocumentResponse(BaseModel):
    id: uuid.UUID
    patient_id: uuid.UUID
    uploader_id: uuid.UUID
    file_name: str
    description: str | None = None
    mime_type: str
    upload_timestamp: datetime

    class Config:
        from_attributes = True

class DocumentDownloadURLResponse(BaseModel):
    download_url: str

```

```python
# /security/s3_client.py

import boto3
from botocore.client import Config
from botocore.exceptions import ClientError
from core.config import settings
import logging

logger = logging.getLogger(__name__)

class S3Client:
    """
    Client for secure interaction with AWS S3.
    """
    def __init__(self):
        self.s3_client = boto3.client(
            "s3",
            region_name=settings.S3_REGION,
            aws_access_key_id=settings.S3_ACCESS_KEY_ID,
            aws_secret_access_key=settings.S3_SECRET_ACCESS_KEY,
            config=Config(signature_version="s3v4")
        )
        self.bucket_name = settings.S3_BUCKET_NAME
        self.url_expiration = settings.S3_PRESIGNED_URL_EXPIRATION

    def generate_presigned_upload_url(self, s3_key: str, mime_type: str) -> str | None:
        """
        Generates a presigned URL for uploading a file directly to S3.
        The S3 bucket must have a CORS policy configured.
        """
        try:
            # SSE-S3 requires this header to be set by the client
            # Or use SSE-KMS by changing ServerSideEncryption and adding KMS key id.
            params = {
                "Bucket": self.bucket_name,
                "Key": s3_key,
                "ContentType": mime_type,
                "ServerSideEncryption": "AES256"
            }
            url = self.s3_client.generate_presigned_url(
                ClientMethod="put_object",
                Params=params,
                ExpiresIn=self.url_expiration,
            )
            return url
        except ClientError as e:
            logger.error(f"Failed to generate presigned upload URL: {e}")
            return None

    def generate_presigned_download_url(self, s3_key: str) -> str | None:
        """
        Generates a presigned URL for downloading a file from S3.
        """
        try:
            url = self.s3_client.generate_presigned_url(
                ClientMethod="get_object",
                Params={"Bucket": self.bucket_name, "Key": s3_key},
                ExpiresIn=self.url_expiration,
            )
            return url
        except ClientError as e:
            logger.error(f"Failed to generate presigned download URL: {e}")
            return None

s3_client = S3Client()

```

```python
# /security/password.py

from passlib.context import CryptContext

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

class PasswordManager:
    @staticmethod
    def verify_password(plain_password: str, hashed_password: str) -> bool:
        return pwd_context.verify(plain_password, hashed_password)

    @staticmethod
    def get_password_hash(password: str) -> str:
        return pwd_context.hash(password)

password_manager = PasswordManager()
```

```python
# /security/token.py

from datetime import datetime, timedelta
from typing import Any, Union
from jose import jwt
from core.config import settings

class TokenManager:
    @staticmethod
    def create_access_token(
        subject: Union[str, Any], expires_delta: timedelta = None
    ) -> str:
        if expires_delta:
            expire = datetime.utcnow() + expires_delta
        else:
            expire = datetime.utcnow() + timedelta(
                minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES
            )
        to_encode = {"exp": expire, "sub": str(subject)}
        encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
        return encoded_jwt

token_manager = TokenManager()
```

```python
# /crud/base.py

from typing import Any, Dict, Generic, List, Optional, Type, TypeVar, Union
from pydantic import BaseModel
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from db.base_class import Base

ModelType = TypeVar("ModelType", bound=Base)
CreateSchemaType = TypeVar("CreateSchemaType", bound=BaseModel)
UpdateSchemaType = TypeVar("UpdateSchemaType", bound=BaseModel)

class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):
    def __init__(self, model: Type[ModelType]):
        self.model = model

    async def get(self, db: AsyncSession, id: Any) -> Optional[ModelType]:
        result = await db.execute(select(self.model).filter(self.model.id == id))
        return result.scalars().first()

    async def get_multi(
        self, db: AsyncSession, *, skip: int = 0, limit: int = 100
    ) -> List[ModelType]:
        result = await db.execute(select(self.model).offset(skip).limit(limit))
        return result.scalars().all()

    async def create(self, db: AsyncSession, *, obj_in: CreateSchemaType) -> ModelType:
        obj_in_data = obj_in.model_dump()
        db_obj = self.model(**obj_in_data)
        db.add(db_obj)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

```

```python
# /crud/crud_audit.py

from crud.base import CRUDBase
from models.audit_log import AuditLog
from schemas.audit_log import AuditLogCreate
from sqlalchemy.ext.asyncio import AsyncSession
import logging

logger = logging.getLogger(__name__)

class CRUDAuditLog(CRUDBase[AuditLog, AuditLogCreate, AuditLogCreate]):
    async def log_event(self, db: AsyncSession, *, obj_in: AuditLogCreate) -> AuditLog:
        """
        Logs an audit event without raising exceptions on failure, to avoid
        disrupting primary application logic.
        """
        try:
            return await self.create(db=db, obj_in=obj_in)
        except Exception as e:
            logger.critical(f"CRITICAL: Failed to write audit log: {e}. Event details: {obj_in.model_dump_json()}")
            # In a real system, this might trigger a high-priority alert.
            # We do not re-raise the exception to ensure the user's action completes.
            return None


crud_audit_log = CRUDAuditLog(AuditLog)
```

```python
# /crud/crud_user.py

from typing import Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from crud.base import CRUDBase
from models.user import User
from schemas.user import UserCreate
from security.password import password_manager

class CRUDUser(CRUDBase[User, UserCreate, UserCreate]):
    async def get_by_username(self, db: AsyncSession, *, username: str) -> Optional[User]:
        result = await db.execute(select(self.model).filter(self.model.username == username))
        return result.scalars().first()

    async def create(self, db: AsyncSession, *, obj_in: UserCreate) -> User:
        db_obj = self.model(
            username=obj_in.username,
            full_name=obj_in.full_name,
            hashed_password=password_manager.get_password_hash(obj_in.password),
            role=obj_in.role,
        )
        db.add(db_obj)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

crud_user = CRUDUser(User)
```

```python
# /crud/crud_document.py

from typing import List
import uuid
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from crud.base import CRUDBase
from models.document import ClinicalDocument
from schemas.document import DocumentCreate

class CRUDDocument(CRUDBase[ClinicalDocument, DocumentCreate, DocumentCreate]):
    async def create_with_uploader(
        self, db: AsyncSession, *, obj_in: DocumentCreate, uploader_id: uuid.UUID
    ) -> ClinicalDocument:
        db_obj = self.model(**obj_in.model_dump(), uploader_id=uploader_id)
        db.add(db_obj)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

    async def get_multi_by_patient(
        self, db: AsyncSession, *, patient_id: uuid.UUID, skip: int = 0, limit: int = 100
    ) -> List[ClinicalDocument]:
        result = await db.execute(
            select(self.model)
            .filter(ClinicalDocument.patient_id == patient_id)
            .offset(skip)
            .limit(limit)
        )
        return result.scalars().all()

crud_document = CRUDDocument(ClinicalDocument)
```

```python
# /crud/crud_patient.py

from crud.base import CRUDBase
from models.patient import Patient
from pydantic import BaseModel

# Placeholder schema for patient creation/update if needed
class PatientCreate(BaseModel):
    pass

class PatientUpdate(BaseModel):
    pass

crud_patient = CRUDBase[Patient, PatientCreate, PatientUpdate](Patient)

```

```python
# /security/dependencies.py

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import jwt, JWTError
from pydantic import ValidationError
from sqlalchemy.ext.asyncio import AsyncSession

from core.config import settings
from crud import crud_user
from db.session import get_db
from models.user import User
from schemas.token import TokenData

reusable_oauth2 = OAuth2PasswordBearer(
    tokenUrl=f"{settings.API_V1_STR}/login/access-token"
)

async def get_current_user(
    db: AsyncSession = Depends(get_db), token: str = Depends(reusable_oauth2)
) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(
            token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM]
        )
        token_data = TokenData(**payload)
        if token_data.username is None:
            raise credentials_exception
    except (JWTError, ValidationError):
        raise credentials_exception
    
    user = await crud_user.get_by_username(db, username=token_data.username)
    if not user:
        raise credentials_exception
    return user

def get_current_active_clinician(
    current_user: User = Depends(get_current_user),
) -> User:
    # Example authorization check: only clinicians and admins can perform certain actions
    if current_user.role not in ["clinician", "admin"]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="The user does not have sufficient privileges.",
        )
    return current_user

```

```python
# /api/v1/endpoints/login.py

from datetime import timedelta
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession

from core.config import settings
from crud import crud_user
from db.session import get_db
from schemas.token import Token
from security.password import password_manager
from security.token import token_manager

router = APIRouter()

@router.post("/access-token", response_model=Token)
async def login_access_token(
    db: AsyncSession = Depends(get_db), form_data: OAuth2PasswordRequestForm = Depends()
):
    """
    OAuth2 compatible token login, get an access token for future requests.
    """
    user = await crud_user.get_by_username(db, username=form_data.username)
    if not user or not password_manager.verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    
    # Add user metadata to token subject
    token_subject = {
        "user_id": str(user.id),
        "username": user.username,
        "role": user.role
    }

    access_token = token_manager.create_access_token(
        subject=token_subject, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

```

```python
# /api/v1/endpoints/documents.py

import uuid
from fastapi import APIRouter, Depends, HTTPException, status, Body
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List

from crud import crud_document, crud_patient, crud_audit_log
from db.session import get_db
from models.user import User
from schemas.audit_log import AuditLogCreate
from schemas.document import (
    DocumentUploadRequest, DocumentUploadURLResponse, DocumentCreate,
    DocumentResponse, DocumentDownloadURLResponse
)
from security.dependencies import get_current_user, get_current_active_clinician
from security.s3_client import s3_client

router = APIRouter()

@router.post(
    "/upload-url",
    response_model=DocumentUploadURLResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Request secure upload URL for a clinical document"
)
async def request_upload_url(
    upload_request: DocumentUploadRequest,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_active_clinician)
):
    """
    First step of document upload.
    Generates a pre-signed S3 URL for the client to upload the file directly.
    This prevents large file transfers through the API server.
    """
    patient = await crud_patient.get(db, id=upload_request.patient_id)
    if not patient:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Patient not found")

    s3_key = f"patients/{patient.id}/documents/{uuid.uuid4()}_{upload_request.file_name}"
    upload_url = s3_client.generate_presigned_upload_url(s3_key, upload_request.mime_type)

    if not upload_url:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Could not generate upload URL. Please try again later."
        )

    # Pre-emptive audit log for upload attempt
    await crud_audit_log.log_event(db, obj_in=AuditLogCreate(
        user_id=current_user.id,
        action="REQUEST_DOCUMENT_UPLOAD_URL",
        details={"patient_id": str(patient.id), "s3_key": s3_key}
    ))

    return {"upload_url": upload_url, "s3_key": s3_key}


@router.post(
    "/",
    response_model=DocumentResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Confirm document upload and create metadata record"
)
async def create_document_metadata(
    *,
    db: AsyncSession = Depends(get_db),
    doc_in: DocumentCreate,
    current_user: User = Depends(get_current_active_clinician)
):
    """
    Second step of document upload.
    After the client successfully uploads the file to S3, it calls this endpoint
    to create the document's metadata record in the database.
    """
    patient = await crud_patient.get(db, id=doc_in.patient_id)
    if not patient:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Patient not found")

    document = await crud_document.create_with_uploader(db=db, obj_in=doc_in, uploader_id=current_user.id)
    
    await crud_audit_log.log_event(db, obj_in=AuditLogCreate(
        user_id=current_user.id,
        action="CREATE_DOCUMENT_METADATA",
        details={"patient_id": str(patient.id), "document_id": str(document.id)}
    ))

    return document


@router.get(
    "/patient/{patient_id}",
    response_model=List[DocumentResponse],
    summary="List all clinical documents for a patient"
)
async def get_patient_documents(
    patient_id: uuid.UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user),
    skip: int = 0,
    limit: int = 100
):
    """
    Retrieves a list of all document metadata for a specific patient.
    Access is logged for HIPAA auditing.
    """
    patient = await crud_patient.get(db, id=patient_id)
    if not patient:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Patient not found")
    
    # Authorization logic: is this user allowed to see this patient's data?
    # This is a placeholder for a more complex access control system (e.g., care team).
    if current_user.role not in ["admin", "clinician", "nurse"]:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Insufficient permissions")

    await crud_audit_log.log_event(db, obj_in=AuditLogCreate(
        user_id=current_user.id,
        action="LIST_PATIENT_DOCUMENTS",
        details={"patient_id": str(patient.id)}
    ))

    documents = await crud_document.get_multi_by_patient(
        db, patient_id=patient_id, skip=skip, limit=limit
    )
    return documents


@router.get(
    "/{document_id}/download-url",
    response_model=DocumentDownloadURLResponse,
    summary="Get secure download URL for a clinical document"
)
async def get_document_download_url(
    document_id: uuid.UUID,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_user)
):
    """
    Retrieves a pre-signed S3 URL to download a document.
    Access is strictly controlled and audited.
    """
    document = await crud_document.get(db, id=document_id)
    if not document:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Document not found")
    
    # Authorization logic (similar to listing)
    if current_user.role not in ["admin", "clinician", "nurse"]:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Insufficient permissions")

    download_url = s3_client.generate_presigned_download_url(s3_key=document.s3_key)
    if not download_url:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail="Could not generate download URL. Please try again later."
        )

    await crud_audit_log.log_event(db, obj_in=AuditLogCreate(
        user_id=current_user.id,
        action="ACCESS_DOCUMENT",
        details={"patient_id": str(document.patient_id), "document_id": str(document.id)}
    ))

    return {"download_url": download_url}

```

```python
# /api/v1/api.py

from fastapi import APIRouter
from api.v1.endpoints import login, documents

api_router = APIRouter()
api_router.include_router(login.router, prefix="/login", tags=["login"])
api_router.include_router(documents.router, prefix="/documents", tags=["documents"])

```

```python
# /main.py

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from core.config import settings
from api.v1.api import api_router

app = FastAPI(
    title="EMR Clinical Document Service",
    description="HIPAA-compliant service for managing clinical documents.",
    version="1.0.0",
    openapi_url=f"{settings.API_V1_STR}/openapi.json"
)

# CORS Middleware for browser-based clients
# In production, restrict origins to the specific frontend application domain
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Restrict this in production
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/", include_in_schema=False)
def root():
    return {"status": "ok", "service": "EMR Clinical Document Service"}

```