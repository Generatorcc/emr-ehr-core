```python
# /core/config.py
import os
from pydantic_settings import BaseSettings
from typing import Literal

class Settings(BaseSettings):
    """
    Application-wide settings loaded from environment variables.
    """
    # Application settings
    PROJECT_NAME: str = "EMR_Backend_Service"
    API_V1_STR: str = "/api/v1"
    ENVIRONMENT: Literal["development", "production", "testing"] = "production"

    # Security settings
    # IMPORTANT: In production, generate a strong secret key, e.g., with:
    # `openssl rand -hex 32`
    SECRET_KEY: str = os.getenv("SECRET_KEY", "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7")
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60
    REFRESH_TOKEN_EXPIRE_DAYS: int = 7

    # Database settings
    # Example: postgresql+asyncpg://user:password@host:port/dbname
    DATABASE_URL: str = os.getenv("DATABASE_URL", "postgresql+asyncpg://emr_user:secure_password@localhost/emr_db")

    # CORS settings
    # In production, restrict this to the frontend domain.
    BACKEND_CORS_ORIGINS: list[str] = ["*"]

    class Config:
        case_sensitive = True
        env_file = ".env"

settings = Settings()

# /enums/roles.py
from enum import Enum

class UserRole(str, Enum):
    ADMIN = "admin"
    PHYSICIAN = "physician"
    NURSE = "nurse"
    PATIENT = "patient"
    SYSTEM = "system"

# /enums/audit.py
from enum import Enum

class AuditAction(str, Enum):
    LOGIN_SUCCESS = "LOGIN_SUCCESS"
    LOGIN_FAILURE = "LOGIN_FAILURE"
    LOGOUT = "LOGOUT"
    TOKEN_REFRESH = "TOKEN_REFRESH"
    PHI_ACCESS = "PHI_ACCESS"
    PHI_CREATE = "PHI_CREATE"
    PHI_UPDATE = "PHI_UPDATE"
    PHI_DELETE = "PHI_DELETE"
    USER_CREATE = "USER_CREATE"
    USER_UPDATE = "USER_UPDATE"
    USER_DELETE = "USER_DELETE"
    SYSTEM_CONFIG_CHANGE = "SYSTEM_CONFIG_CHANGE"
    REPORT_GENERATED = "REPORT_GENERATED"

class AuditStatus(str, Enum):
    SUCCESS = "SUCCESS"
    FAILURE = "FAILURE"

# /core/db.py
from sqlalchemy.ext.asyncio import create_async_engine, async_sessionmaker, AsyncSession
from typing import AsyncGenerator
from .config import settings

engine = create_async_engine(settings.DATABASE_URL, pool_pre_ping=True, echo=False)
AsyncSessionLocal = async_sessionmaker(
    autocommit=False, 
    autoflush=False, 
    bind=engine,
    expire_on_commit=False,
    class_=AsyncSession
)

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """
    Dependency to get an async database session.
    """
    async with AsyncSessionLocal() as session:
        yield session

# /schemas/base.py
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy import Column, Integer, DateTime
from sqlalchemy.sql import func
import uuid
from sqlalchemy.dialects.postgresql import UUID

class Base(DeclarativeBase):
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    created_at = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now(), nullable=False)

# /schemas/user.py
from sqlalchemy import Column, String, Boolean
from ..schemas.base import Base
from ..enums.roles import UserRole
from sqlalchemy.orm import relationship

class User(Base):
    __tablename__ = "users"

    username = Column(String, unique=True, index=True, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, index=True, nullable=False)
    role = Column(String, default=UserRole.NURSE, nullable=False)
    is_active = Column(Boolean(), default=True)
    is_superuser = Column(Boolean(), default=False)
    
    audit_logs = relationship("AuditLog", back_populates="user")

# /schemas/audit_log.py
from sqlalchemy import Column, String, ForeignKey, JSON
from sqlalchemy.dialects.postgresql import INET, UUID
from ..schemas.base import Base
from ..enums.audit import AuditAction, AuditStatus
from sqlalchemy.orm import relationship

class AuditLog(Base):
    __tablename__ = "audit_logs"

    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True) # Nullable for system events
    username = Column(String, index=True) # Denormalized for query performance
    ip_address = Column(INET, nullable=False)
    action = Column(String, nullable=False, index=True)
    status = Column(String, nullable=False)
    target_resource = Column(String, index=True, nullable=True)
    target_id = Column(String, index=True, nullable=True)
    details = Column(JSON, nullable=True)

    user = relationship("User", back_populates="audit_logs")


# /models/token.py
from pydantic import BaseModel
from typing import Optional
import uuid

class Token(BaseModel):
    access_token: str
    refresh_token: str
    token_type: str = "bearer"

class TokenPayload(BaseModel):
    sub: str  # User ID (subject)
    username: str
    role: str
    exp: int

# /models/user.py
from pydantic import BaseModel, EmailStr
from typing import Optional
import uuid
from ..enums.roles import UserRole

# Shared properties
class UserBase(BaseModel):
    email: EmailStr
    full_name: Optional[str] = None
    role: UserRole = UserRole.NURSE
    is_active: Optional[bool] = True
    is_superuser: bool = False

# Properties to receive via API on creation
class UserCreate(UserBase):
    username: str
    password: str

# Properties to receive via API on update
class UserUpdate(BaseModel):
    email: Optional[EmailStr] = None
    full_name: Optional[str] = None
    is_active: Optional[bool] = None

# Properties stored in DB
class UserInDB(UserBase):
    id: uuid.UUID
    username: str
    hashed_password: str

    class Config:
        from_attributes = True

# Public properties to return to client
class UserPublic(UserBase):
    id: uuid.UUID
    username: str

    class Config:
        from_attributes = True

# /models/audit.py
from pydantic import BaseModel
from typing import Optional, Dict, Any
import uuid
from datetime import datetime
from ..enums.audit import AuditAction, AuditStatus

class AuditLogBase(BaseModel):
    ip_address: str
    action: AuditAction
    status: AuditStatus
    target_resource: Optional[str] = None
    target_id: Optional[str] = None
    details: Optional[Dict[str, Any]] = None

class AuditLogCreate(AuditLogBase):
    user_id: Optional[uuid.UUID] = None
    username: Optional[str] = None

class AuditLogInDB(AuditLogBase):
    id: uuid.UUID
    user_id: Optional[uuid.UUID]
    username: Optional[str]
    created_at: datetime

    class Config:
        from_attributes = True

# /crud/base.py
from typing import Any, Dict, Generic, List, Optional, Type, TypeVar, Union
from pydantic import BaseModel
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from ..schemas.base import Base

ModelType = TypeVar("ModelType", bound=Base)
CreateSchemaType = TypeVar("CreateSchemaType", bound=BaseModel)
UpdateSchemaType = TypeVar("UpdateSchemaType", bound=BaseModel)

class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):
    def __init__(self, model: Type[ModelType]):
        self.model = model

    async def get(self, db: AsyncSession, id: Any) -> Optional[ModelType]:
        result = await db.execute(select(self.model).filter(self.model.id == id))
        return result.scalars().first()

    async def get_multi(self, db: AsyncSession, *, skip: int = 0, limit: int = 100) -> List[ModelType]:
        result = await db.execute(select(self.model).offset(skip).limit(limit))
        return result.scalars().all()

    async def create(self, db: AsyncSession, *, obj_in: CreateSchemaType) -> ModelType:
        obj_in_data = obj_in.model_dump()
        db_obj = self.model(**obj_in_data)
        db.add(db_obj)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

    async def update(
        self, db: AsyncSession, *, db_obj: ModelType, obj_in: Union[UpdateSchemaType, Dict[str, Any]]
    ) -> ModelType:
        obj_data = db_obj.model_dump()
        if isinstance(obj_in, dict):
            update_data = obj_in
        else:
            update_data = obj_in.model_dump(exclude_unset=True)
        for field in obj_data:
            if field in update_data:
                setattr(db_obj, field, update_data[field])
        db.add(db_obj)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

    async def remove(self, db: AsyncSession, *, id: Any) -> ModelType:
        result = await db.execute(select(self.model).filter(self.model.id == id))
        obj = result.scalars().first()
        await db.delete(obj)
        await db.commit()
        return obj

# /crud/user.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from typing import Optional
from .base import CRUDBase
from ..models.user import UserCreate, UserUpdate
from ..schemas.user import User
from ..core.security import get_password_hash

class CRUDUser(CRUDBase[User, UserCreate, UserUpdate]):
    async def get_by_username(self, db: AsyncSession, *, username: str) -> Optional[User]:
        result = await db.execute(select(User).filter(User.username == username))
        return result.scalars().first()
    
    async def get_by_email(self, db: AsyncSession, *, email: str) -> Optional[User]:
        result = await db.execute(select(User).filter(User.email == email))
        return result.scalars().first()

    async def create(self, db: AsyncSession, *, obj_in: UserCreate) -> User:
        db_obj = User(
            username=obj_in.username,
            email=obj_in.email,
            hashed_password=get_password_hash(obj_in.password),
            full_name=obj_in.full_name,
            role=obj_in.role.value,
            is_superuser=obj_in.is_superuser,
        )
        db.add(db_obj)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

crud_user = CRUDUser(User)

# /crud/audit_log.py
from sqlalchemy.ext.asyncio import AsyncSession
from .base import CRUDBase
from ..models.audit import AuditLogCreate
from ..schemas.audit_log import AuditLog

class CRUDAuditLog(CRUDBase[AuditLog, AuditLogCreate, None]):
    async def create(self, db: AsyncSession, *, obj_in: AuditLogCreate) -> AuditLog:
        db_obj = AuditLog(
            user_id=obj_in.user_id,
            username=obj_in.username,
            ip_address=obj_in.ip_address,
            action=obj_in.action.value,
            status=obj_in.status.value,
            target_resource=obj_in.target_resource,
            target_id=obj_in.target_id,
            details=obj_in.details,
        )
        db.add(db_obj)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

crud_audit_log = CRUDAuditLog(AuditLog)


# /core/security.py
from datetime import datetime, timedelta, timezone
from typing import Optional, Any
from passlib.context import CryptContext
from jose import jwt, JWTError
from fastapi.security import OAuth2PasswordBearer
from fastapi import Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from pydantic import ValidationError

from .config import settings
from .db import get_db
from ..crud.user import crud_user
from ..models.token import TokenPayload
from ..schemas.user import User as UserSchema

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{settings.API_V1_STR}/auth/token")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def create_refresh_token(data: dict) -> str:
    expire = datetime.now(timezone.utc) + timedelta(days=settings.REFRESH_TOKEN_EXPIRE_DAYS)
    to_encode = data.copy()
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt


async def get_current_user(
    db: AsyncSession = Depends(get_db), token: str = Depends(oauth2_scheme)
) -> UserSchema:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(
            token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM]
        )
        token_data = TokenPayload(**payload)
    except (JWTError, ValidationError):
        raise credentials_exception

    user = await crud_user.get_by_username(db, username=token_data.username)
    if not user:
        raise credentials_exception
    return user


async def get_current_active_user(
    current_user: UserSchema = Depends(get_current_user),
) -> UserSchema:
    if not current_user.is_active:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Inactive user")
    return current_user


async def get_current_active_superuser(
    current_user: UserSchema = Depends(get_current_active_user),
) -> UserSchema:
    if not current_user.is_superuser:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN, detail="The user doesn't have enough privileges"
        )
    return current_user

# /utils/audit_logging.py
from functools import wraps
from fastapi import Request
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional, Callable, Awaitable, Any, Dict
import uuid

from ..crud.audit_log import crud_audit_log
from ..models.audit import AuditLogCreate
from ..enums.audit import AuditAction, AuditStatus
from ..schemas.user import User as UserSchema

class AuditLogger:
    def __init__(self, request: Request, db: AsyncSession):
        self.request = request
        self.db = db

    async def log(
        self,
        action: AuditAction,
        status: AuditStatus,
        user: Optional[UserSchema] = None,
        target_resource: Optional[str] = None,
        target_id: Optional[str] = None,
        username_for_failure: Optional[str] = None,
        details: Optional[Dict[str, Any]] = None,
    ):
        """
        Logs an audit event to the database.
        """
        user_id_to_log: Optional[uuid.UUID] = None
        username_to_log: Optional[str] = None

        if user:
            user_id_to_log = user.id
            username_to_log = user.username
        elif username_for_failure:
            username_to_log = username_for_failure

        log_entry = AuditLogCreate(
            user_id=user_id_to_log,
            username=username_to_log,
            ip_address=self.request.client.host,
            action=action,
            status=status,
            target_resource=target_resource,
            target_id=target_id,
            details=details,
        )
        await crud_audit_log.create(self.db, obj_in=log_entry)

def get_audit_logger(request: Request, db: AsyncSession = Depends(get_db)) -> AuditLogger:
    """
    Dependency to provide an AuditLogger instance to endpoints.
    """
    return AuditLogger(request=request, db=db)


# /api/v1/endpoints/auth.py
from fastapi import APIRouter, Depends, HTTPException, status, Response
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Any

from ....core import security
from ....core.db import get_db
from ....crud.user import crud_user
from ....models.token import Token
from ....utils.audit_logging import AuditLogger, get_audit_logger
from ....enums.audit import AuditAction, AuditStatus

router = APIRouter()

@router.post("/token", response_model=Token)
async def login_for_access_token(
    response: Response,
    db: AsyncSession = Depends(get_db),
    form_data: OAuth2PasswordRequestForm = Depends(),
    audit_logger: AuditLogger = Depends(get_audit_logger)
) -> Any:
    """
    OAuth2 compatible token login, get an access token for future requests.
    Logs login attempts.
    """
    user = await crud_user.get_by_username(db, username=form_data.username)
    if not user or not security.verify_password(form_data.password, user.hashed_password):
        await audit_logger.log(
            action=AuditAction.LOGIN_FAILURE,
            status=AuditStatus.FAILURE,
            username_for_failure=form_data.username,
            details={"reason": "Invalid username or password"},
        )
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    if not user.is_active:
        await audit_logger.log(
            action=AuditAction.LOGIN_FAILURE,
            status=AuditStatus.FAILURE,
            user=user,
            details={"reason": "User account is inactive"},
        )
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")

    await audit_logger.log(
        action=AuditAction.LOGIN_SUCCESS,
        status=AuditStatus.SUCCESS,
        user=user
    )
    
    token_data = {"sub": str(user.id), "username": user.username, "role": user.role}
    access_token = security.create_access_token(data=token_data)
    refresh_token = security.create_refresh_token(data=token_data)

    return {"access_token": access_token, "refresh_token": refresh_token, "token_type": "bearer"}


# /api/v1/endpoints/users.py
from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List

from ....core.db import get_db
from ....core.security import get_current_active_user, get_current_active_superuser
from ....crud.user import crud_user
from ....models.user import UserCreate, UserPublic, UserUpdate
from ....schemas.user import User as UserSchema
from ....utils.audit_logging import AuditLogger, get_audit_logger
from ....enums.audit import AuditAction, AuditStatus

router = APIRouter()

@router.get("/me", response_model=UserPublic)
async def read_users_me(
    current_user: UserSchema = Depends(get_current_active_user),
    audit_logger: AuditLogger = Depends(get_audit_logger)
):
    """
    Get current user's profile. This is an example of a secure endpoint
    that accesses potentially sensitive user information.
    """
    await audit_logger.log(
        action=AuditAction.PHI_ACCESS,
        status=AuditStatus.SUCCESS,
        user=current_user,
        target_resource="user_profile",
        target_id=str(current_user.id),
        details={"accessed_field": "own_profile"}
    )
    return current_user


@router.post("/", response_model=UserPublic, status_code=status.HTTP_21_CREATED, dependencies=[Depends(get_current_active_superuser)])
async def create_user(
    *,
    db: AsyncSession = Depends(get_db),
    user_in: UserCreate,
    current_user: UserSchema = Depends(get_current_active_superuser),
    audit_logger: AuditLogger = Depends(get_audit_logger)
):
    """
    Create a new user in the system. Requires admin privileges.
    """
    user = await crud_user.get_by_username(db, username=user_in.username)
    if user:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="The user with this username already exists in the system.",
        )
    
    new_user = await crud_user.create(db=db, obj_in=user_in)
    
    await audit_logger.log(
        action=AuditAction.USER_CREATE,
        status=AuditStatus.SUCCESS,
        user=current_user,
        target_resource="user",
        target_id=str(new_user.id),
        details={"new_user_username": new_user.username, "new_user_role": new_user.role}
    )
    return new_user

# /api/v1/router.py
from fastapi import APIRouter
from .endpoints import auth, users

api_router = APIRouter()
api_router.include_router(auth.router, prefix="/auth", tags=["Authentication"])
api_router.include_router(users.router, prefix="/users", tags=["Users"])


# /main.py
from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from contextlib import asynccontextmanager

from .core.config import settings
from .core.db import engine
from .schemas.base import Base
from .api.v1.router import api_router

@asynccontextmanager
async def lifespan(app: FastAPI):
    # On startup: Create database tables
    async with engine.begin() as conn:
        # Use this for initial setup, but for production migrations, use Alembic.
        # await conn.run_sync(Base.metadata.drop_all) # Use only in dev
        await conn.run_sync(Base.metadata.create_all)
    yield
    # On shutdown:
    await engine.dispose()

app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_STR}/openapi.json",
    lifespan=lifespan
)

# Set all CORS enabled origins
if settings.BACKEND_CORS_ORIGINS:
    app.add_middleware(
        CORSMiddleware,
        allow_origins=[str(origin) for origin in settings.BACKEND_CORS_ORIGINS],
        allow_credentials=True,
        allow_methods=["*"],
        allow_headers=["*"],
    )

app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/", tags=["Root"])
async def root():
    """
    Root endpoint providing basic service status.
    """
    return {"status": "ok", "service": settings.PROJECT_NAME, "environment": settings.ENVIRONMENT}

```