```python
# /logging_config.py
# Description: Configures structured JSON logging for HIPAA audit trails.

import logging
import logging.config
import sys
import os
from typing import Dict, Any

LOG_LEVEL = os.getenv("LOG_LEVEL", "INFO").upper()

class JsonFormatter(logging.Formatter):
    """
    Formats log records as a JSON string, ensuring audit trails are machine-readable.
    """
    def format(self, record: logging.LogRecord) -> str:
        log_record: Dict[str, Any] = {
            "timestamp": self.formatTime(record, self.datefmt),
            "level": record.levelname,
            "message": record.getMessage(),
            "name": record.name,
        }
        if hasattr(record, 'audit_details'):
            log_record['audit'] = record.audit_details
        if record.exc_info:
            log_record['exception'] = self.formatException(record.exc_info)
        
        # Use default for custom serialization
        return str(log_record).replace("'", '"')

def get_logging_config() -> Dict[str, Any]:
    """
    Defines the dictionary configuration for the logging system.
    """
    return {
        "version": 1,
        "disable_existing_loggers": False,
        "formatters": {
            "json": {
                "()": JsonFormatter,
                "fmt": "%(asctime)s %(levelname)s %(name)s %(message)s",
                "datefmt": "%Y-%m-%dT%H:%M:%S%z",
            },
        },
        "handlers": {
            "stdout": {
                "class": "logging.StreamHandler",
                "stream": sys.stdout,
                "formatter": "json",
            },
        },
        "loggers": {
            "api": {
                "handlers": ["stdout"],
                "level": LOG_LEVEL,
                "propagate": False,
            },
            "uvicorn": {
                "handlers": ["stdout"],
                "level": LOG_LEVEL,
                "propagate": True,
            },
            "uvicorn.error": {
                "handlers": ["stdout"],
                "level": LOG_LEVEL,
                "propagate": True,
            },
            "uvicorn.access": {
                "handlers": ["stdout"],
                "level": "WARNING", # Suppress standard access logs in favor of audit logs
                "propagate": True,
            },
        },
        "root": {
            "handlers": ["stdout"],
            "level": LOG_LEVEL,
        },
    }

logging.config.dictConfig(get_logging_config())
audit_logger = logging.getLogger('api.audit')
app_logger = logging.getLogger('api.application')
```

```python
# /database.py
# Description: Database engine and session management using SQLAlchemy.

import os
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from typing import AsyncGenerator

# Use environment variables for database credentials.
# Example: postgresql+asyncpg://user:password@host:port/dbname
DATABASE_URL = os.getenv("DATABASE_URL")
if not DATABASE_URL:
    raise ValueError("DATABASE_URL environment variable is not set.")

# Create an async engine.
# pool_size and max_overflow are configured for production loads.
engine = create_async_engine(
    DATABASE_URL,
    pool_size=20,
    max_overflow=10,
    pool_recycle=3600, # Recycle connections every hour
    echo=False # Do not log SQL statements to stdout in production
)

# Create a sessionmaker for creating async sessions.
AsyncSessionLocal = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False,
)

Base = declarative_base()

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """
    FastAPI dependency to provide a database session per request.
    Ensures the session is always closed, even if errors occur.
    """
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()
```

```python
# /models.py
# Description: SQLAlchemy ORM models representing database tables.

import enum
from sqlalchemy import (
    Column, Integer, String, DateTime, Boolean, ForeignKey, Enum, JSON
)
from sqlalchemy.sql import func
from .database import Base

class UserRole(str, enum.Enum):
    PHYSICIAN = "physician"
    NURSE = "nurse"
    ADMIN = "admin"
    PATIENT = "patient" # For patient portal access

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, nullable=False)
    role = Column(Enum(UserRole), nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

class Patient(Base):
    __tablename__ = "patients"
    id = Column(Integer, primary_key=True, index=True)
    first_name = Column(String, nullable=False)
    last_name = Column(String, nullable=False)
    date_of_birth = Column(DateTime(timezone=True), nullable=False)
    mrn = Column(String, unique=True, index=True, nullable=False) # Medical Record Number

class AuditLog(Base):
    __tablename__ = "audit_logs"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    patient_id = Column(Integer, ForeignKey("patients.id"), nullable=True)
    action = Column(String, nullable=False)
    timestamp = Column(DateTime(timezone=True), server_default=func.now())
    ip_address = Column(String, nullable=False)
    user_agent = Column(String, nullable=False)
    details = Column(JSON, nullable=True)

# Example clinical data models
class VitalSign(Base):
    __tablename__ = "vital_signs"
    id = Column(Integer, primary_key=True, index=True)
    patient_id = Column(Integer, ForeignKey("patients.id"), nullable=False)
    recorded_at = Column(DateTime(timezone=True), server_default=func.now())
    heart_rate = Column(Integer)
    blood_pressure_systolic = Column(Integer)
    blood_pressure_diastolic = Column(Integer)
    temperature_celsius = Column(Integer)

class Medication(Base):
    __tablename__ = "medications"
    id = Column(Integer, primary_key=True, index=True)
    patient_id = Column(Integer, ForeignKey("patients.id"), nullable=False)
    name = Column(String, nullable=False)
    dosage = Column(String, nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)

class Diagnosis(Base):
    __tablename__ = "diagnoses"
    id = Column(Integer, primary_key=True, index=True)
    patient_id = Column(Integer, ForeignKey("patients.id"), nullable=False)
    code = Column(String, nullable=False) # e.g., ICD-10 code
    description = Column(String, nullable=False)
    is_active = Column(Boolean, default=True, nullable=False)

```

```python
# /schemas.py
# Description: Pydantic models for API data validation and serialization.

from pydantic import BaseModel, Field
from datetime import datetime
from typing import List, Optional, Dict, Any
from .models import UserRole

# --- Token Schemas ---
class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None
    user_id: Optional[int] = None
    role: Optional[UserRole] = None

# --- User Schemas ---
class UserBase(BaseModel):
    username: str
    full_name: str
    role: UserRole

class UserInDB(UserBase):
    id: int
    is_active: bool
    hashed_password: str

    class Config:
        orm_mode = True

# --- Clinical Data Schemas (for Patient Summary) ---
class VitalSignSummary(BaseModel):
    recorded_at: datetime
    heart_rate: Optional[int]
    blood_pressure: Optional[str]

    class Config:
        orm_mode = True

class MedicationSummary(BaseModel):
    name: str
    dosage: str

    class Config:
        orm_mode = True

class DiagnosisSummary(BaseModel):
    code: str
    description: str

    class Config:
        orm_mode = True

# --- Patient Schemas ---
class PatientSummary(BaseModel):
    """
    Represents the secure, minimal patient summary returned by the API.
    Does not include sensitive identifiers like MRN unless necessary for the workflow.
    """
    patient_id: int
    first_name: str
    last_name: str
    date_of_birth: datetime
    latest_vitals: Optional[VitalSignSummary]
    active_medications: List[MedicationSummary] = []
    active_diagnoses: List[DiagnosisSummary] = []

# --- Audit Log Schemas ---
class AuditLogCreate(BaseModel):
    user_id: int
    action: str
    ip_address: str
    user_agent: str
    patient_id: Optional[int] = None
    details: Optional[Dict[str, Any]] = None
```

```python
# /security.py
# Description: Handles password hashing, JWT creation, and JWT verification.

import os
from datetime import datetime, timedelta
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from . import schemas

# Load secrets from environment variables
SECRET_KEY = os.getenv("SECRET_KEY")
ALGORITHM = os.getenv("ALGORITHM", "HS256")
ACCESS_TOKEN_EXPIRE_MINUTES = int(os.getenv("ACCESS_TOKEN_EXPIRE_MINUTES", 30))

if not SECRET_KEY:
    raise ValueError("SECRET_KEY environment variable not set for JWT.")

# Use bcrypt for password hashing, the standard for secure password storage.
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifies a plain-text password against a hashed one."""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hashes a plain-text password."""
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Creates a JWT access token."""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt

def decode_access_token(token: str) -> Optional[schemas.TokenData]:
    """Decodes a JWT, validates it, and returns the payload as TokenData."""
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM])
        username: str = payload.get("sub")
        user_id: int = payload.get("id")
        role: str = payload.get("role")
        if username is None or user_id is None or role is None:
            return None
        return schemas.TokenData(username=username, user_id=user_id, role=role)
    except JWTError:
        return None
```

```python
# /crud.py
# Description: Data Access Layer. Functions for database Create, Read, Update, Delete.

from sqlalchemy.orm import Session
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from . import models, schemas, security
from typing import Optional, List

# --- User CRUD ---
async def get_user_by_username(db: Session, username: str) -> Optional[models.User]:
    """Retrieves a user from the database by their username."""
    result = await db.execute(select(models.User).filter(models.User.username == username))
    return result.scalars().first()

# --- Audit Log CRUD ---
async def create_audit_log(db: Session, log_entry: schemas.AuditLogCreate):
    """Creates a new audit log entry in the database."""
    db_log = models.AuditLog(**log_entry.dict())
    db.add(db_log)
    await db.commit()
    # In a real system, you might not await commit here for performance,
    # but for strict compliance, ensuring the log is written is paramount.
    await db.refresh(db_log)
    return db_log

# --- Patient Data CRUD ---
async def get_patient_summary(db: Session, patient_id: int) -> Optional[schemas.PatientSummary]:
    """
    Retrieves and assembles a patient's summary information.
    This demonstrates the "Minimum Necessary" HIPAA principle by fetching
    only required summary data, not the entire patient record.
    """
    # 1. Fetch Patient Demographics
    patient_result = await db.execute(
        select(models.Patient).filter(models.Patient.id == patient_id)
    )
    patient = patient_result.scalars().first()
    if not patient:
        return None

    # 2. Fetch Latest Vitals
    vitals_result = await db.execute(
        select(models.VitalSign)
        .filter(models.VitalSign.patient_id == patient_id)
        .order_by(models.VitalSign.recorded_at.desc())
        .limit(1)
    )
    latest_vitals = vitals_result.scalars().first()

    # 3. Fetch Active Medications
    meds_result = await db.execute(
        select(models.Medication)
        .filter(models.Medication.patient_id == patient_id, models.Medication.is_active == True)
    )
    active_meds = meds_result.scalars().all()

    # 4. Fetch Active Diagnoses
    dx_result = await db.execute(
        select(models.Diagnosis)
        .filter(models.Diagnosis.patient_id == patient_id, models.Diagnosis.is_active == True)
    )
    active_dx = dx_result.scalars().all()
    
    # 5. Assemble the Pydantic response model
    vitals_summary = None
    if latest_vitals:
        vitals_summary = schemas.VitalSignSummary(
            recorded_at=latest_vitals.recorded_at,
            heart_rate=latest_vitals.heart_rate,
            blood_pressure=f"{latest_vitals.blood_pressure_systolic}/{latest_vitals.blood_pressure_diastolic}"
        )

    patient_summary = schemas.PatientSummary(
        patient_id=patient.id,
        first_name=patient.first_name,
        last_name=patient.last_name,
        date_of_birth=patient.date_of_birth,
        latest_vitals=vitals_summary,
        active_medications=[schemas.MedicationSummary.from_orm(med) for med in active_meds],
        active_diagnoses=[schemas.DiagnosisSummary.from_orm(dx) for dx in active_dx]
    )
    
    return patient_summary
```

```python
# /dependencies.py
# Description: FastAPI dependencies for authentication and authorization.

from fastapi import Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.ext.asyncio import AsyncSession
from . import crud, models, schemas, security
from .database import get_db

# This defines the URL where the client will send the username and password
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

async def get_current_user(
    db: AsyncSession = Depends(get_db), token: str = Depends(oauth2_scheme)
) -> models.User:
    """
    Dependency to get the current user from a JWT token.
    Decodes token, validates user existence in DB.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    token_data = security.decode_access_token(token)
    if token_data is None or token_data.username is None:
        raise credentials_exception
    
    user = await crud.get_user_by_username(db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(
    current_user: models.User = Depends(get_current_user)
) -> models.User:
    """
    Dependency to ensure the user fetched from the token is active.
    This is a critical security check.
    """
    if not current_user.is_active:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")
    return current_user

async def get_request_metadata(request: Request):
    """Dependency to extract common request metadata for audit logging."""
    return {
        "ip_address": request.client.host if request.client else "unknown",
        "user_agent": request.headers.get("user-agent", "unknown")
    }
```

```python
# /main.py
# Description: Main FastAPI application, defines API endpoints.

from fastapi import FastAPI, Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession
from datetime import timedelta
from typing import Dict

from . import crud, models, schemas, security
from .database import get_db
from .dependencies import get_current_active_user, get_request_metadata
from .logging_config import audit_logger, app_logger

app = FastAPI(
    title="Secure EMR API",
    description="Backend services for a HIPAA-compliant Electronic Medical Record system.",
    version="1.0.0",
)

@app.post("/token", response_model=schemas.Token)
async def login_for_access_token(
    db: AsyncSession = Depends(get_db),
    form_data: OAuth2PasswordRequestForm = Depends(),
    metadata: Dict = Depends(get_request_metadata)
):
    """
    OAuth2-compatible endpoint to authenticate a user and issue a JWT.
    Logs successful and failed login attempts for security auditing.
    """
    user = await crud.get_user_by_username(db, username=form_data.username)
    
    audit_details = {
        "username_attempt": form_data.username,
        "ip": metadata['ip_address'],
        "user_agent": metadata['user_agent']
    }

    if not user or not security.verify_password(form_data.password, user.hashed_password):
        audit_logger.warning("Failed login attempt", extra={'audit_details': audit_details})
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    if not user.is_active:
        audit_logger.warning("Login attempt by inactive user", extra={'audit_details': audit_details})
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")
    
    access_token_expires = timedelta(minutes=security.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = security.create_access_token(
        data={"sub": user.username, "id": user.id, "role": user.role.value},
        expires_delta=access_token_expires,
    )

    audit_details['user_id'] = user.id
    audit_logger.info("User authenticated successfully", extra={'audit_details': audit_details})

    return {"access_token": access_token, "token_type": "bearer"}


@app.get(
    "/v1/patients/{patient_id}/summary",
    response_model=schemas.PatientSummary,
    summary="Get Patient Chart Summary",
    description="Retrieves a consolidated summary of a patient's chart. Access is strictly audited."
)
async def read_patient_summary(
    patient_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: models.User = Depends(get_current_active_user),
    metadata: Dict = Depends(get_request_metadata)
):
    """
    Secure endpoint to retrieve a patient's chart summary.
    1. Authenticates and authorizes the user via JWT.
    2. Enforces Role-Based Access Control (RBAC).
    3. Creates a detailed audit log entry for every access attempt.
    4. Returns a minimal, necessary set of patient data.
    """
    # Authorization check: Simple RBAC. Real systems may use complex ABAC.
    if current_user.role not in [models.UserRole.PHYSICIAN, models.UserRole.NURSE]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User does not have permission to access patient data."
        )

    # Fetch patient data from the database
    patient_summary = await crud.get_patient_summary(db, patient_id=patient_id)
    
    if patient_summary is None:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Patient not found")
        
    # --- HIPAA Audit Log Creation ---
    # This is a critical step. The access event MUST be logged before returning data.
    # If logging fails, the request should fail to prevent un-audited data access.
    try:
        audit_log_entry = schemas.AuditLogCreate(
            user_id=current_user.id,
            patient_id=patient_id,
            action="VIEW_PATIENT_SUMMARY",
            ip_address=metadata['ip_address'],
            user_agent=metadata['user_agent'],
            details={
                "requester_role": current_user.role.value,
                "patient_mrn": "MRN_HIDDEN_FOR_LOG_BREVITY" # In a real system, you might log the MRN
            }
        )
        await crud.create_audit_log(db, log_entry=audit_log_entry)
        audit_logger.info(
            f"User {current_user.username} accessed summary for patient {patient_id}",
            extra={'audit_details': audit_log_entry.dict()}
        )
    except Exception as e:
        app_logger.error(f"CRITICAL: Failed to create audit log for user {current_user.id} accessing patient {patient_id}. Error: {e}")
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Could not process request due to an internal logging failure."
        )

    return patient_summary
```