```python
# /core/config.py

import os
from pydantic_settings import BaseSettings
from functools import lru_cache

class Settings(BaseSettings):
    """
    Manages application configuration using environment variables.
    """
    # Application settings
    PROJECT_NAME: str = "EMR_Backend_System"
    API_V1_STR: str = "/api/v1"

    # Security settings
    # In production, use a secrets manager. For this example, load from env.
    # Generate a key using: openssl rand -hex 32
    SECRET_KEY: str
    # Generate an encryption key using: from cryptography.fernet import Fernet; Fernet.generate_key().decode()
    ENCRYPTION_KEY: str
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60
    JWT_ALGORITHM: str = "HS256"

    # Database settings
    POSTGRES_SERVER: str
    POSTGRES_USER: str
    POSTGRES_PASSWORD: str
    POSTGRES_DB: str
    
    @property
    def DATABASE_URL(self) -> str:
        """Constructs the asynchronous database URL."""
        return f"postgresql+asyncpg://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}@{self.POSTGRES_SERVER}/{self.POSTGRES_DB}"

    class Config:
        case_sensitive = True
        env_file = ".env"

@lru_cache()
def get_settings():
    return Settings()

settings = get_settings()

# /database.py

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from core.config import settings

# Create an asynchronous engine instance
engine = create_async_engine(settings.DATABASE_URL, pool_pre_ping=True)

# Create a session factory
AsyncSessionLocal = sessionmaker(
    autocommit=False, 
    autoflush=False, 
    bind=engine, 
    class_=AsyncSession,
    expire_on_commit=False
)

# Base class for declarative models
Base = declarative_base()

async def get_db() -> AsyncSession:
    """
    Dependency to get an async database session.
    Ensures the session is closed after the request.
    """
    async with AsyncSessionLocal() as session:
        yield session

# /models/base.py

from .user import User
from .patient import Patient, PatientCareTeam
from .clinical_note import ClinicalNote
from .audit_log import AuditLog
from database import Base

# This file ensures all models are imported before Base.metadata.create_all is called.

# /models/user.py

from sqlalchemy import Column, Integer, String, Boolean
from database import Base

class User(Base):
    """
    Represents a system user (e.g., clinician, admin).
    """
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, nullable=False)
    role = Column(String, nullable=False) # e.g., 'clinician', 'admin'
    is_active = Column(Boolean, default=True)

# /models/patient.py

from sqlalchemy import Column, Integer, String, ForeignKey, Table
from sqlalchemy.orm import relationship
from database import Base

# Association table for the many-to-many relationship between Patients and Users (Care Team)
PatientCareTeam = Table('patient_care_team', Base.metadata,
    Column('patient_id', Integer, ForeignKey('patients.id'), primary_key=True),
    Column('user_id', Integer, ForeignKey('users.id'), primary_key=True)
)

class Patient(Base):
    """
    Represents a patient in the EMR system.
    """
    __tablename__ = "patients"

    id = Column(Integer, primary_key=True, index=True)
    medical_record_number = Column(String, unique=True, index=True, nullable=False)
    
    care_team = relationship("User", secondary=PatientCareTeam)
    notes = relationship("ClinicalNote", back_populates="patient", cascade="all, delete-orphan")

# /models/clinical_note.py

from sqlalchemy import Column, Integer, LargeBinary, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database import Base

class ClinicalNote(Base):
    """
    Represents a single clinical note associated with a patient.
    Note content is encrypted at rest.
    """
    __tablename__ = "clinical_notes"

    id = Column(Integer, primary_key=True, index=True)
    patient_id = Column(Integer, ForeignKey("patients.id"), nullable=False, index=True)
    author_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    
    encrypted_content = Column(LargeBinary, nullable=False)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    author = relationship("User")
    patient = relationship("Patient", back_populates="notes")

# /models/audit_log.py

from sqlalchemy import Column, Integer, String, DateTime, ForeignKey, Enum
from sqlalchemy.sql import func
from database import Base
import enum

class AuditAction(enum.Enum):
    LOGIN_SUCCESS = "LOGIN_SUCCESS"
    LOGIN_FAIL = "LOGIN_FAIL"
    VIEW_NOTE = "VIEW_NOTE"
    CREATE_NOTE = "CREATE_NOTE"
    UPDATE_NOTE = "UPDATE_NOTE"
    DELETE_NOTE = "DELETE_NOTE"
    ACCESS_DENIED = "ACCESS_DENIED"

class AuditLog(Base):
    """
    Represents an audit trail event, crucial for HIPAA compliance.
    """
    __tablename__ = "audit_logs"

    id = Column(Integer, primary_key=True, index=True)
    timestamp = Column(DateTime(timezone=True), server_default=func.now())
    user_id = Column(Integer, ForeignKey("users.id"), nullable=True) # Nullable for system events
    action = Column(Enum(AuditAction), nullable=False)
    resource_type = Column(String, nullable=True) # e.g., 'patient', 'clinical_note'
    resource_id = Column(Integer, nullable=True)
    details = Column(String, nullable=True) # e.g., IP address, user agent

# /security/encryption.py

from cryptography.fernet import Fernet, InvalidToken
from core.config import settings

class Encryptor:
    """
    Handles encryption and decryption of sensitive data.
    """
    def __init__(self, key: bytes):
        self.fernet = Fernet(key)

    def encrypt(self, data: str) -> bytes:
        """Encrypts a string and returns bytes."""
        return self.fernet.encrypt(data.encode('utf-8'))

    def decrypt(self, encrypted_data: bytes) -> str:
        """Decrypts bytes and returns a string."""
        try:
            return self.fernet.decrypt(encrypted_data).decode('utf-8')
        except InvalidToken:
            # Handle cases where data is not valid encrypted data
            raise ValueError("Invalid encrypted data or key.")

encryptor = Encryptor(key=settings.ENCRYPTION_KEY.encode('utf-8'))

# /services/audit_service.py

from sqlalchemy.ext.asyncio import AsyncSession
from models.audit_log import AuditLog, AuditAction
from typing import Optional

async def log_action(
    db: AsyncSession,
    *,
    user_id: Optional[int],
    action: AuditAction,
    resource_type: Optional[str] = None,
    resource_id: Optional[int] = None,
    details: Optional[str] = None
):
    """
    Creates an audit log entry in the database.
    """
    audit_entry = AuditLog(
        user_id=user_id,
        action=action,
        resource_type=resource_type,
        resource_id=resource_id,
        details=details
    )
    db.add(audit_entry)
    await db.commit()

# /schemas/token.py

from pydantic import BaseModel
from typing import Optional

class Token(BaseModel):
    """Schema for the access token response."""
    access_token: str
    token_type: str

class TokenData(BaseModel):
    """Schema for the data encoded within the JWT."""
    username: Optional[str] = None

# /schemas/user.py

from pydantic import BaseModel
from typing import Optional

class UserBase(BaseModel):
    username: str
    full_name: Optional[str] = None
    role: str

class UserCreate(UserBase):
    password: str

class User(UserBase):
    id: int
    is_active: bool

    class Config:
        from_attributes = True

# /schemas/clinical_note.py

from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class ClinicalNoteBase(BaseModel):
    """Base schema for clinical note data."""
    content: str

class ClinicalNoteCreate(ClinicalNoteBase):
    """Schema for creating a new clinical note."""
    pass

class ClinicalNoteRead(BaseModel):
    """
    Schema for reading a clinical note's metadata.
    Excludes sensitive PHI content by default.
    """
    id: int
    patient_id: int
    author_id: int
    created_at: datetime
    updated_at: Optional[datetime] = None
    
    class Config:
        from_attributes = True

class ClinicalNoteReadFull(ClinicalNoteRead):
    """
    Schema for reading a full clinical note, including decrypted content.
    For use only in authorized contexts.
    """
    content: str

# /crud/crud_user.py

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from models.user import User
from typing import Optional

async def get_user_by_username(db: AsyncSession, username: str) -> Optional[User]:
    """Fetches a user by their username."""
    result = await db.execute(select(User).where(User.username == username))
    return result.scalars().first()

# /crud/crud_patient.py

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from models.patient import Patient, PatientCareTeam

async def check_user_access_to_patient(db: AsyncSession, *, user_id: int, patient_id: int) -> bool:
    """
    Verifies if a user is part of a patient's care team.
    This is a critical authorization check for HIPAA compliance.
    """
    query = (
        select(Patient)
        .join(PatientCareTeam)
        .where(Patient.id == patient_id)
        .where(PatientCareTeam.c.user_id == user_id)
    )
    result = await db.execute(query)
    return result.scalars().first() is not None

# /crud/crud_clinical_note.py

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from models.clinical_note import ClinicalNote
from schemas.clinical_note import ClinicalNoteCreate
from security.encryption import encryptor
from typing import Optional

async def create_note(db: AsyncSession, *, note_in: ClinicalNoteCreate, patient_id: int, author_id: int) -> ClinicalNote:
    """Creates a new clinical note, encrypting its content before saving."""
    encrypted_content = encryptor.encrypt(note_in.content)
    db_note = ClinicalNote(
        patient_id=patient_id,
        author_id=author_id,
        encrypted_content=encrypted_content
    )
    db.add(db_note)
    await db.commit()
    await db.refresh(db_note)
    return db_note

async def get_note(db: AsyncSession, *, note_id: int, patient_id: int) -> Optional[ClinicalNote]:
    """Retrieves a specific clinical note for a given patient."""
    result = await db.execute(
        select(ClinicalNote).where(ClinicalNote.id == note_id, ClinicalNote.patient_id == patient_id)
    )
    return result.scalars().first()

# /security/authentication.py

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from jose import JWTError, jwt
from passlib.context import CryptContext
from datetime import datetime, timedelta, timezone
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Optional

from core.config import settings
from database import get_db
from models.user import User
from schemas.token import TokenData
from crud import crud_user

# Setup password hashing
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{settings.API_V1_STR}/token")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifies a plain password against a hashed one."""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hashes a plain password."""
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Creates a JWT access token."""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.JWT_ALGORITHM)
    return encoded_jwt

async def get_current_user(
    db: AsyncSession = Depends(get_db), token: str = Depends(oauth2_scheme)
) -> User:
    """
    Dependency to get the current user from a JWT token.
    Decodes the token, validates it, and fetches the user from the database.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.JWT_ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except JWTError:
        raise credentials_exception
    
    user = await crud_user.get_user_by_username(db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(current_user: User = Depends(get_current_user)) -> User:
    """
    Dependency to ensure the current user is active.
    Raises an exception if the user is marked as inactive.
    """
    if not current_user.is_active:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")
    return current_user

# /api/deps.py

from fastapi import Depends, HTTPException, status, Path
from sqlalchemy.ext.asyncio import AsyncSession
from database import get_db
from models.user import User
from crud import crud_patient
from security.authentication import get_current_active_user
from services.audit_service import log_action
from models.audit_log import AuditAction

async def get_patient_if_authorized(
    patient_id: int = Path(..., title="The ID of the patient to access"),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_active_user),
) -> int:
    """
    Dependency that verifies if the current user is authorized to access
    the specified patient's data. Raises 403 Forbidden if not.
    This is a cornerstone of HIPAA's minimum necessary principle.
    """
    is_authorized = await crud_patient.check_user_access_to_patient(db=db, user_id=current_user.id, patient_id=patient_id)
    if not is_authorized:
        await log_action(
            db,
            user_id=current_user.id,
            action=AuditAction.ACCESS_DENIED,
            resource_type="patient",
            resource_id=patient_id,
            details=f"User attempted to access records for patient {patient_id} without authorization."
        )
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User does not have access to this patient's records"
        )
    return patient_id

# /api/v1/endpoints/clinical_notes.py

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Any

from database import get_db
from models.user import User
from models.audit_log import AuditAction
from schemas.clinical_note import ClinicalNoteCreate, ClinicalNoteReadFull
from crud import crud_clinical_note
from security.encryption import encryptor
from api import deps
from services import audit_service

router = APIRouter()

@router.post(
    "/",
    response_model=ClinicalNoteReadFull,
    status_code=status.HTTP_201_CREATED,
    summary="Create a Clinical Note",
    description="Creates a new clinical note for a patient, accessible only by their authorized care team.",
)
async def create_clinical_note(
    *,
    db: AsyncSession = Depends(get_db),
    note_in: ClinicalNoteCreate,
    current_user: User = Depends(deps.get_current_active_user),
    patient_id: int = Depends(deps.get_patient_if_authorized),
) -> Any:
    """
    Creates a new clinical note associated with an authorized patient.
    The action is logged for audit purposes.
    """
    note = await crud_clinical_note.create_note(
        db=db, note_in=note_in, patient_id=patient_id, author_id=current_user.id
    )
    
    await audit_service.log_action(
        db,
        user_id=current_user.id,
        action=AuditAction.CREATE_NOTE,
        resource_type="clinical_note",
        resource_id=note.id
    )
    
    decrypted_content = encryptor.decrypt(note.encrypted_content)
    return ClinicalNoteReadFull(**note.__dict__, content=decrypted_content)


@router.get(
    "/{note_id}",
    response_model=ClinicalNoteReadFull,
    summary="Retrieve a Clinical Note",
    description="Retrieves a specific clinical note, accessible only by the patient's authorized care team.",
)
async def read_clinical_note(
    *,
    note_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(deps.get_current_active_user),
    patient_id: int = Depends(deps.get_patient_if_authorized),
) -> Any:
    """
    Retrieves a specific clinical note by its ID.
    Access is first verified at the patient level. Then the note is fetched.
    The view action is logged for audit purposes.
    """
    note = await crud_clinical_note.get_note(db=db, note_id=note_id, patient_id=patient_id)
    if not note:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Clinical note not found")

    await audit_service.log_action(
        db,
        user_id=current_user.id,
        action=AuditAction.VIEW_NOTE,
        resource_type="clinical_note",
        resource_id=note.id
    )
    
    decrypted_content = encryptor.decrypt(note.encrypted_content)
    return ClinicalNoteReadFull(**note.__dict__, content=decrypted_content)

# /api/v1/endpoints/login.py

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession
from datetime import timedelta

from database import get_db
from schemas.token import Token
from crud import crud_user
from security.authentication import create_access_token, verify_password
from core.config import settings
from services.audit_service import log_action
from models.audit_log import AuditAction
from models.user import User

router = APIRouter()

@router.post("/token", response_model=Token)
async def login_for_access_token(
    db: AsyncSession = Depends(get_db), form_data: OAuth2PasswordRequestForm = Depends()
):
    """
    Provides a JWT token for valid user credentials.
    Logs successful and failed login attempts for security auditing.
    """
    user: User = await crud_user.get_user_by_username(db, username=form_data.username)
    
    if not user or not verify_password(form_data.password, user.hashed_password):
        await log_action(
            db, 
            user_id=user.id if user else None, 
            action=AuditAction.LOGIN_FAIL,
            details=f"Failed login attempt for username: {form_data.username}"
        )
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    await log_action(db, user_id=user.id, action=AuditAction.LOGIN_SUCCESS)
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

# /api/v1/api.py

from fastapi import APIRouter
from api.v1.endpoints import login, clinical_notes

api_router = APIRouter()

# Authentication Router
api_router.include_router(login.router, tags=["Authentication"])

# Clinical Notes Router with patient context
api_router.include_router(
    clinical_notes.router, 
    prefix="/patients/{patient_id}/notes", 
    tags=["Clinical Notes"]
)

# /main.py

from fastapi import FastAPI
from starlette.middleware.cors import CORSMiddleware
from core.config import settings
from api.v1.api import api_router
from database import Base, engine

# Initialize FastAPI app
app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_STR}/openapi.json",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], # In production, restrict to known frontends
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# Include the main API router
app.include_router(api_router, prefix=settings.API_V1_STR)

@app.on_event("startup")
async def on_startup():
    """
    On application startup, create database tables.
    For production, this should be handled by a migration tool like Alembic.
    """
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

@app.get("/", status_code=status.HTTP_200_OK, tags=["Health Check"])
def health_check():
    """Root endpoint for basic health checks and service discovery."""
    return {"status": "ok", "service": settings.PROJECT_NAME}

```