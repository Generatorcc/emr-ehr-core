```python
# /core/config.py

import os
from pydantic_settings import BaseSettings
from typing import List

class Settings(BaseSettings):
    """
    Application configuration settings loaded from environment variables.
    """
    # Application settings
    API_V1_STR: str = "/api/v1"
    PROJECT_NAME: str = "EMR Backend System"
    
    # Security settings
    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # Database settings
    POSTGRES_SERVER: str
    POSTGRES_USER: str
    POSTGRES_PASSWORD: str
    POSTGRES_DB: str
    
    @property
    def DATABASE_URL(self) -> str:
        return f"postgresql+asyncpg://{self.POSTGRES_USER}:{self.POSTGRES_PASSWORD}@{self.POSTGRES_SERVER}/{self.POSTGRES_DB}"

    # Encrypted Storage (S3-compatible) settings
    S3_ENDPOINT_URL: str
    S3_ACCESS_KEY_ID: str
    S3_SECRET_ACCESS_KEY: str
    S3_BUCKET_NAME: str
    S3_REGION: str = "us-east-1"
    PRESIGNED_URL_EXPIRATION_SECONDS: int = 3600 # 1 hour

    class Config:
        case_sensitive = True
        env_file = ".env"

settings = Settings()
```

```python
# /core/database.py

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from .config import settings

engine = create_async_engine(settings.DATABASE_URL, pool_pre_ping=True)
AsyncSessionLocal = sessionmaker(
    autocommit=False, 
    autoflush=False, 
    bind=engine, 
    class_=AsyncSession
)

Base = declarative_base()

async def get_db_session() -> AsyncSession:
    """
    Dependency to get a database session.
    Ensures the session is properly closed after the request.
    """
    async with AsyncSessionLocal() as session:
        yield session
```

```python
# /models/audit.py

import uuid
from sqlalchemy import Column, String, DateTime, Enum as SQLAlchemyEnum, ForeignKey
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
import enum
from core.database import Base

class AuditAction(str, enum.Enum):
    CREATE = "CREATE"
    READ = "READ"
    UPDATE = "UPDATE"
    DELETE = "DELETE"
    LOGIN_SUCCESS = "LOGIN_SUCCESS"
    LOGIN_FAIL = "LOGIN_FAIL"
    DOCUMENT_UPLOAD = "DOCUMENT_UPLOAD"
    DOCUMENT_DOWNLOAD_LINK_GENERATED = "DOCUMENT_DOWNLOAD_LINK_GENERATED"
    DOCUMENT_LIST = "DOCUMENT_LIST"

class AuditLog(Base):
    """
    SQLAlchemy model for recording audit trail events.
    Complies with HIPAA ยง164.312(b) for audit controls.
    """
    __tablename__ = "audit_logs"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    action = Column(SQLAlchemyEnum(AuditAction), nullable=False)
    timestamp = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    ip_address = Column(String(45), nullable=True) # Supports IPv6
    user_agent = Column(String(255), nullable=True)
    target_resource = Column(String(255), nullable=True, index=True) # e.g., "patient/patient_id/document/doc_id"
    status = Column(String(50), default="SUCCESS")
    details = Column(String(512), nullable=True)
```

```python
# /models/user.py

import uuid
from sqlalchemy import Column, String, Boolean, Enum as SQLAlchemyEnum
from sqlalchemy.dialects.postgresql import UUID
import enum
from core.database import Base

class UserRole(str, enum.Enum):
    PHYSICIAN = "physician"
    NURSE = "nurse"
    ADMIN = "admin"
    PATIENT = "patient" # For patient portal access, if applicable

class User(Base):
    """
    SQLAlchemy model for system users (healthcare professionals).
    """
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username = Column(String, unique=True, index=True, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, index=True)
    role = Column(SQLAlchemyEnum(UserRole), nullable=False, default=UserRole.NURSE)
    is_active = Column(Boolean(), default=True)
    is_superuser = Column(Boolean(), default=False)
```

```python
# /models/patient.py

import uuid
from sqlalchemy import Column, String, Date, DateTime
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
from core.database import Base

class Patient(Base):
    """
    SQLAlchemy model for patients. Contains only non-sensitive identifiers.
    Sensitive PHI should be linked via secure documents or other tables.
    """
    __tablename__ = "patients"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    mrn = Column(String, unique=True, index=True, nullable=False) # Medical Record Number
    first_name = Column(String, nullable=False)
    last_name = Column(String, nullable=False)
    date_of_birth = Column(Date, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
```

```python
# /models/document.py

import uuid
from sqlalchemy import Column, String, DateTime, ForeignKey
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
from core.database import Base

class Document(Base):
    """
    SQLAlchemy model for document metadata.
    The actual file is stored in an encrypted object store (e.g., S3).
    """
    __tablename__ = "documents"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    patient_id = Column(UUID(as_uuid=True), ForeignKey("patients.id"), nullable=False, index=True)
    uploader_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    
    file_name = Column(String, nullable=False)
    file_type = Column(String, nullable=False) # e.g., 'application/pdf'
    file_size_bytes = Column(String, nullable=False)
    storage_key = Column(String, unique=True, nullable=False) # Key in the S3 bucket
    
    document_type = Column(String, index=True) # e.g., 'Lab Report', 'Imaging', 'Discharge Summary'
    description = Column(String, nullable=True)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
```

```python
# /schemas/document.py

import uuid
from pydantic import BaseModel, Field
from datetime import datetime
from typing import Optional

class DocumentBase(BaseModel):
    document_type: str = Field(..., description="Type of the document, e.g., 'Lab Report'.")
    description: Optional[str] = Field(None, description="Optional description of the document.")
    file_name: str = Field(..., description="Original name of the uploaded file.")

class DocumentCreate(BaseModel):
    patient_id: uuid.UUID
    uploader_id: uuid.UUID
    file_name: str
    file_type: str
    file_size_bytes: int
    storage_key: str
    document_type: str
    description: Optional[str] = None

class DocumentResponse(DocumentBase):
    id: uuid.UUID
    patient_id: uuid.UUID
    uploader_id: uuid.UUID
    file_type: str
    file_size_bytes: int
    created_at: datetime

    class Config:
        from_attributes = True

class DocumentDownloadLink(BaseModel):
    download_url: str
    expires_at: datetime
```

```python
# /services/audit_service.py

from sqlalchemy.ext.asyncio import AsyncSession
from fastapi import Request
from models.audit import AuditLog, AuditAction
from models.user import User
import uuid

async def create_audit_log(
    db: AsyncSession,
    *,
    user: User,
    action: AuditAction,
    target_resource: str,
    request: Request,
    status: str = "SUCCESS",
    details: str | None = None
) -> None:
    """
    Creates an audit log entry in the database.
    """
    log_entry = AuditLog(
        user_id=user.id,
        action=action,
        ip_address=request.client.host,
        user_agent=request.headers.get("user-agent"),
        target_resource=target_resource,
        status=status,
        details=details
    )
    db.add(log_entry)
    await db.commit()
```

```python
# /services/storage_service.py

import boto3
from botocore.client import Config
from botocore.exceptions import ClientError
from core.config import settings
import logging
from datetime import datetime, timedelta, timezone

logger = logging.getLogger(__name__)

class StorageService:
    """
    Service for interacting with S3-compatible encrypted object storage.
    """
    def __init__(self):
        self.s3_client = boto3.client(
            's3',
            endpoint_url=settings.S3_ENDPOINT_URL,
            aws_access_key_id=settings.S3_ACCESS_KEY_ID,
            aws_secret_access_key=settings.S3_SECRET_ACCESS_KEY,
            region_name=settings.S3_REGION,
            config=Config(signature_version='s3v4')
        )
        self.bucket_name = settings.S3_BUCKET_NAME

    def upload_file_obj(self, file_obj, object_name: str, content_type: str) -> bool:
        """
        Uploads a file-like object to the S3 bucket.
        :param file_obj: File-like object to upload.
        :param object_name: S3 object name.
        :param content_type: The MIME type of the file.
        :return: True if file was uploaded, else False.
        """
        try:
            self.s3_client.upload_fileobj(
                file_obj, 
                self.bucket_name, 
                object_name,
                ExtraArgs={
                    'ContentType': content_type,
                    'ServerSideEncryption': 'AES256' # Enforce SSE
                }
            )
        except ClientError as e:
            logger.error(f"S3 Upload Error: {e}")
            return False
        return True

    def generate_presigned_url(self, object_name: str) -> tuple[str | None, datetime | None]:
        """
        Generates a presigned URL to share an S3 object.
        :param object_name: S3 object name.
        :return: A tuple of (presigned URL, expiration_datetime) or (None, None) if error.
        """
        expiration = settings.PRESIGNED_URL_EXPIRATION_SECONDS
        try:
            url = self.s3_client.generate_presigned_url(
                'get_object',
                Params={'Bucket': self.bucket_name, 'Key': object_name},
                ExpiresIn=expiration
            )
            expires_at = datetime.now(timezone.utc) + timedelta(seconds=expiration)
            return url, expires_at
        except ClientError as e:
            logger.error(f"S3 Presigned URL Generation Error: {e}")
            return None, None

storage_service = StorageService()
```

```python
# /crud/document_crud.py

import uuid
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from models.document import Document
from schemas.document import DocumentCreate

async def create_document(db: AsyncSession, *, doc_in: DocumentCreate) -> Document:
    """Creates a new document metadata record in the database."""
    db_doc = Document(
        patient_id=doc_in.patient_id,
        uploader_id=doc_in.uploader_id,
        file_name=doc_in.file_name,
        file_type=doc_in.file_type,
        file_size_bytes=doc_in.file_size_bytes,
        storage_key=doc_in.storage_key,
        document_type=doc_in.document_type,
        description=doc_in.description
    )
    db.add(db_doc)
    await db.commit()
    await db.refresh(db_doc)
    return db_doc

async def get_document_by_id(db: AsyncSession, *, doc_id: uuid.UUID, patient_id: uuid.UUID) -> Document | None:
    """Retrieves a single document by its ID and patient ID for authorization."""
    statement = select(Document).where(Document.id == doc_id, Document.patient_id == patient_id)
    result = await db.execute(statement)
    return result.scalar_one_or_none()

async def get_documents_by_patient_id(db: AsyncSession, *, patient_id: uuid.UUID, skip: int = 0, limit: int = 100) -> list[Document]:
    """Retrieves a list of document metadata for a given patient."""
    statement = select(Document).where(Document.patient_id == patient_id).offset(skip).limit(limit).order_by(Document.created_at.desc())
    result = await db.execute(statement)
    return result.scalars().all()
```

```python
# /api/deps.py

from fastapi import Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from pydantic import BaseModel, ValidationError
from sqlalchemy.ext.asyncio import AsyncSession
from core.config import settings
from core.database import get_db_session
from models.user import User, UserRole
from sqlalchemy.future import select
import uuid

reusable_oauth2 = OAuth2PasswordBearer(tokenUrl=f"{settings.API_V1_STR}/login/token")

class TokenData(BaseModel):
    sub: str | None = None
    scopes: list[str] = []

async def get_current_user(
    db: AsyncSession = Depends(get_db_session), token: str = Depends(reusable_oauth2)
) -> User:
    """Dependency to get the current authenticated user from a JWT."""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(
            token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM]
        )
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(sub=username, scopes=payload.get("scopes", []))
    except (JWTError, ValidationError):
        raise credentials_exception
    
    statement = select(User).where(User.username == token_data.sub)
    result = await db.execute(statement)
    user = result.scalar_one_or_none()
    
    if user is None:
        raise credentials_exception
    return user

def require_role(required_role: UserRole):
    """
    Dependency that checks if the current user has the required role.
    """
    def role_checker(current_user: User = Depends(get_current_user)) -> User:
        if current_user.role != required_role and not current_user.is_superuser:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Operation not permitted. Requires role: {required_role.value}"
            )
        return current_user
    return role_checker

async def verify_patient_access(
    patient_id: uuid.UUID,
    db: AsyncSession = Depends(get_db_session),
    current_user: User = Depends(get_current_user)
) -> None:
    """
    Dependency to verify that the current user is authorized to access a patient's data.
    This is a placeholder for a real, complex authorization logic (e.g., checking care teams).
    For this example, we'll allow physicians and nurses to access any patient.
    """
    if current_user.is_superuser or current_user.role in [UserRole.PHYSICIAN, UserRole.NURSE, UserRole.ADMIN]:
        # A real system would check a Patient-Provider relationship table here.
        from models.patient import Patient
        patient = await db.get(Patient, patient_id)
        if not patient:
            raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Patient not found")
        return
    
    raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Not authorized to access this patient's records")
```

```python
# /api/v1/endpoints/documents.py

from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Form, Request
from sqlalchemy.ext.asyncio import AsyncSession
import uuid
from typing import List

from api import deps
from core.database import get_db_session
from crud import document_crud
from models.user import User, UserRole
from models.audit import AuditAction
from schemas.document import DocumentResponse, DocumentCreate, DocumentDownloadLink
from services.audit_service import create_audit_log
from services.storage_service import storage_service

router = APIRouter()

@router.post(
    "/{patient_id}/documents/",
    response_model=DocumentResponse,
    status_code=status.HTTP_201_CREATED,
    dependencies=[Depends(deps.require_role(UserRole.PHYSICIAN))] # Example role restriction
)
async def upload_patient_document(
    patient_id: uuid.UUID,
    request: Request,
    document_type: str = Form(...),
    description: str = Form(None),
    file: UploadFile = File(...),
    db: AsyncSession = Depends(get_db_session),
    current_user: User = Depends(deps.get_current_user),
    _patient_access: None = Depends(deps.verify_patient_access),
):
    """
    Uploads a document for a specific patient.
    The file is stored in a secure, encrypted object store, and metadata is saved to the database.
    An audit log is created for this action.
    """
    storage_key = f"{patient_id}/{uuid.uuid4()}-{file.filename}"
    
    if not storage_service.upload_file_obj(file.file, storage_key, file.content_type):
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Could not upload file to storage.")

    doc_in = DocumentCreate(
        patient_id=patient_id,
        uploader_id=current_user.id,
        file_name=file.filename,
        file_type=file.content_type,
        file_size_bytes=file.size,
        storage_key=storage_key,
        document_type=document_type,
        description=description,
    )
    
    db_document = await document_crud.create_document(db=db, doc_in=doc_in)

    await create_audit_log(
        db=db, user=current_user, action=AuditAction.DOCUMENT_UPLOAD,
        request=request, target_resource=f"patient/{patient_id}/document/{db_document.id}"
    )

    return db_document


@router.get(
    "/{patient_id}/documents/",
    response_model=List[DocumentResponse],
    dependencies=[Depends(deps.verify_patient_access)]
)
async def list_patient_documents(
    patient_id: uuid.UUID,
    request: Request,
    db: AsyncSession = Depends(get_db_session),
    current_user: User = Depends(deps.get_current_user),
    skip: int = 0,
    limit: int = 100,
):
    """
    Lists all document metadata for a specific patient.
    """
    documents = await document_crud.get_documents_by_patient_id(
        db=db, patient_id=patient_id, skip=skip, limit=limit
    )
    
    await create_audit_log(
        db=db, user=current_user, action=AuditAction.DOCUMENT_LIST,
        request=request, target_resource=f"patient/{patient_id}/documents"
    )

    return documents


@router.get(
    "/{patient_id}/documents/{document_id}/download-link",
    response_model=DocumentDownloadLink,
    dependencies=[Depends(deps.verify_patient_access)]
)
async def get_document_download_link(
    patient_id: uuid.UUID,
    document_id: uuid.UUID,
    request: Request,
    db: AsyncSession = Depends(get_db_session),
    current_user: User = Depends(deps.get_current_user),
):
    """
    Retrieves a secure, time-limited pre-signed URL to download a specific document.
    This prevents exposing raw PHI files through the API server directly.
    """
    document = await document_crud.get_document_by_id(db=db, doc_id=document_id, patient_id=patient_id)

    if not document:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Document not found for this patient.")

    url, expires_at = storage_service.generate_presigned_url(document.storage_key)
    
    if not url:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Could not generate download link.")

    await create_audit_log(
        db=db, user=current_user, action=AuditAction.DOCUMENT_DOWNLOAD_LINK_GENERATED,
        request=request, target_resource=f"patient/{patient_id}/document/{document_id}"
    )

    return DocumentDownloadLink(download_url=url, expires_at=expires_at)
```

```python
# /api/v1/api.py

from fastapi import APIRouter
from .endpoints import documents

api_router = APIRouter()
api_router.include_router(documents.router, prefix="/patients", tags=["Patient Documents"])

# Add other routers here, e.g., for authentication, patient management, etc.
# api_router.include_router(login.router, tags=["login"])
# api_router.include_router(users.router, prefix="/users", tags=["users"])
# api_router.include_router(patients.router, prefix="/patients", tags=["patients"])
```

```python
# /main.py

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from core.config import settings
from api.v1.api import api_router
from core.database import Base, engine

app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_STR}/openapi.json",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Set all CORS enabled origins
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], # In production, restrict this to trusted frontend domains
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.on_event("startup")
async def startup_event():
    """
    On application startup, create database tables if they don't exist.
    """
    async with engine.begin() as conn:
        # In a production environment with Alembic, you might remove this.
        # await conn.run_sync(Base.metadata.drop_all) # Use for development only
        await conn.run_sync(Base.metadata.create_all)

app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/", status_code=200, include_in_schema=False)
def read_root():
    """An unauthenticated root endpoint for health checks."""
    return {"status": "ok"}
```