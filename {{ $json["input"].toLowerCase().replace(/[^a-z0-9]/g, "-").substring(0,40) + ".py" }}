```python
# /core/config.py

import os
from pydantic_settings import BaseSettings
from typing import List

class Settings(BaseSettings):
    """
    Application settings loaded from environment variables.
    """
    PROJECT_NAME: str = "EMR-Backend-Service"
    API_V1_STR: str = "/api/v1"
    
    # Database configuration
    DATABASE_URL: str = os.environ.get("DATABASE_URL", "postgresql+asyncpg://user:password@localhost/emr_db")

    # JWT settings
    SECRET_KEY: str = os.environ.get("SECRET_KEY", "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7")
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60

    class Config:
        case_sensitive = True
        env_file = ".env"

settings = Settings()

```

```python
# /database.py

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from core.config import settings

engine = create_async_engine(settings.DATABASE_URL, echo=False, future=True)
AsyncSessionLocal = sessionmaker(
    engine, 
    class_=AsyncSession, 
    expire_on_commit=False
)

Base = declarative_base()

async def get_db() -> AsyncSession:
    """
    Dependency to get an async database session.
    Ensures the session is closed after the request is finished.
    """
    async with AsyncSessionLocal() as session:
        yield session

```

```python
# /models.py

import uuid
from sqlalchemy import (
    Column, String, DateTime, ForeignKey, Text, Enum,
    Boolean, Table
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
import enum

from database import Base

class UserRole(str, enum.Enum):
    PHYSICIAN = "physician"
    NURSE = "nurse"
    ADMIN = "admin"
    PATIENT = "patient"

class AuditAction(str, enum.Enum):
    CREATE = "CREATE"
    READ = "READ"
    UPDATE = "UPDATE"
    DELETE = "DELETE"
    LOGIN_SUCCESS = "LOGIN_SUCCESS"
    LOGIN_FAIL = "LOGIN_FAIL"
    ACCESS_DENIED = "ACCESS_DENIED"

# Association table for User-Patient care team relationship
care_team_association = Table(
    'care_team_association', Base.metadata,
    Column('user_id', UUID(as_uuid=True), ForeignKey('users.id', ondelete="CASCADE"), primary_key=True),
    Column('patient_id', UUID(as_uuid=True), ForeignKey('patients.id', ondelete="CASCADE"), primary_key=True)
)

class User(Base):
    __tablename__ = "users"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username = Column(String(100), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    full_name = Column(String(100), nullable=False)
    role = Column(Enum(UserRole), nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    notes_authored = relationship("ClinicalNote", back_populates="author")
    patients_in_care = relationship("Patient", secondary=care_team_association, back_populates="care_team")

class Patient(Base):
    __tablename__ = "patients"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    # De-identified patient identifier, e.g., MRN
    medical_record_number = Column(String(50), unique=True, index=True, nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    notes = relationship("ClinicalNote", back_populates="patient", cascade="all, delete-orphan")
    care_team = relationship("User", secondary=care_team_association, back_populates="patients_in_care")

class ClinicalNoteStatus(str, enum.Enum):
    DRAFT = "DRAFT"
    SIGNED = "SIGNED"
    AMENDED = "AMENDED"
    ARCHIVED = "ARCHIVED"

class ClinicalNote(Base):
    __tablename__ = "clinical_notes"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    patient_id = Column(UUID(as_uuid=True), ForeignKey("patients.id"), nullable=False, index=True)
    author_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    content = Column(Text, nullable=False) # Content is encrypted at the application layer before storing if needed
    status = Column(Enum(ClinicalNoteStatus), nullable=False, default=ClinicalNoteStatus.DRAFT)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    patient = relationship("Patient", back_populates="notes")
    author = relationship("User", back_populates="notes_authored")

class AuditLog(Base):
    __tablename__ = "audit_logs"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True) # Nullable for system actions
    action = Column(Enum(AuditAction), nullable=False)
    timestamp = Column(DateTime(timezone=True), server_default=func.now())
    source_ip = Column(String(45)) # Supports IPv6
    resource_type = Column(String(50)) # e.g., "ClinicalNote", "Patient"
    resource_id = Column(UUID(as_uuid=True), nullable=True)
    details = Column(Text, nullable=True)

```

```python
# /schemas.py

import uuid
from pydantic import BaseModel, Field, SecretStr
from typing import Optional, List
from datetime import datetime

from models import UserRole, ClinicalNoteStatus, AuditAction

# Base models
class NoteBase(BaseModel):
    content: str = Field(..., min_length=10)

class NoteCreate(NoteBase):
    patient_id: uuid.UUID

class NoteUpdate(BaseModel):
    content: str = Field(..., min_length=10)
    status: Optional[ClinicalNoteStatus] = None

class UserBase(BaseModel):
    username: str = Field(..., min_length=3)
    full_name: str
    role: UserRole

# Models for API responses
class User(UserBase):
    id: uuid.UUID
    is_active: bool
    
    class Config:
        from_attributes = True

class Note(NoteBase):
    id: uuid.UUID
    patient_id: uuid.UUID
    author_id: uuid.UUID
    status: ClinicalNoteStatus
    created_at: datetime
    updated_at: Optional[datetime] = None
    author: User

    class Config:
        from_attributes = True

# Models for authentication
class UserCreate(UserBase):
    password: str = Field(..., min_length=8)

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

# Models for Auditing
class AuditLogBase(BaseModel):
    action: AuditAction
    source_ip: str
    resource_type: Optional[str] = None
    resource_id: Optional[uuid.UUID] = None
    details: Optional[str] = None

class AuditLogCreate(AuditLogBase):
    user_id: Optional[uuid.UUID] = None

```

```python
# /security.py

from datetime import datetime, timedelta, timezone
from typing import Optional

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext
from sqlalchemy.ext.asyncio import AsyncSession

from core.config import settings
import crud
import models
import schemas
from database import get_db

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{settings.API_V1_STR}/auth/token")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

async def get_current_user(
    db: AsyncSession = Depends(get_db), 
    token: str = Depends(oauth2_scheme)
) -> models.User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = schemas.TokenData(username=username)
    except JWTError:
        raise credentials_exception
    
    user = await crud.get_user_by_username(db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(
    current_user: models.User = Depends(get_current_user)
) -> models.User:
    if not current_user.is_active:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")
    return current_user

```

```python
# /crud.py

import uuid
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload

import models
import schemas
from security import get_password_hash

# User CRUD
async def get_user_by_username(db: AsyncSession, username: str) -> models.User:
    result = await db.execute(select(models.User).filter(models.User.username == username))
    return result.scalars().first()

async def create_user(db: AsyncSession, user: schemas.UserCreate) -> models.User:
    hashed_password = get_password_hash(user.password)
    db_user = models.User(
        username=user.username,
        full_name=user.full_name,
        role=user.role,
        hashed_password=hashed_password
    )
    db.add(db_user)
    await db.commit()
    await db.refresh(db_user)
    return db_user

# Clinical Note CRUD
async def get_note(db: AsyncSession, note_id: uuid.UUID) -> models.ClinicalNote:
    result = await db.execute(
        select(models.ClinicalNote)
        .options(selectinload(models.ClinicalNote.author))
        .filter(models.ClinicalNote.id == note_id)
    )
    return result.scalars().first()

async def get_notes_by_patient(db: AsyncSession, patient_id: uuid.UUID, skip: int = 0, limit: int = 100) -> list[models.ClinicalNote]:
    result = await db.execute(
        select(models.ClinicalNote)
        .options(selectinload(models.ClinicalNote.author))
        .filter(models.ClinicalNote.patient_id == patient_id)
        .filter(models.ClinicalNote.status != models.ClinicalNoteStatus.ARCHIVED)
        .order_by(models.ClinicalNote.created_at.desc())
        .offset(skip)
        .limit(limit)
    )
    return result.scalars().all()

async def create_patient_note(db: AsyncSession, note: schemas.NoteCreate, author_id: uuid.UUID) -> models.ClinicalNote:
    db_note = models.ClinicalNote(
        **note.model_dump(), 
        author_id=author_id, 
        status=models.ClinicalNoteStatus.DRAFT
    )
    db.add(db_note)
    await db.commit()
    await db.refresh(db_note, ["author"])
    return db_note

async def update_note(db: AsyncSession, db_note: models.ClinicalNote, note_update: schemas.NoteUpdate) -> models.ClinicalNote:
    update_data = note_update.model_dump(exclude_unset=True)
    for key, value in update_data.items():
        setattr(db_note, key, value)
    
    await db.commit()
    await db.refresh(db_note, ["author"])
    return db_note

async def archive_note(db: AsyncSession, db_note: models.ClinicalNote) -> models.ClinicalNote:
    db_note.status = models.ClinicalNoteStatus.ARCHIVED
    await db.commit()
    await db.refresh(db_note, ["author"])
    return db_note

# Patient CRUD
async def get_patient(db: AsyncSession, patient_id: uuid.UUID) -> models.Patient:
    result = await db.execute(
        select(models.Patient)
        .options(selectinload(models.Patient.care_team))
        .filter(models.Patient.id == patient_id)
    )
    return result.scalars().first()

# Audit Log CRUD
async def create_audit_log(db: AsyncSession, log_entry: schemas.AuditLogCreate) -> models.AuditLog:
    db_log = models.AuditLog(**log_entry.model_dump())
    db.add(db_log)
    await db.commit()
    # No refresh needed for fire-and-forget logging
    return db_log
```

```python
# /services.py

from fastapi import Request, BackgroundTasks
from sqlalchemy.ext.asyncio import AsyncSession
import uuid

import crud
import models
import schemas

class AuditService:
    """Service for handling HIPAA audit logging."""
    def __init__(self, background_tasks: BackgroundTasks, db: AsyncSession):
        self.background_tasks = background_tasks
        self.db = db

    def log_action(
        self,
        request: Request,
        action: models.AuditAction,
        user: models.User,
        resource_type: str = None,
        resource_id: uuid.UUID = None,
        details: str = None
    ):
        log_entry = schemas.AuditLogCreate(
            user_id=user.id if user else None,
            action=action,
            source_ip=request.client.host,
            resource_type=resource_type,
            resource_id=resource_id,
            details=details,
        )
        self.background_tasks.add_task(crud.create_audit_log, self.db, log_entry)
```

```python
# /api/v1/dependencies.py

from fastapi import Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
import uuid

import crud
import models
from database import get_db

async def check_patient_access(
    patient_id: uuid.UUID,
    db: AsyncSession = Depends(get_db),
    current_user: models.User = Depends(models.get_current_active_user)
) -> models.Patient:
    """
    Dependency that verifies if the current user is authorized to access
    a given patient's data. Authorization is granted if the user is on the
    patient's care team or has an administrative role.
    """
    if current_user.role == models.UserRole.ADMIN:
        patient = await crud.get_patient(db, patient_id=patient_id)
    else:
        # For clinical roles, check if they are on the care team.
        patient = await crud.get_patient(db, patient_id=patient_id)
        if patient and current_user not in patient.care_team:
            # Note: Do not reveal if patient exists or not. Generic error.
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Not authorized to access this patient's records"
            )

    if not patient:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Patient with ID {patient_id} not found"
        )
    return patient
```

```python
# /api/v1/endpoints/auth.py

from fastapi import APIRouter, Depends, HTTPException, status, BackgroundTasks, Request
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession
from datetime import timedelta

import crud
import security
import schemas
import models
from services import AuditService
from core.config import settings
from database import get_db

router = APIRouter()

@router.post("/token", response_model=schemas.Token)
async def login_for_access_token(
    request: Request,
    background_tasks: BackgroundTasks,
    db: AsyncSession = Depends(get_db),
    form_data: OAuth2PasswordRequestForm = Depends()
):
    """
    Authenticate user and return a JWT access token.
    """
    user = await crud.get_user_by_username(db, username=form_data.username)
    audit_service = AuditService(background_tasks, db)

    if not user or not security.verify_password(form_data.password, user.hashed_password):
        if user: # Log failed attempt against a real user
            audit_service.log_action(request, models.AuditAction.LOGIN_FAIL, user, details=f"Failed login attempt for user: {user.username}")
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    if not user.is_active:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")

    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = security.create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    
    audit_service.log_action(request, models.AuditAction.LOGIN_SUCCESS, user, details=f"Successful login for user: {user.username}")

    return {"access_token": access_token, "token_type": "bearer"}

```

```python
# /api/v1/endpoints/notes.py

from fastapi import APIRouter, Depends, HTTPException, status, Request, BackgroundTasks
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List
import uuid

import crud
import models
import schemas
from database import get_db
from security import get_current_active_user
from services import AuditService
from api.v1.dependencies import check_patient_access

router = APIRouter()

@router.post("/", response_model=schemas.Note, status_code=status.HTTP_201_CREATED)
async def create_clinical_note(
    note_in: schemas.NoteCreate,
    request: Request,
    background_tasks: BackgroundTasks,
    db: AsyncSession = Depends(get_db),
    current_user: models.User = Depends(get_current_active_user)
):
    """
    Create a new clinical note for a patient.
    - Requires clinical role (physician or nurse).
    - User must be on the patient's care team.
    """
    if current_user.role not in [models.UserRole.PHYSICIAN, models.UserRole.NURSE]:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="User role cannot create clinical notes.")

    patient = await check_patient_access(patient_id=note_in.patient_id, db=db, current_user=current_user)

    note = await crud.create_patient_note(db=db, note=note_in, author_id=current_user.id)
    
    audit_service = AuditService(background_tasks, db)
    audit_service.log_action(request, models.AuditAction.CREATE, current_user, "ClinicalNote", note.id, f"Created note for patient {patient.id}")

    return note

@router.get("/patient/{patient_id}", response_model=List[schemas.Note])
async def read_patient_notes(
    patient_id: uuid.UUID,
    request: Request,
    background_tasks: BackgroundTasks,
    db: AsyncSession = Depends(get_db),
    current_user: models.User = Depends(get_current_active_user),
    skip: int = 0,
    limit: int = 100
):
    """
    Retrieve all clinical notes for a specific patient.
    - User must be on the patient's care team.
    """
    patient = await check_patient_access(patient_id=patient_id, db=db, current_user=current_user)
    
    notes = await crud.get_notes_by_patient(db, patient_id=patient.id, skip=skip, limit=limit)

    audit_service = AuditService(background_tasks, db)
    audit_service.log_action(request, models.AuditAction.READ, current_user, "Patient", patient.id, f"Accessed notes list for patient {patient.id}")

    return notes


@router.get("/{note_id}", response_model=schemas.Note)
async def read_note(
    note_id: uuid.UUID,
    request: Request,
    background_tasks: BackgroundTasks,
    db: AsyncSession = Depends(get_db),
    current_user: models.User = Depends(get_current_active_user)
):
    """
    Retrieve a single clinical note by its ID.
    - User must be on the patient's care team.
    """
    db_note = await crud.get_note(db, note_id=note_id)
    if not db_note:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Note not found")

    patient = await check_patient_access(patient_id=db_note.patient_id, db=db, current_user=current_user)
    
    audit_service = AuditService(background_tasks, db)
    audit_service.log_action(request, models.AuditAction.READ, current_user, "ClinicalNote", db_note.id, f"Read note for patient {patient.id}")

    return db_note

@router.put("/{note_id}", response_model=schemas.Note)
async def update_clinical_note(
    note_id: uuid.UUID,
    note_update: schemas.NoteUpdate,
    request: Request,
    background_tasks: BackgroundTasks,
    db: AsyncSession = Depends(get_db),
    current_user: models.User = Depends(get_current_active_user)
):
    """
    Update a clinical note.
    - Only the original author can edit a note in DRAFT status.
    - Only a physician can sign a note.
    """
    db_note = await crud.get_note(db, note_id=note_id)
    if not db_note:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Note not found")

    await check_patient_access(patient_id=db_note.patient_id, db=db, current_user=current_user)

    if db_note.status in [models.ClinicalNoteStatus.SIGNED, models.ClinicalNoteStatus.ARCHIVED]:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Cannot edit a signed or archived note.")

    # Check for content update
    if note_update.content != db_note.content:
        if db_note.author_id != current_user.id:
             raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Only the author can edit the note's content.")
    
    # Check for status update (signing)
    if note_update.status and note_update.status != db_note.status:
        if note_update.status == models.ClinicalNoteStatus.SIGNED and current_user.role != models.UserRole.PHYSICIAN:
            raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Only a physician can sign a clinical note.")

    updated_note = await crud.update_note(db=db, db_note=db_note, note_update=note_update)
    
    audit_service = AuditService(background_tasks, db)
    audit_service.log_action(request, models.AuditAction.UPDATE, current_user, "ClinicalNote", updated_note.id, f"Updated note for patient {updated_note.patient_id}")
    
    return updated_note

@router.delete("/{note_id}", status_code=status.HTTP_204_NO_CONTENT)
async def archive_clinical_note(
    note_id: uuid.UUID,
    request: Request,
    background_tasks: BackgroundTasks,
    db: AsyncSession = Depends(get_db),
    current_user: models.User = Depends(get_current_active_user)
):
    """
    Archive a clinical note (soft delete).
    - Requires PHYSICIAN or ADMIN role.
    """
    db_note = await crud.get_note(db, note_id=note_id)
    if not db_note:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Note not found")
    
    await check_patient_access(patient_id=db_note.patient_id, db=db, current_user=current_user)

    if current_user.role not in [models.UserRole.PHYSICIAN, models.UserRole.ADMIN]:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Insufficient privileges to archive a note.")

    if db_note.status == models.ClinicalNoteStatus.ARCHIVED:
        return # Idempotent

    await crud.archive_note(db=db, db_note=db_note)

    audit_service = AuditService(background_tasks, db)
    audit_service.log_action(request, models.AuditAction.DELETE, current_user, "ClinicalNote", db_note.id, f"Archived note for patient {db_note.patient_id}")

```

```python
# /api/v1/api.py

from fastapi import APIRouter
from api.v1.endpoints import notes, auth

api_router = APIRouter()
api_router.include_router(auth.router, prefix="/auth", tags=["auth"])
api_router.include_router(notes.router, prefix="/notes", tags=["notes"])

```

```python
# /main.py

from fastapi import FastAPI
from core.config import settings
from api.v1.api import api_router

app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_STR}/openapi.json"
)

app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/", tags=["Health Check"])
async def root():
    """
    Root endpoint for health checks.
    """
    return {"status": "ok", "project": settings.PROJECT_NAME}

# Example of how to add a startup event to create initial data
# @app.on_event("startup")
# async def startup_event():
#     async with AsyncSessionLocal() as db:
#         # Code to create initial admin user, etc.
#         pass
```