```python
# /emr_backend/config.py
import os
from pydantic_settings import BaseSettings, SettingsConfigDict
from functools import lru_cache

class Settings(BaseSettings):
    """
    Application settings loaded from environment variables.
    """
    # PostgreSQL Database Configuration
    DATABASE_URL: str = "postgresql+asyncpg://user:password@localhost/emr_db"

    # JWT Authentication Configuration
    SECRET_KEY: str = "a_very_secret_key_that_should_be_long_and_random"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30

    # AWS S3 Configuration for Document Storage
    S3_BUCKET_NAME: str = "emr-secure-documents-bucket"
    S3_ACCESS_KEY_ID: str = "YOUR_S3_ACCESS_KEY"
    S3_SECRET_ACCESS_KEY: str = "YOUR_S3_SECRET_KEY"
    S3_REGION: str = "us-east-1"
    S3_ENDPOINT_URL: str | None = None # For local testing with MinIO etc.

    # Fernet Encryption Key for Document Payloads (must be 32 url-safe base64-encoded bytes)
    # Generate one with: `from cryptography.fernet import Fernet; Fernet.generate_key().decode()`
    DOCUMENT_MASTER_ENCRYPTION_KEY: str

    model_config = SettingsConfigDict(env_file=".env", env_file_encoding='utf-8')

@lru_cache()
def get_settings():
    """Returns a cached instance of the settings."""
    return Settings()

# /emr_backend/database.py
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from .config import get_settings

settings = get_settings()

engine = create_async_engine(settings.DATABASE_URL, echo=False, future=True)
AsyncSessionLocal = sessionmaker(
    engine, class_=AsyncSession, expire_on_commit=False
)
Base = declarative_base()

async def get_db() -> AsyncSession:
    """
    Dependency to get an async database session.
    Ensures the session is closed after the request.
    """
    async with AsyncSessionLocal() as session:
        yield session

# /emr_backend/models.py
import enum
from sqlalchemy import (
    Boolean, Column, Integer, String, DateTime, ForeignKey, Enum, Text, Table
)
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from .database import Base

class UserRole(str, enum.Enum):
    PHYSICIAN = "physician"
    NURSE = "nurse"
    ADMIN = "admin"
    PATIENT = "patient"

care_team_association = Table(
    'care_team_association', Base.metadata,
    Column('user_id', Integer, ForeignKey('users.id', ondelete="CASCADE"), primary_key=True),
    Column('patient_id', Integer, ForeignKey('patients.id', ondelete="CASCADE"), primary_key=True)
)

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, nullable=False)
    role = Column(Enum(UserRole), nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    patients = relationship(
        "Patient",
        secondary=care_team_association,
        back_populates="care_team"
    )

class Patient(Base):
    __tablename__ = "patients"
    id = Column(Integer, primary_key=True, index=True)
    full_name = Column(String, nullable=False)
    date_of_birth = Column(DateTime(timezone=True), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    care_team = relationship(
        "User",
        secondary=care_team_association,
        back_populates="patients"
    )
    documents = relationship("DocumentMetadata", back_populates="patient", cascade="all, delete-orphan")

class DocumentMetadata(Base):
    __tablename__ = "document_metadata"
    id = Column(Integer, primary_key=True, index=True)
    patient_id = Column(Integer, ForeignKey("patients.id"), nullable=False, index=True)
    uploader_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    
    filename = Column(String, nullable=False)
    s3_object_key = Column(String, unique=True, nullable=False)
    file_type = Column(String, nullable=False)
    file_size_bytes = Column(Integer, nullable=False)
    sha256_checksum = Column(String(64), nullable=False)
    
    # Store a unique, encrypted Data Encryption Key (DEK) for each file
    encrypted_dek = Column(Text, nullable=False)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    patient = relationship("Patient", back_populates="documents")
    uploader = relationship("User")

class AuditLog(Base):
    __tablename__ = "audit_logs"
    id = Column(Integer, primary_key=True, index=True)
    timestamp = Column(DateTime(timezone=True), server_default=func.now())
    performing_user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    client_ip_address = Column(String)
    
    action = Column(String, nullable=False, index=True) # e.g., 'DOCUMENT_UPLOAD', 'DOCUMENT_VIEW'
    outcome = Column(Enum("SUCCESS", "FAILURE", name="audit_outcome_enum"), nullable=False)
    
    target_patient_id = Column(Integer, ForeignKey("patients.id"), nullable=True)
    target_document_id = Column(Integer, ForeignKey("document_metadata.id"), nullable=True)
    
    details = Column(Text) # Additional context

# /emr_backend/schemas.py
from pydantic import BaseModel, Field
from datetime import datetime
from .models import UserRole

# --- Token Schemas ---
class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: str | None = None
    role: UserRole | None = None

# --- User Schemas ---
class UserBase(BaseModel):
    username: str
    full_name: str
    role: UserRole

class UserCreate(UserBase):
    password: str

class UserInDB(UserBase):
    id: int
    is_active: bool

    class Config:
        from_attributes = True

# --- Document Schemas ---
class DocumentMetadataResponse(BaseModel):
    id: int
    filename: str
    file_type: str
    file_size_bytes: int
    created_at: datetime
    uploader_id: int

    class Config:
        from_attributes = True

# --- Audit Schemas ---
class AuditLogCreate(BaseModel):
    performing_user_id: int
    client_ip_address: str | None
    action: str
    outcome: str # "SUCCESS" or "FAILURE"
    target_patient_id: int | None = None
    target_document_id: int | None = None
    details: str | None = None

# /emr_backend/security.py
from datetime import datetime, timedelta, timezone
from passlib.context import CryptContext
from jose import JWTError, jwt
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.ext.asyncio import AsyncSession
from . import crud, schemas, models
from .config import get_settings
from .database import get_db

settings = get_settings()
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/token")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: timedelta | None = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

async def get_current_active_user(
    token: str = Depends(oauth2_scheme), 
    db: AsyncSession = Depends(get_db)
) -> models.User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = schemas.TokenData(username=username)
    except JWTError:
        raise credentials_exception
    
    user = await crud.get_user_by_username(db, username=token_data.username)
    if user is None:
        raise credentials_exception
    if not user.is_active:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")
    
    return user

# /emr_backend/services.py
import boto3
from botocore.client import Config
from botocore.exceptions import ClientError
from cryptography.fernet import Fernet, InvalidToken
import hashlib
import os
from .config import get_settings

settings = get_settings()

class EncryptionService:
    """Handles symmetric encryption for file content."""
    def __init__(self, master_key: str):
        self.master_key = master_key.encode()
        self.master_fernet = Fernet(self.master_key)

    def generate_dek(self) -> bytes:
        """Generates a new Data Encryption Key (DEK)."""
        return Fernet.generate_key()

    def encrypt_dek(self, dek: bytes) -> str:
        """Encrypts the DEK with the master key."""
        return self.master_fernet.encrypt(dek).decode('utf-8')

    def decrypt_dek(self, encrypted_dek: str) -> bytes:
        """Decrypts the DEK with the master key."""
        return self.master_fernet.decrypt(encrypted_dek.encode('utf-8'))

    def encrypt_data(self, data: bytes, dek: bytes) -> bytes:
        """Encrypts data using the provided DEK."""
        f = Fernet(dek)
        return f.encrypt(data)

    def decrypt_data(self, encrypted_data: bytes, dek: bytes) -> bytes:
        """Decrypts data using the provided DEK."""
        f = Fernet(dek)
        try:
            return f.decrypt(encrypted_data)
        except InvalidToken:
            # This indicates a key mismatch or corrupted data
            raise ValueError("Failed to decrypt data: Invalid token or key.")

class S3Service:
    """Handles interactions with the S3-compatible object store."""
    def __init__(self):
        self.s3_client = boto3.client(
            's3',
            aws_access_key_id=settings.S3_ACCESS_KEY_ID,
            aws_secret_access_key=settings.S3_SECRET_ACCESS_KEY,
            region_name=settings.S3_REGION,
            endpoint_url=settings.S3_ENDPOINT_URL,
            config=Config(signature_version='s3v4')
        )
        self.bucket_name = settings.S3_BUCKET_NAME

    async def upload_file_content(self, file_content: bytes, object_key: str):
        try:
            self.s3_client.put_object(
                Bucket=self.bucket_name,
                Key=object_key,
                Body=file_content
            )
        except ClientError as e:
            # Production-grade logging should be used here
            raise HTTPException(status_code=500, detail=f"S3 upload failed: {e}")

    async def download_file_content(self, object_key: str) -> bytes:
        try:
            response = self.s3_client.get_object(Bucket=self.bucket_name, Key=object_key)
            return response['Body'].read()
        except ClientError as e:
            if e.response['Error']['Code'] == 'NoSuchKey':
                raise HTTPException(status_code=404, detail="Document not found in storage.")
            # Production-grade logging should be used here
            raise HTTPException(status_code=500, detail=f"S3 download failed: {e}")

def get_sha256_checksum(data: bytes) -> str:
    """Computes the SHA256 checksum of byte data."""
    return hashlib.sha256(data).hexdigest()

# Initialize services
encryption_service = EncryptionService(master_key=settings.DOCUMENT_MASTER_ENCRYPTION_KEY)
s3_service = S3Service()

# /emr_backend/crud.py
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from sqlalchemy.orm import selectinload
from . import models, schemas, security

# --- User ---
async def get_user_by_username(db: AsyncSession, username: str) -> models.User | None:
    result = await db.execute(select(models.User).filter(models.User.username == username))
    return result.scalars().first()

# --- Authorization ---
async def is_user_in_patient_care_team(db: AsyncSession, user_id: int, patient_id: int) -> bool:
    stmt = select(models.Patient).options(selectinload(models.Patient.care_team)).filter_by(id=patient_id)
    result = await db.execute(stmt)
    patient = result.scalars().first()
    if not patient:
        return False
    return any(member.id == user_id for member in patient.care_team)

# --- Document ---
async def create_document_metadata(db: AsyncSession, doc_data: dict) -> models.DocumentMetadata:
    db_doc = models.DocumentMetadata(**doc_data)
    db.add(db_doc)
    await db.commit()
    await db.refresh(db_doc)
    return db_doc

async def get_document_metadata(db: AsyncSession, document_id: int) -> models.DocumentMetadata | None:
    result = await db.execute(
        select(models.DocumentMetadata).filter(models.DocumentMetadata.id == document_id)
    )
    return result.scalars().first()

async def get_patient_documents(db: AsyncSession, patient_id: int) -> list[models.DocumentMetadata]:
    result = await db.execute(
        select(models.DocumentMetadata)
        .filter(models.DocumentMetadata.patient_id == patient_id)
        .order_by(models.DocumentMetadata.created_at.desc())
    )
    return result.scalars().all()

# --- Audit Log ---
async def create_audit_log(db: AsyncSession, log_entry: schemas.AuditLogCreate):
    db_log = models.AuditLog(**log_entry.model_dump())
    db.add(db_log)
    await db.commit()
    await db.refresh(db_log)

# /emr_backend/dependencies.py
from fastapi import Depends, HTTPException, status, Request
from sqlalchemy.ext.asyncio import AsyncSession
from . import crud, models, schemas
from .database import get_db
from .security import get_current_active_user

async def get_patient_from_path(patient_id: int, db: AsyncSession = Depends(get_db)) -> models.Patient:
    stmt = select(models.Patient).where(models.Patient.id == patient_id)
    result = await db.execute(stmt)
    patient = result.scalars().first()
    if not patient:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Patient not found")
    return patient

async def authorize_patient_access(
    patient: models.Patient = Depends(get_patient_from_path),
    current_user: models.User = Depends(get_current_active_user),
    db: AsyncSession = Depends(get_db)
) -> models.Patient:
    """
    Ensures the current user is authorized to access the patient's data.
    Allows access if the user is part of the care team or an admin.
    """
    if current_user.role == models.UserRole.ADMIN:
        return patient

    is_authorized = await crud.is_user_in_patient_care_team(db, user_id=current_user.id, patient_id=patient.id)
    if not is_authorized:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User not authorized to access this patient's records"
        )
    return patient

class AuditLogger:
    def __init__(self, action: str):
        self.action = action

    async def __call__(
        self,
        request: Request,
        current_user: models.User = Depends(get_current_active_user),
        db: AsyncSession = Depends(get_db),
    ):
        async def log(
            outcome: str,
            patient_id: int | None = None,
            document_id: int | None = None,
            details: str | None = None
        ):
            log_entry = schemas.AuditLogCreate(
                performing_user_id=current_user.id,
                client_ip_address=request.client.host,
                action=self.action,
                outcome=outcome,
                target_patient_id=patient_id,
                target_document_id=document_id,
                details=details
            )
            await crud.create_audit_log(db, log_entry)
        
        return log

# /emr_backend/api/v1/endpoints/documents.py
from fastapi import APIRouter, Depends, UploadFile, File, HTTPException, status
from fastapi.responses import StreamingResponse
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List
import io
import uuid

from .... import crud, models, schemas, services
from ....database import get_db
from ....dependencies import authorize_patient_access, AuditLogger

router = APIRouter()

MAX_FILE_SIZE = 25 * 1024 * 1024 # 25 MB

@router.post(
    "/{patient_id}/documents",
    response_model=schemas.DocumentMetadataResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Upload a Patient Document",
    description="Uploads a document for a patient, encrypts it, stores it in S3, and records metadata in the database. Requires care team membership or admin role."
)
async def upload_document(
    patient_id: int,
    file: UploadFile = File(...),
    patient: models.Patient = Depends(authorize_patient_access),
    current_user: models.User = Depends(services.security.get_current_active_user),
    db: AsyncSession = Depends(get_db),
    log: callable = Depends(AuditLogger("DOCUMENT_UPLOAD"))
):
    file_content = await file.read()
    if len(file_content) > MAX_FILE_SIZE:
        await log("FAILURE", patient_id=patient_id, details=f"File size {len(file_content)} exceeds limit {MAX_FILE_SIZE}.")
        raise HTTPException(status.HTTP_413_REQUEST_ENTITY_TOO_LARGE, "File size exceeds 25MB limit.")
    
    try:
        # 1. Security: Generate checksum for integrity
        checksum = services.get_sha256_checksum(file_content)

        # 2. Security: Encrypt file content using envelope encryption
        dek = services.encryption_service.generate_dek()
        encrypted_content = services.encryption_service.encrypt_data(file_content, dek)
        encrypted_dek = services.encryption_service.encrypt_dek(dek)
        
        # 3. Storage: Upload encrypted content to S3
        s3_object_key = f"{patient_id}/{uuid.uuid4().hex}"
        await services.s3_service.upload_file_content(encrypted_content, s3_object_key)

        # 4. Database: Create metadata record
        doc_data = {
            "patient_id": patient_id,
            "uploader_id": current_user.id,
            "filename": file.filename,
            "s3_object_key": s3_object_key,
            "file_type": file.content_type,
            "file_size_bytes": len(file_content),
            "sha256_checksum": checksum,
            "encrypted_dek": encrypted_dek
        }
        db_doc = await crud.create_document_metadata(db, doc_data)
        
        await log("SUCCESS", patient_id=patient_id, document_id=db_doc.id)
        return db_doc

    except Exception as e:
        await log("FAILURE", patient_id=patient_id, details=str(e))
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Failed to process and store document.")

@router.get(
    "/{patient_id}/documents",
    response_model=List[schemas.DocumentMetadataResponse],
    summary="List Patient Documents",
    description="Retrieves a list of all document metadata for a given patient. Requires care team membership or admin role."
)
async def list_patient_documents(
    patient_id: int,
    patient: models.Patient = Depends(authorize_patient_access),
    db: AsyncSession = Depends(get_db)
):
    return await crud.get_patient_documents(db, patient_id=patient_id)

@router.get(
    "/{patient_id}/documents/{document_id}",
    response_class=StreamingResponse,
    summary="Download a Patient Document",
    description="Downloads a specific patient document. The file is decrypted server-side and streamed to the client. Requires care team membership or admin role."
)
async def download_document(
    patient_id: int,
    document_id: int,
    patient: models.Patient = Depends(authorize_patient_access),
    db: AsyncSession = Depends(get_db),
    log: callable = Depends(AuditLogger("DOCUMENT_VIEW"))
):
    doc_meta = await crud.get_document_metadata(db, document_id=document_id)
    if not doc_meta or doc_meta.patient_id != patient_id:
        await log("FAILURE", patient_id=patient_id, document_id=document_id, details="Document not found or does not belong to patient.")
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Document not found")
        
    try:
        # 1. Storage: Download encrypted content from S3
        encrypted_content = await services.s3_service.download_file_content(doc_meta.s3_object_key)

        # 2. Security: Decrypt DEK and then file content
        dek = services.encryption_service.decrypt_dek(doc_meta.encrypted_dek)
        decrypted_content = services.encryption_service.decrypt_data(encrypted_content, dek)

        # 3. Security: Verify integrity
        checksum_on_download = services.get_sha256_checksum(decrypted_content)
        if checksum_on_download != doc_meta.sha256_checksum:
            await log("FAILURE", patient_id=patient_id, document_id=document_id, details="Data integrity check failed: checksum mismatch.")
            raise HTTPException(status_code=500, detail="Data integrity error: file may be corrupted.")
        
        await log("SUCCESS", patient_id=patient_id, document_id=document_id)
        return StreamingResponse(
            io.BytesIO(decrypted_content),
            media_type=doc_meta.file_type,
            headers={"Content-Disposition": f"attachment; filename={doc_meta.filename}"}
        )
    except ValueError as e: # From decryption failure
        await log("FAILURE", patient_id=patient_id, document_id=document_id, details=str(e))
        raise HTTPException(status_code=500, detail=str(e))
    except Exception as e:
        await log("FAILURE", patient_id=patient_id, document_id=document_id, details=str(e))
        # Hide specific S3/DB error details from client in production
        raise HTTPException(status_code=500, detail="Failed to retrieve and decrypt document.")

# /emr_backend/api/v1/endpoints/auth.py
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession
from datetime import timedelta

from .... import crud, schemas, security, models
from ....config import get_settings
from ....database import get_db

router = APIRouter()
settings = get_settings()

@router.post("/token", response_model=schemas.Token)
async def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: AsyncSession = Depends(get_db)
):
    user = await crud.get_user_by_username(db, username=form_data.username)
    if not user or not security.verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    if not user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")

    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = security.create_access_token(
        data={"sub": user.username, "role": user.role.value},
        expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/users/me", response_model=schemas.UserInDB)
async def read_users_me(current_user: models.User = Depends(security.get_current_active_user)):
    return current_user

# /emr_backend/api/v1/api.py
from fastapi import APIRouter
from .endpoints import documents, auth

api_router = APIRouter()
api_router.include_router(auth.router, prefix="/auth", tags=["Authentication"])
api_router.include_router(documents.router, prefix="/patients", tags=["Patient Documents"])

# /emr_backend/main.py
from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from .api.v1.api import api_router
from .database import engine, Base
import logging

# Setup logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(
    title="Secure EMR Backend",
    description="HIPAA-compliant backend services for a modern Electronic Medical Record system.",
    version="1.0.0",
    redoc_url=None # Disable ReDoc in production environments
)

@app.on_event("startup")
async def startup_event():
    # This is for demonstration. In production, use Alembic for migrations.
    async with engine.begin() as conn:
        # await conn.run_sync(Base.metadata.drop_all) # Use for clean slate testing
        await conn.run_sync(Base.metadata.create_all)
    logger.info("Database tables created.")

@app.exception_handler(Exception)
async def generic_exception_handler(request: Request, exc: Exception):
    # Generic handler to prevent leaking exception details
    logger.error(f"Unhandled exception for request {request.method} {request.url}: {exc}", exc_info=True)
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={"detail": "An internal server error occurred."},
    )

app.include_router(api_router, prefix="/api/v1")

@app.get("/health", status_code=status.HTTP_200_OK, tags=["Health Check"])
async def health_check():
    """Simple health check endpoint."""
    return {"status": "ok"}
```