```python
# /core/config.py

import os
from pydantic_settings import BaseSettings
from functools import lru_cache

class Settings(BaseSettings):
    """
    Application-wide settings loaded from environment variables.
    """
    # Security
    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60
    
    # Database
    DATABASE_URL: str
    
    # S3 for future use (e.g., attachments)
    S3_BUCKET_NAME: str | None = None
    S3_ACCESS_KEY_ID: str | None = None
    S3_SECRET_ACCESS_KEY: str | None = None
    S3_REGION: str | None = None
    
    class Config:
        env_file = ".env"
        env_file_encoding = 'utf-8'

@lru_cache()
def get_settings():
    return Settings()

# Example .env file for local development (DO NOT COMMIT TO VERSION CONTROL)
# SECRET_KEY=your_super_secret_key_32_bytes_long
# DATABASE_URL=postgresql+asyncpg://user:password@host:port/dbname
# S3_BUCKET_NAME=my-secure-emr-bucket
# S3_ACCESS_KEY_ID=your_aws_access_key
# S3_SECRET_ACCESS_KEY=your_aws_secret_key
# S3_REGION=us-east-1
```

```python
# /db/session.py

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from core.config import get_settings

settings = get_settings()

engine = create_async_engine(settings.DATABASE_URL, pool_pre_ping=True, echo=False)
AsyncSessionLocal = sessionmaker(
    autocommit=False, 
    autoflush=False, 
    bind=engine, 
    class_=AsyncSession
)

async def get_db_session() -> AsyncSession:
    """
    Dependency to get a new database session for each request.
    Ensures the session is always closed, even if errors occur.
    """
    async with AsyncSessionLocal() as session:
        yield session
```

```python
# /db/base_class.py

from sqlalchemy.orm import declarative_base

# Base for all SQLAlchemy ORM models.
Base = declarative_base()
```

```python
# /models/user.py

import uuid
from sqlalchemy import Column, String, Boolean
from sqlalchemy.dialects.postgresql import UUID
from db.base_class import Base

class User(Base):
    __tablename__ = "users"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, index=True, nullable=False)
    # Role-based access control (RBAC)
    role = Column(String, nullable=False, default="clinician") # e.g., 'clinician', 'admin', 'billing'
    is_active = Column(Boolean(), default=True)
```

```python
# /models/patient.py

import uuid
from sqlalchemy import Column, String, Date
from sqlalchemy.dialects.postgresql import UUID
from db.base_class import Base

class Patient(Base):
    __tablename__ = "patients"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    mrn = Column(String, unique=True, index=True, nullable=False) # Medical Record Number
    full_name = Column(String, index=True, nullable=False)
    date_of_birth = Column(Date, nullable=False)
```

```python
# /models/audit_log.py

import uuid
from datetime import datetime, timezone
from sqlalchemy import Column, String, DateTime, ForeignKey, Enum as SAEnum
from sqlalchemy.dialects.postgresql import UUID, INET
from db.base_class import Base
from enum import Enum

class AuditAction(str, Enum):
    CREATE_CLINICAL_NOTE = "CREATE_CLINICAL_NOTE"
    READ_CLINICAL_NOTE = "READ_CLINICAL_NOTE"
    AMEND_CLINICAL_NOTE = "AMEND_CLINICAL_NOTE"
    LOGIN_SUCCESS = "LOGIN_SUCCESS"
    LOGIN_FAILURE = "LOGIN_FAILURE"
    PHI_ACCESS_DENIED = "PHI_ACCESS_DENIED"

class AuditStatus(str, Enum):
    SUCCESS = "SUCCESS"
    FAILURE = "FAILURE"

class AuditLog(Base):
    __tablename__ = "audit_logs"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True)
    timestamp_utc = Column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), nullable=False)
    action = Column(SAEnum(AuditAction, name="audit_action_enum"), nullable=False)
    status = Column(SAEnum(AuditStatus, name="audit_status_enum"), nullable=False)
    client_ip_address = Column(INET, nullable=True)
    target_resource_type = Column(String, nullable=True)
    target_resource_id = Column(String, nullable=True)
    details = Column(String, nullable=True)
```

```python
# /models/clinical_note.py

import uuid
from datetime import datetime, timezone
from enum import Enum
from sqlalchemy import Column, String, DateTime, ForeignKey, Text, Enum as SAEnum
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from db.base_class import Base

class NoteStatus(str, Enum):
    DRAFT = "DRAFT"
    FINAL = "FINAL"
    AMENDED = "AMENDED"

class ClinicalNote(Base):
    __tablename__ = "clinical_notes"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    patient_id = Column(UUID(as_uuid=True), ForeignKey("patients.id"), nullable=False, index=True)
    author_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    
    # NOTE: In a production PostgreSQL environment, this column should be encrypted at rest
    # using pgcrypto or an equivalent transparent data encryption (TDE) mechanism.
    # Storing encrypted data blobs from the app layer is less secure and less performant.
    note_content = Column(Text, nullable=False)
    
    status = Column(SAEnum(NoteStatus, name="note_status_enum"), nullable=False, default=NoteStatus.DRAFT)
    
    created_at = Column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), nullable=False)
    updated_at = Column(DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), onupdate=lambda: datetime.now(timezone.utc), nullable=False)
    
    author = relationship("User")
    patient = relationship("Patient")
```

```python
# /schemas/token.py

from pydantic import BaseModel
from uuid import UUID

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenPayload(BaseModel):
    sub: str  # User ID (subject)
    role: str
    exp: int
```

```python
# /schemas/user.py

from pydantic import BaseModel, EmailStr
from uuid import UUID

class UserBase(BaseModel):
    email: EmailStr
    full_name: str
    role: str

class UserCreate(UserBase):
    password: str

class UserInDB(UserBase):
    id: UUID
    is_active: bool

    class Config:
        from_attributes = True

class User(UserInDB):
    pass
```

```python
# /schemas/audit_log.py

from pydantic import BaseModel
from datetime import datetime
from uuid import UUID
from models.audit_log import AuditAction, AuditStatus

class AuditLogCreate(BaseModel):
    user_id: UUID | None
    action: AuditAction
    status: AuditStatus
    client_ip_address: str | None = None
    target_resource_type: str | None = None
    target_resource_id: str | None = None
    details: str | None = None
```

```python
# /schemas/clinical_note.py

from pydantic import BaseModel, Field
from uuid import UUID
from datetime import datetime
from models.clinical_note import NoteStatus

class ClinicalNoteBase(BaseModel):
    note_content: str = Field(..., min_length=10, description="Content of the clinical note.")

class ClinicalNoteCreate(ClinicalNoteBase):
    patient_id: UUID

class ClinicalNoteUpdate(BaseModel):
    note_content: str = Field(..., min_length=10, description="New content for the addendum.")

class ClinicalNoteResponse(ClinicalNoteBase):
    id: UUID
    patient_id: UUID
    author_id: UUID
    status: NoteStatus
    created_at: datetime
    updated_at: datetime
    
    class Config:
        from_attributes = True
```

```python
# /crud/crud_audit_log.py

from sqlalchemy.ext.asyncio import AsyncSession
from models.audit_log import AuditLog
from schemas.audit_log import AuditLogCreate

async def create_audit_log_entry(
    db: AsyncSession, *, obj_in: AuditLogCreate
) -> AuditLog:
    db_obj = AuditLog(
        user_id=obj_in.user_id,
        action=obj_in.action,
        status=obj_in.status,
        client_ip_address=obj_in.client_ip_address,
        target_resource_type=obj_in.target_resource_type,
        target_resource_id=obj_in.target_resource_id,
        details=obj_in.details,
    )
    db.add(db_obj)
    await db.commit()
    await db.refresh(db_obj)
    return db_obj
```

```python
# /crud/crud_user.py

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from models.user import User
from uuid import UUID

async def get_user_by_id(db: AsyncSession, *, user_id: UUID) -> User | None:
    result = await db.execute(select(User).filter(User.id == user_id))
    return result.scalars().first()
```

```python
# /crud/crud_clinical_note.py

from uuid import UUID
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from models.clinical_note import ClinicalNote, NoteStatus
from schemas.clinical_note import ClinicalNoteCreate

async def create_note(
    db: AsyncSession, *, obj_in: ClinicalNoteCreate, author_id: UUID
) -> ClinicalNote:
    db_obj = ClinicalNote(
        patient_id=obj_in.patient_id,
        note_content=obj_in.note_content,
        author_id=author_id,
        status=NoteStatus.DRAFT
    )
    db.add(db_obj)
    await db.commit()
    await db.refresh(db_obj)
    return db_obj

async def get_note_by_id(db: AsyncSession, *, note_id: UUID) -> ClinicalNote | None:
    result = await db.execute(select(ClinicalNote).filter(ClinicalNote.id == note_id))
    return result.scalars().first()

async def get_notes_for_patient(
    db: AsyncSession, *, patient_id: UUID, skip: int = 0, limit: int = 100
) -> list[ClinicalNote]:
    result = await db.execute(
        select(ClinicalNote)
        .filter(ClinicalNote.patient_id == patient_id)
        .order_by(ClinicalNote.created_at.desc())
        .offset(skip)
        .limit(limit)
    )
    return result.scalars().all()

async def amend_note(
    db: AsyncSession, *, db_obj: ClinicalNote, addendum_content: str
) -> ClinicalNote:
    """
    Amends a finalized note by appending an addendum and updating status.
    This preserves the original content for auditability.
    """
    original_content = db_obj.note_content
    timestamp = db_obj.updated_at.strftime("%Y-%m-%d %H:%M:%S UTC")
    
    db_obj.note_content = (
        f"{original_content}\n\n--- ADDENDUM ({timestamp}) ---\n{addendum_content}"
    )
    db_obj.status = NoteStatus.AMENDED
    await db.commit()
    await db.refresh(db_obj)
    return db_obj
```

```python
# /core/security.py

from datetime import datetime, timedelta, timezone
from fastapi import Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext
from sqlalchemy.ext.asyncio import AsyncSession
from uuid import UUID

from core.config import get_settings
from db.session import get_db_session
from models.user import User
from schemas.token import TokenPayload
import crud.crud_user as crud_user
import crud.crud_audit_log as crud_audit_log
from schemas.audit_log import AuditLogCreate
from models.audit_log import AuditAction, AuditStatus

settings = get_settings()

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="api/v1/login")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict) -> str:
    to_encode = data.copy()
    expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

async def get_current_user(
    token: str = Depends(oauth2_scheme), 
    db: AsyncSession = Depends(get_db_session),
    request: Request = None
) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(
            token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM]
        )
        user_id: str = payload.get("sub")
        if user_id is None:
            raise credentials_exception
        token_data = TokenPayload(**payload)
    except JWTError:
        raise credentials_exception
    
    user = await crud_user.get_user_by_id(db, user_id=UUID(token_data.sub))
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(
    current_user: User = Depends(get_current_user)
) -> User:
    if not current_user.is_active:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Inactive user")
    return current_user

class RoleChecker:
    """
    Dependency to check if the current user has the required role.
    """
    def __init__(self, allowed_roles: list[str]):
        self.allowed_roles = allowed_roles

    async def __call__(self, 
        request: Request,
        db: AsyncSession = Depends(get_db_session),
        current_user: User = Depends(get_current_active_user)
    ):
        if current_user.role not in self.allowed_roles:
            await crud_audit_log.create_audit_log_entry(
                db=db,
                obj_in=AuditLogCreate(
                    user_id=current_user.id,
                    action=AuditAction.PHI_ACCESS_DENIED,
                    status=AuditStatus.FAILURE,
                    client_ip_address=request.client.host,
                    details=f"User lacks required role. Required: {self.allowed_roles}, Has: {current_user.role}"
                )
            )
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="The user does not have adequate permissions."
            )
        return current_user
```

```python
# /api/deps.py

from fastapi import Request, Depends
from sqlalchemy.ext.asyncio import AsyncSession
from uuid import UUID

from db.session import get_db_session
from models.user import User
from models.audit_log import AuditAction, AuditStatus
from schemas.audit_log import AuditLogCreate
from crud.crud_audit_log import create_audit_log_entry

async def audit_log_transaction(
    request: Request,
    db: AsyncSession = Depends(get_db_session),
) -> callable:
    """
    Provides a callable to log an audit event within an endpoint.
    This ensures necessary context like request and db session is available.
    """
    async def log_event(
        user: User,
        action: AuditAction,
        status: AuditStatus,
        target_resource_type: str | None = None,
        target_resource_id: UUID | None = None,
        details: str | None = None,
    ):
        log_entry = AuditLogCreate(
            user_id=user.id,
            action=action,
            status=status,
            client_ip_address=request.client.host,
            target_resource_type=target_resource_type,
            target_resource_id=str(target_resource_id) if target_resource_id else None,
            details=details,
        )
        await create_audit_log_entry(db, obj_in=log_entry)
    
    return log_event
```

```python
# /api/v1/endpoints/clinical_notes.py

from fastapi import APIRouter, Depends, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from uuid import UUID
from typing import List

from api.deps import audit_log_transaction
from core.security import get_current_active_user, RoleChecker
from db.session import get_db_session
from models.user import User
from models.clinical_note import ClinicalNote, NoteStatus
from models.audit_log import AuditAction, AuditStatus as LogStatus
import crud.crud_clinical_note as crud
import schemas.clinical_note as schemas

router = APIRouter()

# Dependency for routes requiring clinician-level access
allow_clinician = RoleChecker(allowed_roles=["clinician", "admin"])

@router.post(
    "",
    response_model=schemas.ClinicalNoteResponse,
    status_code=status.HTTP_201_CREATED,
    dependencies=[Depends(allow_clinician)],
    summary="Create a new clinical note for a patient"
)
async def create_clinical_note(
    *,
    db: AsyncSession = Depends(get_db_session),
    note_in: schemas.ClinicalNoteCreate,
    current_user: User = Depends(get_current_active_user),
    log: callable = Depends(audit_log_transaction)
):
    """
    Create a new clinical note. Only users with 'clinician' or 'admin' roles can perform this action.
    The note is created in a 'DRAFT' state.
    """
    # In a real system, you would also verify that the clinician has a valid relationship with the patient.
    note = await crud.create_note(db=db, obj_in=note_in, author_id=current_user.id)
    await log(
        user=current_user,
        action=AuditAction.CREATE_CLINICAL_NOTE,
        status=LogStatus.SUCCESS,
        target_resource_type="ClinicalNote",
        target_resource_id=note.id,
        details=f"Created DRAFT note for patient {note_in.patient_id}"
    )
    return note


@router.get(
    "/by_patient/{patient_id}",
    response_model=List[schemas.ClinicalNoteResponse],
    summary="Get all clinical notes for a patient"
)
async def read_patient_clinical_notes(
    patient_id: UUID,
    db: AsyncSession = Depends(get_db_session),
    current_user: User = Depends(get_current_active_user),
    log: callable = Depends(audit_log_transaction),
    skip: int = 0,
    limit: int = 100
):
    """
    Retrieve all clinical notes for a specific patient, with pagination.
    """
    # In a real system, verify user's access to this patient's records ("break the glass" logic may apply).
    notes = await crud.get_notes_for_patient(db=db, patient_id=patient_id, skip=skip, limit=limit)
    await log(
        user=current_user,
        action=AuditAction.READ_CLINICAL_NOTE,
        status=LogStatus.SUCCESS,
        target_resource_type="Patient",
        target_resource_id=patient_id,
        details=f"Accessed note list for patient. Returned {len(notes)} notes."
    )
    return notes


@router.get(
    "/{note_id}",
    response_model=schemas.ClinicalNoteResponse,
    summary="Get a specific clinical note by ID"
)
async def read_clinical_note_by_id(
    note_id: UUID,
    db: AsyncSession = Depends(get_db_session),
    current_user: User = Depends(get_current_active_user),
    log: callable = Depends(audit_log_transaction)
):
    """
    Retrieve a single clinical note by its unique ID.
    """
    note = await crud.get_note_by_id(db=db, note_id=note_id)
    if not note:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Clinical note not found")
    
    # Again, verify user access rights to this specific note/patient.
    await log(
        user=current_user,
        action=AuditAction.READ_CLINICAL_NOTE,
        status=LogStatus.SUCCESS,
        target_resource_type="ClinicalNote",
        target_resource_id=note_id,
    )
    return note


@router.put(
    "/{note_id}/amend",
    response_model=schemas.ClinicalNoteResponse,
    dependencies=[Depends(allow_clinician)],
    summary="Amend a finalized clinical note"
)
async def amend_clinical_note(
    note_id: UUID,
    update_in: schemas.ClinicalNoteUpdate,
    db: AsyncSession = Depends(get_db_session),
    current_user: User = Depends(get_current_active_user),
    log: callable = Depends(audit_log_transaction)
):
    """
    Amends a clinical note. This action is restricted to the original author
    and can only be performed on notes in 'FINAL' status. It appends an
    addendum to the note content rather than overwriting it.
    """
    note = await crud.get_note_by_id(db=db, note_id=note_id)
    if not note:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Clinical note not found")
    
    if note.author_id != current_user.id:
        await log(
            user=current_user,
            action=AuditAction.AMEND_CLINICAL_NOTE,
            status=LogStatus.FAILURE,
            target_resource_type="ClinicalNote",
            target_resource_id=note_id,
            details="User is not the original author."
        )
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Only the original author can amend a note.")
    
    if note.status != NoteStatus.FINAL:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail=f"Cannot amend a note with status '{note.status}'. Must be 'FINAL'.")
        
    updated_note = await crud.amend_note(db=db, db_obj=note, addendum_content=update_in.note_content)
    await log(
        user=current_user,
        action=AuditAction.AMEND_CLINICAL_NOTE,
        status=LogStatus.SUCCESS,
        target_resource_type="ClinicalNote",
        target_resource_id=note_id
    )
    return updated_note
```

```python
# /api/v1/api.py

from fastapi import APIRouter
from api.v1.endpoints import clinical_notes

api_router = APIRouter()
api_router.include_router(clinical_notes.router, prefix="/notes", tags=["Clinical Notes"])
# Add other routers here, e.g., for patients, users, authentication
```

```python
# /main.py

from fastapi import FastAPI
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException
from starlette.middleware.cors import CORSMiddleware
from api.v1.api import api_router
from core.errors import http_error_handler, validation_error_handler

app = FastAPI(
    title="Secure EMR API",
    description="Backend services for the Electronic Medical Record system. This system is designed to be HIPAA compliant.",
    version="1.0.0",
)

# Production-grade CORS configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["https://*.my-emr-frontend.com", "https://my-emr-frontend.com"], # Specific, trusted origins
    allow_credentials=True,
    allow_methods=["GET", "POST", "PUT", "DELETE"],
    allow_headers=["Authorization", "Content-Type"],
)

# Exception handlers for uniform error responses
app.add_exception_handler(HTTPException, http_error_handler)
app.add_exception_handler(RequestValidationError, validation_error_handler)

# API router
app.include_router(api_router, prefix="/api/v1")

@app.get("/health", tags=["System"], summary="Perform a Health Check")
def health_check():
    """
    Endpoint for health checks and monitoring.
    Returns a 200 OK status if the application is responsive.
    """
    return {"status": "ok"}
```

```python
# /core/errors.py

from fastapi.encoders import jsonable_encoder
from fastapi.exceptions import RequestValidationError
from starlette.exceptions import HTTPException
from starlette.requests import Request
from starlette.responses import JSONResponse
from starlette.status import HTTP_422_UNPROCESSABLE_ENTITY

async def http_error_handler(
    _: Request, exc: HTTPException
) -> JSONResponse:
    """
    Global handler for FastAPI's HTTPException to ensure consistent error format.
    """
    return JSONResponse(
        status_code=exc.status_code,
        content={"detail": exc.detail},
        headers=exc.headers
    )

async def validation_error_handler(
    _: Request, exc: RequestValidationError
) -> JSONResponse:
    """
    Handler for Pydantic's validation errors to provide more structured error details.
    """
    return JSONResponse(
        status_code=HTTP_422_UNPROCESSABLE_ENTITY,
        content={"detail": "Validation Error", "errors": exc.errors()},
    )
```