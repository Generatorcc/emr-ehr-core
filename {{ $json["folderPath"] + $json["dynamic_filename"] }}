```python
# /core/config.py

import os
from pydantic_settings import BaseSettings
from typing import Set

class Settings(BaseSettings):
    """Application configuration settings."""
    API_V1_STR: str = "/api/v1"

    # Database Configuration
    DATABASE_URL: str = os.environ.get("DATABASE_URL", "postgresql+asyncpg://user:password@localhost/emr_db")
    
    # Security and JWT Settings
    SECRET_KEY: str = os.environ.get("SECRET_KEY", "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7")
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    
    # S3 Storage Configuration
    S3_BUCKET_NAME: str = os.environ.get("S3_BUCKET_NAME", "emr-secure-documents")
    S3_ACCESS_KEY: str = os.environ.get("S3_ACCESS_KEY", "minioadmin")
    S3_SECRET_KEY: str = os.environ.get("S3_SECRET_KEY", "minioadmin")
    S3_ENDPOINT_URL: str | None = os.environ.get("S3_ENDPOINT_URL", "http://localhost:9000")
    S3_PRESIGNED_URL_EXPIRATION: int = 300  # seconds

    # Fernet Encryption Key for file contents
    FILE_ENCRYPTION_KEY: str = os.environ.get("FILE_ENCRYPTION_KEY", "E3A5s5g_gYp5g-qE6Fk_i8G_kM2nOpQrStUvWxYzZaA=")

    # Allowed roles for document access
    DOCUMENT_ACCESS_ROLES: Set[str] = {"clinician", "admin", "nurse"}

    class Config:
        case_sensitive = True

settings = Settings()

# /core/database.py

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from .config import settings

engine = create_async_engine(settings.DATABASE_URL, pool_pre_ping=True)
AsyncSessionLocal = sessionmaker(
    autocommit=False, autoflush=False, bind=engine, class_=AsyncSession
)
Base = declarative_base()

async def get_db() -> AsyncSession:
    """Dependency to get an async database session."""
    async with AsyncSessionLocal() as session:
        yield session

# /models/audit.py

import uuid
from sqlalchemy import Column, String, DateTime, Text, ForeignKey
from sqlalchemy.dialects.postgresql import UUID, INET
from sqlalchemy.sql import func
from core.database import Base

class AuditLog(Base):
    """Represents an entry in the HIPAA audit trail."""
    __tablename__ = "audit_logs"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(String, nullable=False, index=True)
    patient_id = Column(UUID(as_uuid=True), ForeignKey("patients.id"), nullable=True, index=True)
    action = Column(String(255), nullable=False)
    resource_type = Column(String(255), nullable=False)
    resource_id = Column(String, nullable=True)
    status = Column(String(50), nullable=False) # e.g., 'SUCCESS', 'FAILURE'
    ip_address = Column(INET, nullable=True)
    details = Column(Text, nullable=True)
    timestamp = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)

# /models/patient.py

import uuid
from sqlalchemy import Column, String, DateTime
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from core.database import Base

class Patient(Base):
    """Represents a patient record."""
    __tablename__ = "patients"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    mrn = Column(String, unique=True, index=True, nullable=False) # Medical Record Number
    first_name = Column(String, nullable=False)
    last_name = Column(String, nullable=False)
    date_of_birth = Column(DateTime, nullable=False)
    documents = relationship("Document", back_populates="patient", cascade="all, delete-orphan")

# /models/document.py

import uuid
from sqlalchemy import Column, String, DateTime, ForeignKey, Integer
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
from sqlalchemy.orm import relationship
from core.database import Base

class Document(Base):
    """Represents metadata for a stored patient document."""
    __tablename__ = "documents"

    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    patient_id = Column(UUID(as_uuid=True), ForeignKey("patients.id"), nullable=False, index=True)
    uploaded_by_user_id = Column(String, nullable=False)
    
    file_name = Column(String, nullable=False)
    s3_object_key = Column(String, unique=True, nullable=False)
    content_type = Column(String, nullable=False)
    file_size_bytes = Column(Integer, nullable=False)
    
    document_type = Column(String, nullable=False, index=True) # e.g., 'Lab Report', 'Imaging', 'Consent Form'
    description = Column(String, nullable=True)
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    
    patient = relationship("Patient", back_populates="documents")


# /schemas/token_schemas.py

from pydantic import BaseModel
from typing import List

class TokenData(BaseModel):
    """Schema for data encoded within a JWT."""
    username: str
    roles: List[str] = []

# /schemas/document_schemas.py

from pydantic import BaseModel, Field
from uuid import UUID
from datetime import datetime

class DocumentMetadataBase(BaseModel):
    document_type: str = Field(..., description="Type of the document, e.g., 'Lab Report'.")
    description: str | None = Field(None, description="Optional description of the document.")

class DocumentMetadataCreate(DocumentMetadataBase):
    pass

class DocumentMetadataResponse(DocumentMetadataBase):
    id: UUID
    patient_id: UUID
    uploaded_by_user_id: str
    file_name: str
    content_type: str
    file_size_bytes: int
    created_at: datetime

    class Config:
        from_attributes = True

# /services/audit_service.py

from sqlalchemy.ext.asyncio import AsyncSession
from models.audit import AuditLog
from fastapi import Request
from uuid import UUID

class AuditService:
    @staticmethod
    async def log_action(
        db: AsyncSession,
        request: Request,
        user_id: str,
        action: str,
        resource_type: str,
        status: str = "SUCCESS",
        patient_id: UUID | None = None,
        resource_id: str | None = None,
        details: str | None = None,
    ):
        """Creates a new audit log entry."""
        log_entry = AuditLog(
            user_id=user_id,
            action=action,
            resource_type=resource_type,
            resource_id=resource_id,
            patient_id=patient_id,
            status=status,
            ip_address=request.client.host if request.client else None,
            details=details,
        )
        db.add(log_entry)
        await db.commit()

# /services/encryption_service.py

from cryptography.fernet import Fernet, InvalidToken
from core.config import settings
import base64

class EncryptionService:
    """Service for encrypting and decrypting data using Fernet."""
    def __init__(self, key: str):
        try:
            # The key must be 32 url-safe base64-encoded bytes.
            decoded_key = base64.urlsafe_b64decode(key)
            if len(decoded_key) != 32:
                raise ValueError("Invalid Fernet key length.")
            self.fernet = Fernet(key.encode('utf-8'))
        except (ValueError, TypeError) as e:
            raise RuntimeError(f"Invalid FILE_ENCRYPTION_KEY provided: {e}")

    def encrypt(self, data: bytes) -> bytes:
        """Encrypts data."""
        if not isinstance(data, bytes):
            raise TypeError("Data must be bytes to be encrypted.")
        return self.fernet.encrypt(data)

    def decrypt(self, token: bytes) -> bytes:
        """Decrypts data. Raises InvalidToken on failure."""
        if not isinstance(token, bytes):
            raise TypeError("Token must be bytes to be decrypted.")
        try:
            return self.fernet.decrypt(token)
        except InvalidToken as e:
            raise ValueError("Failed to decrypt data. Token is invalid or tampered.") from e

encryption_service = EncryptionService(settings.FILE_ENCRYPTION_KEY)


# /services/s3_service.py

import boto3
from botocore.client import Config
from botocore.exceptions import ClientError
from core.config import settings
import logging

logger = logging.getLogger(__name__)

class S3Service:
    """Service for interacting with an S3-compatible object storage."""
    def __init__(self):
        self.s3_client = boto3.client(
            "s3",
            endpoint_url=settings.S3_ENDPOINT_URL,
            aws_access_key_id=settings.S3_ACCESS_KEY,
            aws_secret_access_key=settings.S3_SECRET_KEY,
            config=Config(signature_version="s3v4"),
            region_name="us-east-1",  # region is often required even for local S3
        )
        self.bucket_name = settings.S3_BUCKET_NAME

    def upload_file_obj(self, file_obj, object_key: str, content_type: str):
        """Uploads a file-like object to S3 with server-side encryption."""
        try:
            self.s3_client.upload_fileobj(
                file_obj,
                self.bucket_name,
                object_key,
                ExtraArgs={
                    "ContentType": content_type,
                    "ServerSideEncryption": "AES256"
                },
            )
        except ClientError as e:
            logger.error(f"Failed to upload {object_key} to S3 bucket {self.bucket_name}: {e}")
            raise

    def generate_presigned_download_url(self, object_key: str) -> str | None:
        """Generates a short-lived presigned URL to download an object."""
        try:
            response = self.s3_client.generate_presigned_url(
                "get_object",
                Params={"Bucket": self.bucket_name, "Key": object_key},
                ExpiresIn=settings.S3_PRESIGNED_URL_EXPIRATION,
            )
            return response
        except ClientError as e:
            logger.error(f"Failed to generate presigned URL for {object_key}: {e}")
            return None

s3_service = S3Service()


# /core/security.py

from datetime import datetime, timedelta
from typing import Annotated
from fastapi import Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from pydantic import ValidationError
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select

from core.config import settings
from schemas.token_schemas import TokenData
from services.audit_service import AuditService
from core.database import get_db

# This would typically be a User model from the database.
# For this example, we'll use a Pydantic model to represent the authenticated user.
class AuthenticatedUser(BaseModel):
    username: str
    roles: list[str]
    is_active: bool = True

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/token")

async def get_current_user(token: Annotated[str, Depends(oauth2_scheme)]) -> AuthenticatedUser:
    """Decodes JWT and returns user data. Raises credentials exception on failure."""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        token_data = TokenData(**payload)
    except (JWTError, ValidationError):
        raise credentials_exception
        
    # In a real system, you would look up the user in the database
    # user = await user_service.get_user_by_username(db, username=token_data.username)
    # For this example, we create a user object directly from token data.
    if token_data.username is None:
        raise credentials_exception
    
    user = AuthenticatedUser(username=token_data.username, roles=token_data.roles)
    return user

async def get_current_active_user(
    current_user: Annotated[AuthenticatedUser, Depends(get_current_user)]
) -> AuthenticatedUser:
    """Checks if the user from the token is active."""
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user

async def authorize_document_access(
    request: Request,
    current_user: Annotated[AuthenticatedUser, Depends(get_current_active_user)],
    db: Annotated[AsyncSession, Depends(get_db)]
) -> AuthenticatedUser:
    """Authorizes user based on roles defined in settings for document access."""
    if not settings.DOCUMENT_ACCESS_ROLES.intersection(current_user.roles):
        await AuditService.log_action(
            db=db,
            request=request,
            user_id=current_user.username,
            action="DOCUMENT_ACCESS_DENIED",
            resource_type="Authorization",
            status="FAILURE",
            details=f"User lacks required roles. Has: {current_user.roles}",
        )
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User does not have permission to access patient documents.",
        )
    return current_user


# /api/v1/endpoints/documents.py

from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Form, Request
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from uuid import UUID
import uuid
import io

from core.database import get_db
from core.security import authorize_document_access, AuthenticatedUser
from models.document import Document
from models.patient import Patient
from schemas.document_schemas import DocumentMetadataResponse, DocumentMetadataCreate
from services.s3_service import s3_service
from services.encryption_service import encryption_service
from services.audit_service import AuditService

router = APIRouter()

MAX_FILE_SIZE = 10 * 1024 * 1024  # 10 MB
ALLOWED_CONTENT_TYPES = ["application/pdf", "image/jpeg", "image/png", "text/plain"]


@router.post(
    "/patients/{patient_id}/documents",
    response_model=DocumentMetadataResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Upload a Patient Document",
    description="Securely uploads a document for a given patient, encrypts it, stores it in S3, and records metadata in the database."
)
async def upload_document(
    request: Request,
    patient_id: UUID,
    metadata: DocumentMetadataCreate = Depends(),
    file: UploadFile = File(...),
    db: AsyncSession = Depends(get_db),
    current_user: AuthenticatedUser = Depends(authorize_document_access)
):
    # Authorization Step 1: Verify patient exists
    patient_result = await db.execute(select(Patient).where(Patient.id == patient_id))
    patient = patient_result.scalar_one_or_none()
    if not patient:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Patient not found.")

    # Authorization Step 2: In a real system, verify user has rights to this specific patient
    # e.g., check_provider_patient_relationship(db, user.id, patient.id)
    
    # Input Validation
    if file.content_type not in ALLOWED_CONTENT_TYPES:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid file type.")
    
    contents = await file.read()
    if len(contents) > MAX_FILE_SIZE:
        raise HTTPException(status_code=status.HTTP_413_REQUEST_ENTITY_TOO_LARGE, detail="File size exceeds limit.")
    await file.close()

    # Security: Encrypt file contents before upload
    try:
        encrypted_contents = encryption_service.encrypt(contents)
    except Exception as e:
        await AuditService.log_action(
            db, request, current_user.username, "UPLOAD_DOCUMENT", "Document", "FAILURE", patient_id, 
            details=f"Encryption failed for file {file.filename}. Error: {e}"
        )
        raise HTTPException(status_code=500, detail="Could not encrypt file.")

    s3_object_key = f"{patient_id}/{uuid.uuid4()}-{file.filename}"

    # Perform S3 Upload
    try:
        s3_service.upload_file_obj(
            file_obj=io.BytesIO(encrypted_contents),
            object_key=s3_object_key,
            content_type="application/octet-stream" # Store as generic bytes after encryption
        )
    except Exception as e:
        await AuditService.log_action(
            db, request, current_user.username, "UPLOAD_DOCUMENT", "Document", "FAILURE", patient_id, 
            details=f"S3 upload failed for {s3_object_key}. Error: {e}"
        )
        raise HTTPException(status_code=status.HTTP_503_SERVICE_UNAVAILABLE, detail="Could not store file.")

    # Database: Create metadata record
    db_document = Document(
        patient_id=patient_id,
        uploaded_by_user_id=current_user.username,
        file_name=file.filename,
        s3_object_key=s3_object_key,
        content_type=file.content_type, # Store original content type for client use
        file_size_bytes=len(contents),
        document_type=metadata.document_type,
        description=metadata.description,
    )
    db.add(db_document)
    await db.commit()
    await db.refresh(db_document)

    # Audit
    await AuditService.log_action(
        db, request, current_user.username, "UPLOAD_DOCUMENT", "Document", "SUCCESS", patient_id, 
        str(db_document.id), f"Uploaded file '{file.filename}' ({len(contents)} bytes)"
    )

    return db_document


@router.get(
    "/patients/{patient_id}/documents",
    response_model=list[DocumentMetadataResponse],
    summary="List Patient Documents",
    description="Retrieves a list of document metadata for a given patient. Does not return file contents."
)
async def list_documents(
    request: Request,
    patient_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: AuthenticatedUser = Depends(authorize_document_access)
):
    # Authorization: Verify patient exists
    patient_result = await db.execute(select(Patient).where(Patient.id == patient_id))
    if not patient_result.scalar_one_or_none():
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Patient not found.")

    # Database query
    result = await db.execute(select(Document).where(Document.patient_id == patient_id).order_by(Document.created_at.desc()))
    documents = result.scalars().all()
    
    # Audit
    await AuditService.log_action(
        db, request, current_user.username, "LIST_DOCUMENTS", "Document", "SUCCESS", patient_id,
        details=f"Retrieved metadata for {len(documents)} documents."
    )

    return documents


@router.get(
    "/patients/{patient_id}/documents/{document_id}/download",
    response_model=dict,
    summary="Get Secure Download URL",
    description="Generates a short-lived, secure, presigned URL for a client to download a document directly from object storage."
)
async def get_document_download_url(
    request: Request,
    patient_id: UUID,
    document_id: UUID,
    db: AsyncSession = Depends(get_db),
    current_user: AuthenticatedUser = Depends(authorize_document_access)
):
    # Database query to get document metadata, ensuring it belongs to the correct patient
    result = await db.execute(select(Document).where(Document.id == document_id, Document.patient_id == patient_id))
    document = result.scalar_one_or_none()
    if not document:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Document not found for this patient.")

    # Generate presigned URL
    url = s3_service.generate_presigned_download_url(document.s3_object_key)
    if not url:
        await AuditService.log_action(
            db, request, current_user.username, "DOWNLOAD_DOCUMENT_URL", "Document", "FAILURE", patient_id, str(document.id),
            details="Failed to generate S3 presigned URL."
        )
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Could not generate download link.")

    # Audit
    await AuditService.log_action(
        db, request, current_user.username, "DOWNLOAD_DOCUMENT_URL", "Document", "SUCCESS", patient_id, str(document.id),
        details=f"Generated download URL for '{document.file_name}'."
    )

    return {"download_url": url, "file_name": document.file_name, "content_type": document.content_type}


# /api/v1/api.py

from fastapi import APIRouter
from .endpoints import documents

api_router = APIRouter()
api_router.include_router(documents.router, prefix="/documents", tags=["Patient Documents"])

# /main.py

from fastapi import FastAPI
from core.config import settings
from api.v1.api import api_router

app = FastAPI(
    title="EMR Secure Backend API",
    openapi_url=f"{settings.API_V1_STR}/openapi.json"
)

app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/health", tags=["System"])
def health_check():
    """Simple health check endpoint."""
    return {"status": "ok"}
```