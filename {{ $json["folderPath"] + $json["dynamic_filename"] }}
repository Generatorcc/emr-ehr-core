```python
# === FILENAME: config.py ===
import os
from pydantic_settings import BaseSettings
from functools import lru_cache

class Settings(BaseSettings):
    """
    Application configuration settings.
    Reads from environment variables.
    """
    # PostgreSQL Database
    DATABASE_URL: str = "postgresql+asyncpg://user:password@localhost/emr_db"

    # JWT Settings
    SECRET_KEY: str = os.environ.get("SECRET_KEY", "a_very_secret_key_that_must_be_changed")
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30

    class Config:
        env_file = ".env"
        env_file_encoding = 'utf-8'

@lru_cache()
def get_settings() -> Settings:
    """Returns a cached instance of the settings."""
    return Settings()

# === FILENAME: database.py ===
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from typing import AsyncGenerator

from config import get_settings

settings = get_settings()

engine = create_async_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
    echo=False, # Set to True for debugging SQL statements
)

AsyncSessionFactory = sessionmaker(
    autocommit=False,
    autoflush=False,
    bind=engine,
    class_=AsyncSession,
    expire_on_commit=False,
)

Base = declarative_base()

async def get_db_session() -> AsyncGenerator[AsyncSession, None]:
    """
    Dependency to get an async database session.
    Ensures the session is properly closed.
    """
    async with AsyncSessionFactory() as session:
        yield session

# === FILENAME: models.py ===
import enum
from sqlalchemy import (
    Column, Integer, String, DateTime, ForeignKey, Enum, Boolean, Text,
    event, DDL
)
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from database import Base

class UserRole(str, enum.Enum):
    PHYSICIAN = "physician"
    NURSE = "nurse"
    ADMIN = "admin"
    SYSTEM = "system"

class AuditAction(str, enum.Enum):
    CREATE = "CREATE"
    READ = "READ"
    UPDATE = "UPDATE"
    DELETE = "DELETE"
    LOGIN_SUCCESS = "LOGIN_SUCCESS"
    LOGIN_FAIL = "LOGIN_FAIL"
    ACCESS_DENIED = "ACCESS_DENIED"

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, index=True)
    role = Column(Enum(UserRole), nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    audit_logs = relationship("AuditLog", back_populates="user")

class Patient(Base):
    __tablename__ = "patients"
    id = Column(Integer, primary_key=True, index=True)
    mrn = Column(String, unique=True, index=True, nullable=False) # Medical Record Number
    full_name = Column(String, index=True, nullable=False)
    date_of_birth = Column(DateTime(timezone=True), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    clinical_notes = relationship("ClinicalNote", back_populates="patient")
    care_team_associations = relationship("PatientCareTeam", back_populates="patient")

class PatientCareTeam(Base):
    __tablename__ = "patient_care_team"
    id = Column(Integer, primary_key=True, index=True)
    patient_id = Column(Integer, ForeignKey("patients.id"), nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)

    patient = relationship("Patient", back_populates="care_team_associations")
    user = relationship("User")


class ClinicalNote(Base):
    __tablename__ = "clinical_notes"
    id = Column(Integer, primary_key=True, index=True)
    patient_id = Column(Integer, ForeignKey("patients.id"), nullable=False)
    author_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    note_type = Column(String, default="Progress Note")
    content = Column(Text, nullable=False) # Encrypted at the application layer before storing
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    is_signed = Column(Boolean, default=False)
    signed_at = Column(DateTime(timezone=True), nullable=True)
    signed_by_id = Column(Integer, ForeignKey("users.id"), nullable=True)

    patient = relationship("Patient", back_populates="clinical_notes")
    author = relationship("User", foreign_keys=[author_id])
    signed_by = relationship("User", foreign_keys=[signed_by_id])

class AuditLog(Base):
    __tablename__ = "audit_logs"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=True) # Nullable for system events
    action = Column(Enum(AuditAction), nullable=False)
    target_resource_type = Column(String, nullable=True)
    target_resource_id = Column(Integer, nullable=True)
    timestamp = Column(DateTime(timezone=True), server_default=func.now())
    status = Column(String, nullable=False) # 'SUCCESS' or 'FAILURE'
    details = Column(Text, nullable=True)
    client_ip_address = Column(String, nullable=True)

    user = relationship("User", back_populates="audit_logs")

# Trigger for pgcrypto extension - ensures data-at-rest encryption for sensitive columns
# Note: Real implementation might use application-level encryption for better key management.
# This is a database-level safeguard.
# event.listen(
#     ClinicalNote.__table__,
#     "after_create",
#     DDL("ALTER TABLE clinical_notes ALTER COLUMN content TYPE pgp_sym_encrypt(content, %(key)s);")
# )

# === FILENAME: schemas.py ===
from pydantic import BaseModel, Field
from datetime import datetime
from typing import Optional, List
from models import UserRole

# --- Token Schemas ---
class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None
    user_id: Optional[int] = None
    role: Optional[UserRole] = None

# --- User Schemas ---
class UserBase(BaseModel):
    username: str
    full_name: str
    role: UserRole

class UserCreate(UserBase):
    password: str

class UserInDB(UserBase):
    id: int
    is_active: bool

    class Config:
        from_attributes = True

class User(UserInDB):
    pass

# --- Patient Schemas ---
class PatientBase(BaseModel):
    mrn: str = Field(..., description="Medical Record Number")
    full_name: str
    date_of_birth: datetime

class Patient(PatientBase):
    id: int
    created_at: datetime

    class Config:
        from_attributes = True

# --- Clinical Note Schemas ---
class ClinicalNoteCreate(BaseModel):
    note_type: str = Field("Progress Note", description="Type of clinical note, e.g., SOAP, Progress Note.")
    content: str = Field(..., min_length=10, description="The textual content of the note.")

class ClinicalNoteRead(BaseModel):
    id: int
    patient_id: int
    author_id: int
    author_full_name: str
    note_type: str
    content: str # In a real system, this might be de-identified or access-controlled
    created_at: datetime
    updated_at: Optional[datetime] = None
    is_signed: bool
    signed_at: Optional[datetime] = None
    signed_by_id: Optional[int] = None

    class Config:
        from_attributes = True

# --- General Response Schema ---
class StatusResponse(BaseModel):
    status: str
    message: str

# === FILENAME: crud.py ===
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, and_
from typing import List, Optional

import models
import schemas
from security import get_password_hash

# --- User CRUD ---
async def get_user_by_username(db: AsyncSession, username: str) -> Optional[models.User]:
    result = await db.execute(select(models.User).filter(models.User.username == username))
    return result.scalars().first()

# --- Patient CRUD ---
async def check_user_patient_access(db: AsyncSession, user_id: int, patient_id: int) -> bool:
    """Check if a user is in the patient's care team."""
    query = select(models.PatientCareTeam).where(
        and_(
            models.PatientCareTeam.user_id == user_id,
            models.PatientCareTeam.patient_id == patient_id
        )
    )
    result = await db.execute(query)
    return result.scalars().first() is not None

# --- Clinical Note CRUD ---
async def create_patient_clinical_note(db: AsyncSession, note: schemas.ClinicalNoteCreate, patient_id: int, author_id: int) -> models.ClinicalNote:
    # In a real system, `note.content` would be encrypted here before saving
    db_note = models.ClinicalNote(
        **note.model_dump(),
        patient_id=patient_id,
        author_id=author_id,
    )
    db.add(db_note)
    await db.commit()
    await db.refresh(db_note)
    return db_note

async def get_clinical_notes_for_patient(db: AsyncSession, patient_id: int, skip: int = 0, limit: int = 100) -> List[models.ClinicalNote]:
    query = (
        select(models.ClinicalNote)
        .join(models.User, models.ClinicalNote.author_id == models.User.id)
        .where(models.ClinicalNote.patient_id == patient_id)
        .order_by(models.ClinicalNote.created_at.desc())
        .offset(skip)
        .limit(limit)
        .options(
            # Eagerly load author to prevent N+1 query problem
            # and access author's full name
            # We must use the relationship name 'author' here
             from_attributes=True,
             # Explicitly load the relationship to access author.full_name
             # This requires proper relationship setup in models.py
        )
    )
    result = await db.execute(query)
    # The result contains ClinicalNote objects; the relationship provides author access
    notes = result.scalars().all()
    # Eager loading means `note.author.full_name` is accessible without new queries
    for note in notes:
        # Manually attach author full name for the Pydantic schema
        if note.author:
            note.author_full_name = note.author.full_name
        else:
            note.author_full_name = "Unknown Author"

    return notes


# --- Audit Log CRUD ---
async def create_audit_log_entry(
    db: AsyncSession,
    *,
    user_id: Optional[int],
    action: models.AuditAction,
    status: str,
    target_resource_type: Optional[str] = None,
    target_resource_id: Optional[int] = None,
    details: Optional[str] = None,
    client_ip: Optional[str] = None
):
    audit_log = models.AuditLog(
        user_id=user_id,
        action=action,
        status=status,
        target_resource_type=target_resource_type,
        target_resource_id=target_resource_id,
        details=details,
        client_ip_address=client_ip
    )
    db.add(audit_log)
    await db.commit()

# === FILENAME: security.py ===
from datetime import datetime, timedelta, timezone
from typing import Optional

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext
from sqlalchemy.ext.asyncio import AsyncSession

from config import get_settings
from database import get_db_session
import crud
import schemas
import models

settings = get_settings()

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/auth/token")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

async def get_current_user(
    db: AsyncSession = Depends(get_db_session), token: str = Depends(oauth2_scheme)
) -> models.User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = schemas.TokenData(username=username)
    except JWTError:
        raise credentials_exception

    user = await crud.get_user_by_username(db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(
    current_user: models.User = Depends(get_current_user)
) -> models.User:
    if not current_user.is_active:
        raise HTTPException(status_code=403, detail="Inactive user")
    return current_user

# === FILENAME: authorization.py ===
from fastapi import Depends, HTTPException, status, Request
from sqlalchemy.ext.asyncio import AsyncSession

import models
import crud
from database import get_db_session
from security import get_current_active_user

class PatientAccessChecker:
    """
    Dependency to verify user access to a patient's record.
    Enforces HIPAA's Minimum Necessary Principle.
    """
    async def __call__(
        self,
        patient_id: int,
        request: Request,
        db: AsyncSession = Depends(get_db_session),
        current_user: models.User = Depends(get_current_active_user)
    ):
        is_authorized = False

        # System administrators have broad access for administrative purposes.
        if current_user.role == models.UserRole.ADMIN:
            is_authorized = True
        else:
            # Clinical staff must be part of the patient's care team.
            is_authorized = await crud.check_user_patient_access(
                db=db, user_id=current_user.id, patient_id=patient_id
            )

        if not is_authorized:
            # Log the unauthorized access attempt
            await crud.create_audit_log_entry(
                db=db,
                user_id=current_user.id,
                action=models.AuditAction.ACCESS_DENIED,
                status="FAILURE",
                target_resource_type="Patient",
                target_resource_id=patient_id,
                details=f"User {current_user.username} denied access to patient ID {patient_id}.",
                client_ip=request.client.host if request.client else "N/A"
            )
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="User does not have permission to access this patient's records."
            )

verify_patient_access = PatientAccessChecker()


# === FILENAME: routers/authentication.py ===
from datetime import timedelta
from fastapi import APIRouter, Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession

import crud
import schemas
import models
from database import get_db_session
from security import create_access_token, verify_password, get_current_active_user
from config import get_settings

router = APIRouter(prefix="/auth", tags=["Authentication"])

@router.post("/token", response_model=schemas.Token)
async def login_for_access_token(
    request: Request,
    db: AsyncSession = Depends(get_db_session),
    form_data: OAuth2PasswordRequestForm = Depends()
):
    """
    Standard OAuth2 password flow.
    Provides a JWT for subsequent authenticated requests.
    """
    user = await crud.get_user_by_username(db, username=form_data.username)
    client_ip = request.client.host if request.client else "N/A"
    
    if not user or not verify_password(form_data.password, user.hashed_password):
        # Log failed login attempt
        user_id = user.id if user else None
        await crud.create_audit_log_entry(
            db=db,
            user_id=user_id,
            action=models.AuditAction.LOGIN_FAIL,
            status="FAILURE",
            details=f"Failed login attempt for username: {form_data.username}",
            client_ip=client_ip
        )
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    if not user.is_active:
        raise HTTPException(status_code=403, detail="User account is inactive.")

    # Log successful login
    await crud.create_audit_log_entry(
        db=db,
        user_id=user.id,
        action=models.AuditAction.LOGIN_SUCCESS,
        status="SUCCESS",
        details=f"User {user.username} logged in successfully.",
        client_ip=client_ip
    )
    
    access_token_expires = timedelta(minutes=get_settings().ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = create_access_token(
        data={"sub": user.username, "user_id": user.id, "role": user.role.value},
        expires_delta=access_token_expires,
    )
    return {"access_token": access_token, "token_type": "bearer"}


@router.get("/users/me", response_model=schemas.User)
async def read_users_me(current_user: models.User = Depends(get_current_active_user)):
    """
    Get information about the currently authenticated user.
    """
    return current_user

# === FILENAME: routers/clinical_notes.py ===
from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List

import crud
import schemas
import models
from database import get_db_session
from security import get_current_active_user
from authorization import verify_patient_access

router = APIRouter(prefix="/patients/{patient_id}/notes", tags=["Clinical Notes"])

@router.post(
    "/",
    response_model=schemas.ClinicalNoteRead,
    status_code=status.HTTP_201_CREATED,
    dependencies=[Depends(verify_patient_access)]
)
async def create_clinical_note_for_patient(
    patient_id: int,
    note: schemas.ClinicalNoteCreate,
    request: Request,
    db: AsyncSession = Depends(get_db_session),
    current_user: models.User = Depends(get_current_active_user),
):
    """
    Create a new clinical note for a specific patient.
    - Requires authentication.
    - Requires authorization to access the patient's record.
    - All actions are audit logged.
    """
    client_ip = request.client.host if request.client else "N/A"
    try:
        created_note = await crud.create_patient_clinical_note(
            db=db, note=note, patient_id=patient_id, author_id=current_user.id
        )
        await crud.create_audit_log_entry(
            db=db,
            user_id=current_user.id,
            action=models.AuditAction.CREATE,
            status="SUCCESS",
            target_resource_type="ClinicalNote",
            target_resource_id=created_note.id,
            details=f"User created note for patient {patient_id}",
            client_ip=client_ip
        )
        
        # Manually set author_full_name for the response model
        created_note.author_full_name = current_user.full_name
        return created_note
    except Exception as e:
        await crud.create_audit_log_entry(
            db=db,
            user_id=current_user.id,
            action=models.AuditAction.CREATE,
            status="FAILURE",
            target_resource_type="ClinicalNote",
            target_resource_id=patient_id,
            details=f"Failed to create note for patient {patient_id}. Error: {str(e)}",
            client_ip=client_ip
        )
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Could not create clinical note."
        )

@router.get(
    "/",
    response_model=List[schemas.ClinicalNoteRead],
    dependencies=[Depends(verify_patient_access)]
)
async def read_clinical_notes(
    patient_id: int,
    request: Request,
    db: AsyncSession = Depends(get_db_session),
    current_user: models.User = Depends(get_current_active_user),
    skip: int = 0,
    limit: int = 100,
):
    """
    Retrieve all clinical notes for a specific patient.
    - Requires authentication.
    - Requires authorization to access the patient's record.
    - All access is audit logged.
    """
    client_ip = request.client.host if request.client else "N/A"
    try:
        notes = await crud.get_clinical_notes_for_patient(db, patient_id=patient_id, skip=skip, limit=limit)
        await crud.create_audit_log_entry(
            db=db,
            user_id=current_user.id,
            action=models.AuditAction.READ,
            status="SUCCESS",
            target_resource_type="ClinicalNote",
            target_resource_id=patient_id, # Target is the collection for the patient
            details=f"User viewed notes for patient {patient_id}. Returned {len(notes)} notes.",
            client_ip=client_ip
        )
        return notes
    except Exception as e:
        await crud.create_audit_log_entry(
            db=db,
            user_id=current_user.id,
            action=models.AuditAction.READ,
            status="FAILURE",
            target_resource_type="ClinicalNote",
            target_resource_id=patient_id,
            details=f"Failed to read notes for patient {patient_id}. Error: {str(e)}",
            client_ip=client_ip
        )
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Could not retrieve clinical notes."
        )

# === FILENAME: main.py ===
from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from sqlalchemy.ext.asyncio import AsyncSession
from database import get_db_session
from routers import clinical_notes, authentication
import crud
import models

app = FastAPI(
    title="Secure EMR API",
    description="A HIPAA-compliant backend for a modern Electronic Medical Record system.",
    version="1.0.0",
)

app.include_router(authentication.router)
app.include_router(clinical_notes.router)

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """
    Custom exception handler to log validation errors, which can be a security signal.
    """
    # Attempt to get a DB session to log the error.
    # This is a bit complex as we are outside the normal dependency injection flow.
    # A middleware approach might be cleaner for production.
    try:
        async for session in get_db_session():
            await crud.create_audit_log_entry(
                db=session,
                user_id=None, # User is not authenticated at this stage
                action=models.AuditAction.ACCESS_DENIED,
                status="FAILURE",
                details=f"Request validation failed: {str(exc.errors())}",
                client_ip=request.client.host if request.client else "N/A"
            )
    except Exception:
        # If logging fails, we still must return the error response.
        pass
    
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={"detail": exc.errors()},
    )


@app.get("/", tags=["Health Check"])
async def root():
    """
    Root endpoint for basic health checks and service discovery.
    """
    return {"status": "ok", "service": "EMR Backend API"}
```