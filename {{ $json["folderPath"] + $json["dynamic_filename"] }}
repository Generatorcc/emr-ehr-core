```python
# /core/config.py
import os
from pydantic_settings import BaseSettings
from functools import lru_cache

class Settings(BaseSettings):
    """
    Application settings loaded from environment variables.
    """
    # Application
    PROJECT_NAME: str = "EMR_Backend_System"
    API_V1_STR: str = "/api/v1"

    # Security
    # Generate with: openssl rand -hex 32
    SECRET_KEY: str = os.environ.get("SECRET_KEY", "09d25e094faa6ca2556c818166b7a9563b93f7099f6f0f4caa6cf63b88e8d3e7")
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60
    
    # Database
    # Format: postgresql+asyncpg://user:password@host:port/dbname
    DATABASE_URL: str = os.environ.get("DATABASE_URL", "postgresql+asyncpg://emr_user:secure_password@localhost:5432/emr_db")

    class Config:
        case_sensitive = True
        env_file = ".env"

@lru_cache()
def get_settings():
    return Settings()

settings = get_settings()

# /db/session.py
from typing import AsyncGenerator
from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from core.config import settings

engine = create_async_engine(settings.DATABASE_URL, pool_pre_ping=True, echo=False)
AsyncSessionLocal = sessionmaker(
    autocommit=False, 
    autoflush=False, 
    bind=engine, 
    class_=AsyncSession,
    expire_on_commit=False
)

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """
    Dependency to get a database session.
    """
    async with AsyncSessionLocal() as session:
        yield session

# /db/base_class.py
from typing import Any
from sqlalchemy.ext.declarative import as_declarative, declared_attr

@as_declarative()
class Base:
    """
    Base class for SQLAlchemy models.
    """
    id: Any
    __name__: str

    # Generate __tablename__ automatically
    @declared_attr
    def __tablename__(cls) -> str:
        return cls.__name__.lower()

# /db/models/user.py
import uuid
from sqlalchemy import Column, String, Boolean
from sqlalchemy.dialects.postgresql import UUID
from db.base_class import Base

class User(Base):
    """
    Database model for a User (system operator).
    """
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username = Column(String(255), unique=True, index=True, nullable=False)
    email = Column(String(255), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    full_name = Column(String(255), index=True)
    role = Column(String(50), nullable=False) # e.g., 'physician', 'nurse', 'admin'
    is_active = Column(Boolean(), default=True)

# /db/models/patient.py
import uuid
from sqlalchemy import Column, String, Date
from sqlalchemy.dialects.postgresql import UUID
from db.base_class import Base
# Note: In a production PostgreSQL environment with pgcrypto extension enabled,
# you would use sqlalchemy-utils EncryptedType for PHI fields.
# from sqlalchemy_utils import EncryptedType
# from core.config import settings
# secret_key = settings.SECRET_KEY

class Patient(Base):
    """
    Database model for a Patient.
    PHI fields should be encrypted at rest in the database.
    """
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    mrn = Column(String(255), unique=True, index=True, nullable=False) # Medical Record Number
    
    # Example of encrypted fields. The database handles encryption via pgcrypto.
    # first_name = Column(EncryptedType(String, secret_key))
    # last_name = Column(EncryptedType(String, secret_key))
    # date_of_birth = Column(EncryptedType(Date, secret_key))
    first_name = Column(String(255), nullable=False)
    last_name = Column(String(255), nullable=False)
    date_of_birth = Column(Date, nullable=False)

# /db/models/audit_log.py
import uuid
from sqlalchemy import Column, String, DateTime, ForeignKey
from sqlalchemy.dialects.postgresql import UUID, INET, JSONB
from sqlalchemy.sql import func
from db.base_class import Base

class AuditLog(Base):
    """
    Database model for HIPAA audit trails.
    """
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    timestamp = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    performing_user_id = Column(UUID(as_uuid=True), ForeignKey("user.id"), nullable=False, index=True)
    client_ip_address = Column(INET)
    action = Column(String(100), nullable=False) # e.g., 'PATIENT_RECORD_VIEW'
    resource_type = Column(String(100)) # e.g., 'Patient'
    resource_id = Column(String(255)) # e.g., Patient MRN or UUID
    outcome = Column(String(50), nullable=False) # 'success', 'failure'
    details = Column(JSONB) # Additional context

# /schemas/token.py
from pydantic import BaseModel
from typing import Optional
import uuid

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None
    user_id: Optional[uuid.UUID] = None

# /schemas/user.py
from pydantic import BaseModel, EmailStr
import uuid
from typing import Optional

class UserBase(BaseModel):
    username: str
    email: EmailStr
    full_name: Optional[str] = None
    role: str

class UserCreate(UserBase):
    password: str

class UserUpdate(UserBase):
    pass

class UserInDBBase(UserBase):
    id: uuid.UUID
    is_active: bool

    class Config:
        from_attributes = True

class User(UserInDBBase):
    pass

# /schemas/patient.py
from pydantic import BaseModel
from datetime import date
import uuid

class PatientBase(BaseModel):
    first_name: str
    last_name: str
    date_of_birth: date

class PatientCreate(PatientBase):
    mrn: str

class PatientUpdate(PatientBase):
    pass

class PatientInDBBase(PatientBase):
    id: uuid.UUID
    mrn: str

    class Config:
        from_attributes = True

class Patient(PatientInDBBase):
    """
    Schema for returning patient data. This is the single source of truth
    for what patient data is exposed via the API.
    """
    pass

# /crud/base.py
from typing import Any, Dict, Generic, List, Optional, Type, TypeVar, Union
from pydantic import BaseModel
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from db.base_class import Base

ModelType = TypeVar("ModelType", bound=Base)
CreateSchemaType = TypeVar("CreateSchemaType", bound=BaseModel)
UpdateSchemaType = TypeVar("UpdateSchemaType", bound=BaseModel)

class CRUDBase(Generic[ModelType, CreateSchemaType, UpdateSchemaType]):
    def __init__(self, model: Type[ModelType]):
        self.model = model

    async def get(self, db: AsyncSession, id: Any) -> Optional[ModelType]:
        result = await db.execute(select(self.model).filter(self.model.id == id))
        return result.scalars().first()

    async def get_multi(
        self, db: AsyncSession, *, skip: int = 0, limit: int = 100
    ) -> List[ModelType]:
        result = await db.execute(select(self.model).offset(skip).limit(limit))
        return result.scalars().all()

    async def create(self, db: AsyncSession, *, obj_in: CreateSchemaType) -> ModelType:
        obj_in_data = obj_in.model_dump()
        db_obj = self.model(**obj_in_data)
        db.add(db_obj)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

    async def update(
        self, db: AsyncSession, *, db_obj: ModelType, obj_in: Union[UpdateSchemaType, Dict[str, Any]]
    ) -> ModelType:
        obj_data = db_obj.model_dump()
        if isinstance(obj_in, dict):
            update_data = obj_in
        else:
            update_data = obj_in.model_dump(exclude_unset=True)
        for field in obj_data:
            if field in update_data:
                setattr(db_obj, field, update_data[field])
        db.add(db_obj)
        await db.commit()
        await db.refresh(db_obj)
        return db_obj

    async def remove(self, db: AsyncSession, *, id: Any) -> ModelType:
        obj = await self.get(db, id)
        await db.delete(obj)
        await db.commit()
        return obj

# /crud/crud_user.py
from typing import Optional
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from crud.base import CRUDBase
from db.models.user import User
from schemas.user import UserCreate, UserUpdate

class CRUDUser(CRUDBase[User, UserCreate, UserUpdate]):
    async def get_by_username(self, db: AsyncSession, *, username: str) -> Optional[User]:
        result = await db.execute(select(User).filter(User.username == username))
        return result.scalars().first()

user = CRUDUser(User)

# /crud/crud_patient.py
from crud.base import CRUDBase
from db.models.patient import Patient
from schemas.patient import PatientCreate, PatientUpdate

class CRUDPatient(CRUDBase[Patient, PatientCreate, PatientUpdate]):
    pass

patient = CRUDPatient(Patient)

# /crud/crud_audit_log.py
from sqlalchemy.ext.asyncio import AsyncSession
from db.models.audit_log import AuditLog

async def create_audit_log(
    db: AsyncSession,
    *,
    log_data: dict,
) -> AuditLog:
    """
    Creates an audit log entry in the database.
    """
    db_obj = AuditLog(**log_data)
    db.add(db_obj)
    await db.commit()
    await db.refresh(db_obj)
    return db_obj

# /services/audit_logger.py
from fastapi import Request
from sqlalchemy.ext.asyncio import AsyncSession
from crud.crud_audit_log import create_audit_log
from schemas.user import User

class AuditLogger:
    def __init__(self, request: Request, db: AsyncSession):
        self.request = request
        self.db = db

    async def log(
        self,
        *,
        actor: User,
        action: str,
        outcome: str,
        resource_type: str = None,
        resource_id: str = None,
        details: dict = None,
    ):
        """
        Asynchronously logs an audit event.
        """
        log_data = {
            "performing_user_id": actor.id,
            "client_ip_address": self.request.client.host if self.request.client else "unknown",
            "action": action,
            "outcome": outcome,
            "resource_type": resource_type,
            "resource_id": str(resource_id) if resource_id else None,
            "details": details or {},
        }
        await create_audit_log(db=self.db, log_data=log_data)

# /core/security.py
from datetime import datetime, timedelta
from typing import Optional
from passlib.context import CryptContext
from jose import JWTError, jwt
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.ext.asyncio import AsyncSession
from pydantic import ValidationError

from core.config import settings
from db.session import get_db
from crud import crud_user
from schemas import token as token_schema
from schemas import user as user_schema
from db.models import user as user_model

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{settings.API_V1_STR}/login/access-token")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    # Ensure all data is serializable
    to_encode["user_id"] = str(to_encode["user_id"])
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

async def get_current_user(
    db: AsyncSession = Depends(get_db), token: str = Depends(oauth2_scheme)
) -> user_model.User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        token_data = token_schema.TokenData(**payload)
        if token_data.username is None:
            raise credentials_exception
    except (JWTError, ValidationError):
        raise credentials_exception
    
    user = await crud_user.user.get_by_username(db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(
    current_user: user_model.User = Depends(get_current_user),
) -> user_model.User:
    if not current_user.is_active:
        raise HTTPException(status_code=403, detail="Inactive user")
    return current_user

# /services/authorization.py
from fastapi import HTTPException, status
from db.models.user import User as UserModel
from db.models.patient import Patient as PatientModel
from sqlalchemy.ext.asyncio import AsyncSession

async def check_user_access_to_patient(
    db: AsyncSession, *, user: UserModel, patient: PatientModel
) -> None:
    """
    Verifies if a user has the right to access a given patient's record.
    This enforces the 'Minimum Necessary' HIPAA principle.
    - 'admin' roles can access any patient record.
    - 'physician' and 'nurse' roles can access any patient record in this example.
    A production system would have a more granular check, e.g., via a
    patient-provider relationship table.
    """
    if user.role == "admin":
        return

    if user.role in ["physician", "nurse"]:
        # In a real system, you would check a UserPatientLink table.
        # For this example, we grant broad access to clinical roles.
        # Example check:
        # link = await db.execute(
        #     select(UserPatientLink).where(
        #         UserPatientLink.user_id == user.id,
        #         UserPatientLink.patient_id == patient.id
        #     )
        # )
        # if not link.first():
        #     raise HTTPException(
        #         status_code=status.HTTP_403_FORBIDDEN,
        #         detail="User does not have a clinical relationship with this patient.",
        #     )
        return

    # Default deny
    raise HTTPException(
        status_code=status.HTTP_403_FORBIDDEN,
        detail="User role does not permit access to patient records.",
    )

# /api/v1/endpoints/login.py
from datetime import timedelta
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession

from core import security
from core.config import settings
from crud import crud_user
from db import session
from schemas import token as token_schema

router = APIRouter()

@router.post("/login/access-token", response_model=token_schema.Token)
async def login_access_token(
    db: AsyncSession = Depends(session.get_db),
    form_data: OAuth2PasswordRequestForm = Depends(),
):
    """
    OAuth2 compatible token login, get an access token for future requests.
    """
    user = await crud_user.user.get_by_username(db, username=form_data.username)
    if not user or not security.verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    if not user.is_active:
        raise HTTPException(status_code=403, detail="Inactive user")
    
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = security.create_access_token(
        data={"sub": user.username, "username": user.username, "user_id": user.id},
        expires_delta=access_token_expires,
    )
    return {"access_token": access_token, "token_type": "bearer"}

# /api/v1/endpoints/patients.py
import uuid
from fastapi import APIRouter, Depends, HTTPException, Request, status
from sqlalchemy.ext.asyncio import AsyncSession

from core.security import get_current_active_user
from crud import crud_patient
from db import session
from db.models.user import User as UserModel
from schemas.patient import Patient as PatientSchema
from services.audit_logger import AuditLogger
from services.authorization import check_user_access_to_patient

router = APIRouter()

@router.get("/{patient_id}", response_model=PatientSchema, status_code=status.HTTP_200_OK)
async def read_patient_by_id(
    request: Request,
    patient_id: uuid.UUID,
    db: AsyncSession = Depends(session.get_db),
    current_user: UserModel = Depends(get_current_active_user),
):
    """
    Retrieve a single patient's record by their UUID.
    - Requires authentication.
    - Verifies user authorization to access the specific patient record.
    - Creates a HIPAA-compliant audit log entry for the access event.
    """
    audit_logger = AuditLogger(request=request, db=db)
    
    patient = await crud_patient.patient.get(db=db, id=patient_id)
    if not patient:
        await audit_logger.log(
            actor=current_user,
            action="PATIENT_RECORD_VIEW",
            outcome="failure",
            resource_type="Patient",
            resource_id=str(patient_id),
            details={"reason": "Patient not found"},
        )
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Patient not found")
    
    try:
        await check_user_access_to_patient(db=db, user=current_user, patient=patient)
    except HTTPException as auth_exc:
        await audit_logger.log(
            actor=current_user,
            action="PATIENT_RECORD_VIEW",
            outcome="failure",
            resource_type="Patient",
            resource_id=str(patient_id),
            details={"reason": f"Authorization failed: {auth_exc.detail}"},
        )
        raise auth_exc

    await audit_logger.log(
        actor=current_user,
        action="PATIENT_RECORD_VIEW",
        outcome="success",
        resource_type="Patient",
        resource_id=str(patient_id),
    )
    
    return patient

# /api/v1/api.py
from fastapi import APIRouter
from api.v1.endpoints import login, patients

api_router = APIRouter()
api_router.include_router(login.router, tags=["login"])
api_router.include_router(patients.router, prefix="/patients", tags=["patients"])

# /main.py
from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from starlette.middleware.cors import CORSMiddleware
from core.config import settings
from api.v1.api import api_router

app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_STR}/openapi.json",
    version="1.0.0"
)

# Set all CORS enabled origins
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], # In production, restrict to known frontend domains
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.middleware("http")
async def add_security_headers(request: Request, call_next):
    """
    Add security headers to all responses to enhance security.
    """
    response = await call_next(request)
    response.headers["Strict-Transport-Security"] = "max-age=31536000; includeSubDomains"
    response.headers["X-Content-Type-Options"] = "nosniff"
    response.headers["X-Frame-Options"] = "DENY"
    response.headers["X-XSS-Protection"] = "1; mode=block"
    # Content Security Policy should be tailored to the specific application needs
    response.headers["Content-Security-Policy"] = "default-src 'self'; script-src 'self'; style-src 'self'; object-src 'none'; frame-ancestors 'none';"
    return response

@app.exception_handler(Exception)
async def generic_exception_handler(request: Request, exc: Exception):
    """
    Generic exception handler to prevent stack traces from being returned.
    """
    # In a production system, this would log the full exception details.
    return JSONResponse(
        status_code=500,
        content={"detail": "An internal server error occurred."},
    )

app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/", include_in_schema=False)
async def root():
    return {"status": "EMR Service is operational."}
```