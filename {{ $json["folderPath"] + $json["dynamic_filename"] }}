```python
# /core/config.py

import os
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    """
    Manages application configuration using environment variables.
    """
    # Application settings
    API_V1_STR: str = "/api/v1"
    PROJECT_NAME: str = "EMR Backend System"

    # Database configuration (PostgreSQL)
    # Example: postgresql+asyncpg://user:password@host:port/dbname
    DATABASE_URL: str = os.getenv("DATABASE_URL", "postgresql+asyncpg://emr_user:secure_password@localhost/emr_db")

    # JWT Security settings
    JWT_SECRET_KEY: str = os.getenv("JWT_SECRET_KEY", "a_very_secure_secret_key_for_production")
    JWT_ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60

    # AWS S3 Configuration for encrypted document storage
    S3_BUCKET_NAME: str = os.getenv("S3_BUCKET_NAME", "emr-secure-document-storage")
    AWS_ACCESS_KEY_ID: str = os.getenv("AWS_ACCESS_KEY_ID", "")
    AWS_SECRET_ACCESS_KEY: str = os.getenv("AWS_SECRET_ACCESS_KEY", "")
    AWS_REGION: str = os.getenv("AWS_REGION", "us-east-1")
    S3_PRESIGNED_URL_EXPIRATION_SECONDS: int = 300 # 5 minutes

    class Config:
        case_sensitive = True

settings = Settings()
```

```python
# /core/db.py

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from typing import AsyncGenerator

from core.config import settings

# Create an asynchronous engine instance
engine = create_async_engine(settings.DATABASE_URL, pool_pre_ping=True)

# Create a sessionmaker for creating async sessions
AsyncSessionLocal = sessionmaker(
    autocommit=False, 
    autoflush=False, 
    bind=engine, 
    class_=AsyncSession,
    expire_on_commit=False
)

Base = declarative_base()

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """
    FastAPI dependency to provide a database session per request.
    Ensures the session is always closed after the request.
    """
    async with AsyncSessionLocal() as session:
        try:
            yield session
        finally:
            await session.close()
```

```python
# /models/user.py

from sqlalchemy import Column, Integer, String, Boolean, Enum
from core.db import Base
import enum

class UserRole(enum.Enum):
    physician = "physician"
    nurse = "nurse"
    admin = "admin"
    patient = "patient" # A patient may have login credentials

class User(Base):
    """
    Database model for a system user.
    """
    __tablename__ = "users"

    id = Column(Integer, primary_key=True, index=True)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, index=True)
    role = Column(Enum(UserRole), nullable=False)
    is_active = Column(Boolean, default=True)
```

```python
# /models/patient.py

from sqlalchemy import Column, Integer, String, Date
from core.db import Base

class Patient(Base):
    """
    Database model for a patient.
    """
    __tablename__ = "patients"

    id = Column(Integer, primary_key=True, index=True)
    medical_record_number = Column(String, unique=True, index=True, nullable=False)
    full_name = Column(String, nullable=False)
    date_of_birth = Column(Date, nullable=False)
```

```python
# /models/lab_result.py

from sqlalchemy import Column, Integer, String, Date, DateTime, ForeignKey
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from core.db import Base

class LabResult(Base):
    """
    Database model for lab result metadata.
    The actual report is stored in an encrypted S3 bucket.
    """
    __tablename__ = "lab_results"

    id = Column(Integer, primary_key=True, index=True)
    patient_id = Column(Integer, ForeignKey("patients.id"), nullable=False, index=True)
    ordering_physician_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    
    test_name = Column(String, nullable=False, index=True)
    result_date = Column(Date, nullable=False)
    s3_object_key = Column(String, nullable=False, unique=True) # Key to the encrypted file in S3
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    patient = relationship("Patient")
    ordering_physician = relationship("User")
```

```python
# /models/audit_log.py

from sqlalchemy import Column, Integer, String, DateTime, JSON, ForeignKey
from sqlalchemy.sql import func
from core.db import Base

class AuditLog(Base):
    """
    Database model for HIPAA audit trails.
    Logs all access to Protected Health Information (PHI).
    """
    __tablename__ = "audit_logs"

    id = Column(Integer, primary_key=True, index=True)
    timestamp = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    performing_user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    action = Column(String, nullable=False, index=True) # e.g., "VIEW_PATIENT_LABS"
    patient_id = Column(Integer, ForeignKey("patients.id"), nullable=True, index=True) # Nullable if action is not patient-specific
    details = Column(JSON) # Additional context, e.g., IP address, user-agent
```

```python
# /schemas/token.py

from pydantic import BaseModel
from typing import Optional

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    user_id: Optional[int] = None
```

```python
# /schemas/user.py

from pydantic import BaseModel, EmailStr
from models.user import UserRole

class UserBase(BaseModel):
    email: EmailStr
    full_name: str

class UserInDB(UserBase):
    id: int
    role: UserRole
    is_active: bool

    class Config:
        from_attributes = True
```

```python
# /schemas/lab_result.py

from pydantic import BaseModel
from datetime import date

class LabResultBase(BaseModel):
    test_name: str
    result_date: date

class LabResultResponse(LabResultBase):
    """
    Schema for returning lab result metadata to the client.
    Critically, it includes a temporary, secure download URL instead of the raw file key.
    """
    id: int
    ordering_physician_name: str
    download_url: str

    class Config:
        from_attributes = True
```

```python
# /schemas/audit_log.py

from pydantic import BaseModel
from typing import Dict, Any

class AuditLogCreate(BaseModel):
    performing_user_id: int
    action: str
    patient_id: int
    details: Dict[str, Any]
```

```python
# /crud/crud_user.py

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from models.user import User

async def get_user_by_id(db: AsyncSession, user_id: int):
    """
    Fetches a user by their ID.
    """
    result = await db.execute(select(User).filter(User.id == user_id))
    return result.scalars().first()
```

```python
# /crud/crud_audit_log.py

from sqlalchemy.ext.asyncio import AsyncSession
from models.audit_log import AuditLog
from schemas.audit_log import AuditLogCreate

async def create_audit_log(db: AsyncSession, *, log_entry: AuditLogCreate) -> AuditLog:
    """
    Creates a new entry in the audit log.
    This is a critical function for HIPAA compliance.
    """
    db_obj = AuditLog(**log_entry.model_dump())
    db.add(db_obj)
    await db.commit()
    await db.refresh(db_obj)
    return db_obj
```

```python
# /crud/crud_patient_access.py

from sqlalchemy.ext.asyncio import AsyncSession
from models.user import User

async def verify_user_access_to_patient(db: AsyncSession, *, user: User, patient_id: int) -> bool:
    """
    Verifies if a user is authorized to access a patient's records.
    This is a placeholder for a complex business logic rule.
    In a real system, this would query a care team, patient-provider relationship,
    or other authorization tables. For this example, we'll allow clinicians and admins.
    """
    # Production logic would be far more granular.
    # Example: Check if the user is in the patient's assigned care team.
    # SELECT 1 FROM care_teams WHERE user_id = :user_id AND patient_id = :patient_id
    if user.role in ["physician", "nurse", "admin"]:
        return True
    
    # Patients may be able to view their own records.
    # This would require linking user accounts to patient records.
    # if user.role == "patient" and user.patient_link.patient_id == patient_id:
    #     return True

    return False
```

```python
# /crud/crud_lab_result.py

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from typing import List

from models.lab_result import LabResult

async def get_lab_results_for_patient(
    db: AsyncSession, *, patient_id: int, skip: int = 0, limit: int = 100
) -> List[LabResult]:
    """
    Retrieves a paginated list of lab result metadata for a specific patient.
    Uses selectinload to eagerly load the related physician to avoid extra queries.
    """
    query = (
        select(LabResult)
        .where(LabResult.patient_id == patient_id)
        .options(selectinload(LabResult.ordering_physician))
        .order_by(LabResult.result_date.desc())
        .offset(skip)
        .limit(limit)
    )
    result = await db.execute(query)
    return result.scalars().all()
```

```python
# /services/s3_service.py

import boto3
from botocore.client import Config
from botocore.exceptions import ClientError
from core.config import settings
import logging

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

# Initialize S3 client
s3_client = boto3.client(
    "s3",
    aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
    aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
    region_name=settings.AWS_REGION,
    config=Config(signature_version="s3v4"),
)

def create_presigned_url(object_name: str) -> str | None:
    """
    Generate a presigned URL to share an S3 object.
    This provides temporary, secure access to the encrypted lab report file.

    :param object_name: string
    :return: Presigned URL as string. If error, returns None.
    """
    try:
        response = s3_client.generate_presigned_url(
            "get_object",
            Params={"Bucket": settings.S3_BUCKET_NAME, "Key": object_name},
            ExpiresIn=settings.S3_PRESIGNED_URL_EXPIRATION_SECONDS,
        )
    except ClientError as e:
        logger.error(f"Error generating presigned URL for {object_name}: {e}")
        return None
    except Exception as e:
        logger.error(f"An unexpected error occurred during presigned URL generation: {e}")
        return None

    return response
```

```python
# /core/security.py

from datetime import datetime, timedelta
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.ext.asyncio import AsyncSession

from core.config import settings
from core.db import get_db
from models import user as user_model
from schemas import token as token_schema
from crud import crud_user

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{settings.API_V1_STR}/login/token")

def create_access_token(data: dict) -> str:
    to_encode = data.copy()
    expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.JWT_SECRET_KEY, algorithm=settings.JWT_ALGORITHM)
    return encoded_jwt

async def get_current_active_user(
    token: str = Depends(oauth2_scheme), db: AsyncSession = Depends(get_db)
) -> user_model.User:
    """
    Dependency to get the current authenticated and active user.
    Raises HTTPException for invalid credentials or inactive users.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.JWT_SECRET_KEY, algorithms=[settings.JWT_ALGORITHM])
        user_id: int = payload.get("sub")
        if user_id is None:
            raise credentials_exception
        token_data = token_schema.TokenData(user_id=user_id)
    except JWTError:
        raise credentials_exception
    
    user = await crud_user.get_user_by_id(db, user_id=token_data.user_id)
    if user is None:
        raise credentials_exception
    if not user.is_active:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")
    
    return user
```

```python
# /api/v1/endpoints/lab_results.py

from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List

from core import db, security
from models import user as user_model
from schemas import lab_result as lab_schema, audit_log as audit_schema
from crud import crud_lab_result, crud_audit_log, crud_patient_access
from services import s3_service

router = APIRouter()

@router.get(
    "/patients/{patient_id}/lab-results",
    response_model=List[lab_schema.LabResultResponse],
    summary="Get Patient Lab Results",
    description="Retrieves a list of lab result metadata for a specific patient. Access is strictly audited.",
    status_code=status.HTTP_200_OK,
)
async def get_patient_lab_results(
    request: Request,
    patient_id: int,
    current_user: user_model.User = Depends(security.get_current_active_user),
    db: AsyncSession = Depends(db.get_db),
    skip: int = 0,
    limit: int = 100,
):
    """
    Provides access to a patient's lab results.

    - **Authentication**: Requires a valid JWT bearer token.
    - **Authorization**: Verifies the user has rights to view the specified patient's data.
    - **Auditing**: Logs every access attempt to the HIPAA audit log.
    - **Data Security**: Returns temporary, secure download links for result files, not direct object keys.
    """
    # 1. Authorization: Verify user has rights to access this patient's data
    is_authorized = await crud_patient_access.verify_user_access_to_patient(
        db=db, user=current_user, patient_id=patient_id
    )
    if not is_authorized:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User not authorized to access this patient's records.",
        )

    # 2. Auditing: Log the access event
    audit_details = {
        "ip_address": request.client.host,
        "user_agent": request.headers.get("user-agent"),
        "request_details": f"Accessed lab results with skip={skip}, limit={limit}",
    }
    log_entry = audit_schema.AuditLogCreate(
        performing_user_id=current_user.id,
        action="VIEW_PATIENT_LABS",
        patient_id=patient_id,
        details=audit_details,
    )
    await crud_audit_log.create_audit_log(db=db, log_entry=log_entry)

    # 3. Data Retrieval: Fetch lab result metadata from the database
    db_lab_results = await crud_lab_result.get_lab_results_for_patient(
        db=db, patient_id=patient_id, skip=skip, limit=limit
    )
    
    # 4. Response Preparation: Generate secure, temporary URLs for each result
    response_data = []
    for result in db_lab_results:
        download_url = s3_service.create_presigned_url(object_name=result.s3_object_key)
        if not download_url:
            # In a production system, this failure should be handled robustly,
            # perhaps by omitting the result or returning a specific error indicator.
            continue
            
        response_data.append(
            lab_schema.LabResultResponse(
                id=result.id,
                test_name=result.test_name,
                result_date=result.result_date,
                ordering_physician_name=result.ordering_physician.full_name,
                download_url=download_url,
            )
        )

    return response_data
```

```python
# /api/v1/api.py

from fastapi import APIRouter
from api.v1.endpoints import lab_results

api_router = APIRouter()
api_router.include_router(lab_results.router, tags=["Lab Results"])
```

```python
# /main.py

from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from sqlalchemy.exc import SQLAlchemyError

from core.config import settings
from api.v1.api import api_router

app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_STR}/openapi.json",
    docs_url=f"{settings.API_V1_STR}/docs",
    redoc_url=f"{settings.API_V1_STR}/redoc",
)

# Include the main API router
app.include_router(api_router, prefix=settings.API_V1_STR)

# --- Production-Grade Exception Handlers ---

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    """
    Handles request validation errors to provide a clear, standardized response.
    """
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={"detail": "Invalid request payload", "errors": exc.errors()},
    )

@app.exception_handler(SQLAlchemyError)
async def sqlalchemy_exception_handler(request: Request, exc: SQLAlchemyError):
    """
    Handles database errors to prevent leaking sensitive information.
    Logs the detailed error for internal review.
    """
    # In a real system, this would use a structured logger.
    print(f"Database error occurred: {exc}") 
    return JSONResponse(
        status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
        content={"detail": "A database error occurred. Please try again later."},
    )

@app.exception_handler(Exception)
async def generic_exception_handler(request: Request, exc: Exception):
    """
    Catches any unhandled exceptions to ensure a generic, safe error
    response is returned to the client.
    """
    # In a real system, this would use a structured logger.
    print(f"An unhandled exception occurred: {exc}")
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={"detail": "An internal server error occurred."},
    )

@app.get("/", include_in_schema=False)
def read_root():
    return {"status": "EMR Service is operational"}

```