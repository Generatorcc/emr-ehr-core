```python
# /core/config.py
# Description: Configuration management for the application.

import os
from pydantic_settings import BaseSettings

class AppSettings(BaseSettings):
    """
    Application settings loaded from environment variables.
    Ensures critical configuration is not hardcoded.
    """
    # Application settings
    API_V1_STR: str = "/api/v1"
    PROJECT_NAME: str = "EMR-Core-API"
    SERVER_HOST: str = "0.0.0.0"
    SERVER_PORT: int = 8000

    # Security settings
    SECRET_KEY: str = os.getenv("SECRET_KEY", "a_very_secret_key_for_development_only")
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60  # Token lifetime
    ALGORITHM: str = "HS256"

    # Database settings
    DATABASE_URL: str = os.getenv("DATABASE_URL", "postgresql+asyncpg://user:password@localhost/emr_db")

    # Secure Storage (S3) settings
    S3_BUCKET_NAME: str = os.getenv("S3_BUCKET_NAME", "emr-secure-documents-bucket")
    S3_PRESIGNED_URL_EXPIRATION_SECONDS: int = 300 # 5 minutes
    AWS_ACCESS_KEY_ID: str = os.getenv("AWS_ACCESS_KEY_ID", "")
    AWS_SECRET_ACCESS_KEY: str = os.getenv("AWS_SECRET_ACCESS_KEY", "")
    AWS_REGION: str = os.getenv("AWS_REGION", "us-east-1")

    class Config:
        case_sensitive = True
        env_file = ".env"

settings = AppSettings()

# /db/models.py
# Description: SQLAlchemy ORM models for database tables.

import enum
from sqlalchemy import (
    Column, Integer, String, DateTime, Boolean, ForeignKey, Enum
)
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

class UserRole(str, enum.Enum):
    ADMIN = "admin"
    CLINICIAN = "clinician"
    NURSE = "nurse"
    PATIENT = "patient"

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    email = Column(String, unique=True, index=True, nullable=False)
    full_name = Column(String, index=True)
    role = Column(Enum(UserRole), nullable=False, default=UserRole.CLINICIAN)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

class DocumentMetadata(Base):
    __tablename__ = "document_metadata"
    id = Column(Integer, primary_key=True, index=True)
    patient_id = Column(Integer, nullable=False, index=True) # Assuming patient_id from a Patient table
    document_name = Column(String, nullable=False)
    document_type = Column(String, nullable=False) # e.g., 'Lab Report', 'Imaging', 'Discharge Summary'
    s3_bucket = Column(String, nullable=False)
    s3_key = Column(String, nullable=False, unique=True)
    file_size_bytes = Column(Integer)
    mime_type = Column(String)
    uploaded_by_user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    
    uploader = relationship("User")

class AuditAction(str, enum.Enum):
    LOGIN_SUCCESS = "LOGIN_SUCCESS"
    LOGIN_FAILURE = "LOGIN_FAILURE"
    DOCUMENT_UPLOAD = "DOCUMENT_UPLOAD"
    DOCUMENT_ACCESS = "DOCUMENT_ACCESS"
    DOCUMENT_DELETE = "DOCUMENT_DELETE"

class AuditLog(Base):
    __tablename__ = "audit_log"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=True) # Nullable for system events or failed logins
    action = Column(Enum(AuditAction), nullable=False)
    target_resource_id = Column(String, index=True, nullable=True) # e.g., patient_id or document_id
    details = Column(String, nullable=True)
    ip_address = Column(String, nullable=True)
    timestamp = Column(DateTime(timezone=True), server_default=func.now())
    
    user = relationship("User")


# /db/session.py
# Description: Database session and engine setup.

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from core.config import settings

engine = create_async_engine(settings.DATABASE_URL, pool_pre_ping=True)
AsyncSessionLocal = sessionmaker(
    engine,
    class_=AsyncSession,
    autocommit=False,
    autoflush=False,
    expire_on_commit=False,
)

# /schemas/token.py
# Description: Pydantic schemas for authentication tokens.

from pydantic import BaseModel
from typing import Optional

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None

# /schemas/user.py
# Description: Pydantic schemas for User data models.

from pydantic import BaseModel, EmailStr
from datetime import datetime
from .token import Token
from db.models import UserRole

class UserBase(BaseModel):
    username: str
    email: EmailStr
    full_name: Optional[str] = None

class UserCreate(UserBase):
    password: str
    role: UserRole

class UserInDB(UserBase):
    id: int
    is_active: bool
    role: UserRole
    created_at: datetime

    class Config:
        from_attributes = True

class User(UserInDB):
    pass

# /schemas/audit.py
# Description: Pydantic schemas for audit logging.

from pydantic import BaseModel
from datetime import datetime
from db.models import AuditAction

class AuditLogCreate(BaseModel):
    user_id: Optional[int] = None
    action: AuditAction
    target_resource_id: Optional[str] = None
    details: Optional[str] = None
    ip_address: Optional[str] = None

class AuditLogInDB(AuditLogCreate):
    id: int
    timestamp: datetime

    class Config:
        from_attributes = True

# /schemas/document.py
# Description: Pydantic schemas for document metadata.

from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class DocumentMetadataBase(BaseModel):
    document_name: str
    document_type: str
    patient_id: int

class DocumentMetadataCreate(DocumentMetadataBase):
    s3_bucket: str
    s3_key: str
    file_size_bytes: int
    mime_type: str
    uploaded_by_user_id: int

class DocumentMetadataInDB(DocumentMetadataBase):
    id: int
    s3_key: str
    uploaded_by_user_id: int
    created_at: datetime

    class Config:
        from_attributes = True

class DocumentDownloadInfo(BaseModel):
    download_url: str
    expires_at: datetime

# /core/security.py
# Description: Security utilities for password hashing and JWT handling.

from datetime import datetime, timedelta, timezone
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from .config import settings

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    """Verifies a plain password against its hashed version."""
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    """Hashes a plain password."""
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    """Creates a JWT access token."""
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

# /crud/crud_user.py
# Description: CRUD operations for the User model.

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from db.models import User
from schemas.user import UserCreate
from core.security import get_password_hash
from typing import Optional

async def get_user_by_username(db: AsyncSession, username: str) -> Optional[User]:
    """Retrieves a user by their username."""
    result = await db.execute(select(User).filter(User.username == username))
    return result.scalars().first()

async def create_user(db: AsyncSession, *, user_in: UserCreate) -> User:
    """Creates a new user in the database."""
    hashed_password = get_password_hash(user_in.password)
    db_user = User(
        username=user_in.username,
        email=user_in.email,
        full_name=user_in.full_name,
        hashed_password=hashed_password,
        role=user_in.role
    )
    db.add(db_user)
    await db.commit()
    await db.refresh(db_user)
    return db_user

# /crud/crud_audit.py
# Description: CRUD operations for the AuditLog model.

from sqlalchemy.ext.asyncio import AsyncSession
from db.models import AuditLog
from schemas.audit import AuditLogCreate

async def create_audit_log(db: AsyncSession, *, log_in: AuditLogCreate) -> AuditLog:
    """Creates a new audit log entry."""
    db_log = AuditLog(**log_in.model_dump())
    db.add(db_log)
    await db.commit()
    await db.refresh(db_log)
    return db_log

# /crud/crud_document.py
# Description: CRUD operations for the DocumentMetadata model.

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from db.models import DocumentMetadata
from schemas.document import DocumentMetadataCreate
from typing import Optional, List

async def create_document_metadata(db: AsyncSession, *, doc_in: DocumentMetadataCreate) -> DocumentMetadata:
    """Creates a new document metadata record."""
    db_doc = DocumentMetadata(**doc_in.model_dump())
    db.add(db_doc)
    await db.commit()
    await db.refresh(db_doc)
    return db_doc

async def get_document_metadata_by_id(db: AsyncSession, doc_id: int) -> Optional[DocumentMetadata]:
    """Retrieves document metadata by its primary key."""
    result = await db.execute(select(DocumentMetadata).filter(DocumentMetadata.id == doc_id))
    return result.scalars().first()

async def get_documents_for_patient(db: AsyncSession, patient_id: int) -> List[DocumentMetadata]:
    """Retrieves all document metadata records for a given patient."""
    result = await db.execute(select(DocumentMetadata).filter(DocumentMetadata.patient_id == patient_id))
    return result.scalars().all()

# /services/s3_service.py
# Description: Service for interacting with AWS S3 for secure storage.

import boto3
from botocore.exceptions import ClientError
from core.config import settings
import logging
from uuid import uuid4
from datetime import datetime, timedelta, timezone

logger = logging.getLogger(__name__)

s3_client = boto3.client(
    "s3",
    region_name=settings.AWS_REGION,
    aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
    aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY
)

def generate_s3_key(patient_id: int, filename: str) -> str:
    """Generates a unique, non-guessable S3 key for a patient document."""
    unique_id = uuid4()
    return f"patients/{patient_id}/documents/{unique_id}-{filename}"

def upload_file_to_s3(file_obj, s3_key: str) -> bool:
    """
    Uploads a file-like object to S3 with server-side encryption.
    """
    try:
        s3_client.upload_fileobj(
            file_obj,
            settings.S3_BUCKET_NAME,
            s3_key,
            ExtraArgs={"ServerSideEncryption": "AES256"}
        )
    except ClientError as e:
        logger.error(f"S3 Upload Failed: {e}")
        return False
    return True

def create_presigned_url(s3_key: str) -> Optional[str]:
    """
    Generates a pre-signed URL to securely access an S3 object.
    The URL is short-lived to minimize exposure.
    """
    try:
        response = s3_client.generate_presigned_url(
            'get_object',
            Params={'Bucket': settings.S3_BUCKET_NAME, 'Key': s3_key},
            ExpiresIn=settings.S3_PRESIGNED_URL_EXPIRATION_SECONDS
        )
    except ClientError as e:
        logger.error(f"S3 Presigned URL Generation Failed: {e}")
        return None
    return response

# /api/v1/dependencies.py
# Description: Reusable FastAPI dependencies for security and session management.

from fastapi import Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.ext.asyncio import AsyncSession

from core.config import settings
from db.session import AsyncSessionLocal
from db.models import User, UserRole
from crud import crud_user
from schemas.token import TokenData

oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{settings.API_V1_STR}/users/token")

async def get_db() -> AsyncSession:
    """Dependency to get a database session."""
    async with AsyncSessionLocal() as session:
        yield session

async def get_current_user(
    db: AsyncSession = Depends(get_db), token: str = Depends(oauth2_scheme)
) -> User:
    """Dependency to get the current authenticated user from a JWT."""
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except JWTError:
        raise credentials_exception
    
    user = await crud_user.get_user_by_username(db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(current_user: User = Depends(get_current_user)) -> User:
    """Dependency to ensure the current user is active."""
    if not current_user.is_active:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")
    return current_user

def require_role(required_role: UserRole):
    """Dependency factory to require a specific user role."""
    def role_checker(current_user: User = Depends(get_current_active_user)) -> User:
        if current_user.role != required_role and current_user.role != UserRole.ADMIN:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"User does not have required role: {required_role.value}"
            )
        return current_user
    return role_checker

# /api/v1/endpoints/audit.py
# Description: API endpoint for creating audit logs (internal use).

from fastapi import Depends, Request
from sqlalchemy.ext.asyncio import AsyncSession
from schemas.audit import AuditLogCreate
from crud import crud_audit
from api.v1.dependencies import get_db

async def create_audit_log_entry(
    request: Request,
    db: AsyncSession,
    action: str,
    user_id: Optional[int] = None,
    target_resource_id: Optional[str] = None,
    details: Optional[str] = None
):
    """Utility function to create an audit log entry."""
    client_host = request.client.host if request.client else "unknown"
    log_entry = AuditLogCreate(
        user_id=user_id,
        action=action,
        target_resource_id=target_resource_id,
        details=details,
        ip_address=client_host
    )
    await crud_audit.create_audit_log(db, log_in=log_entry)

# /api/v1/endpoints/users.py
# Description: API endpoints for user management and authentication.

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession
from typing import Any

from crud import crud_user
from schemas import user as user_schema
from schemas import token as token_schema
from core import security
from api.v1.dependencies import get_db, get_current_active_user
from .audit import create_audit_log_entry
from db.models import AuditAction, User
from fastapi import Request

router = APIRouter()

@router.post("/token", response_model=token_schema.Token)
async def login_for_access_token(
    request: Request,
    db: AsyncSession = Depends(get_db),
    form_data: OAuth2PasswordRequestForm = Depends()
) -> Any:
    """Authenticate user and return a JWT access token."""
    user = await crud_user.get_user_by_username(db, username=form_data.username)
    if not user or not security.verify_password(form_data.password, user.hashed_password):
        await create_audit_log_entry(
            request, db, AuditAction.LOGIN_FAILURE,
            details=f"Failed login attempt for username: {form_data.username}"
        )
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    if not user.is_active:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")

    await create_audit_log_entry(request, db, AuditAction.LOGIN_SUCCESS, user_id=user.id)
    access_token = security.create_access_token(data={"sub": user.username})
    return {"access_token": access_token, "token_type": "bearer"}

@router.get("/me", response_model=user_schema.User)
async def read_users_me(current_user: User = Depends(get_current_active_user)) -> Any:
    """Get current authenticated user's details."""
    return current_user

# /api/v1/endpoints/documents.py
# Description: API endpoints for secure patient document handling.

from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Request
from sqlalchemy.ext.asyncio import AsyncSession
from typing import List, Any
from datetime import datetime, timezone

from api.v1.dependencies import get_db, get_current_active_user, require_role
from db.models import User, UserRole, AuditAction
from crud import crud_document
from schemas import document as doc_schema
from core.config import settings
from services import s3_service
from .audit import create_audit_log_entry

router = APIRouter()

@router.post(
    "/patients/{patient_id}/documents",
    response_model=doc_schema.DocumentMetadataInDB,
    status_code=status.HTTP_201_CREATED
)
async def upload_patient_document(
    *,
    request: Request,
    patient_id: int,
    document_type: str,
    file: UploadFile = File(...),
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(require_role(UserRole.CLINICIAN)),
) -> Any:
    """
    Uploads a document for a specific patient.
    - Requires 'clinician' or 'admin' role.
    - File is stored in a secure S3 bucket with server-side encryption.
    - Metadata is stored in the EMR database.
    - An audit log is created for this action.
    """
    if not file.filename:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="No filename provided.")

    s3_key = s3_service.generate_s3_key(patient_id, file.filename)
    
    # Read file content to get size before upload
    file.file.seek(0, 2)
    file_size = file.file.tell()
    file.file.seek(0)
    
    success = s3_service.upload_file_to_s3(file.file, s3_key)

    if not success:
        raise HTTPException(status.HTTP_500_INTERNAL_SERVER_ERROR, "Failed to upload file to storage.")

    doc_metadata_in = doc_schema.DocumentMetadataCreate(
        patient_id=patient_id,
        document_name=file.filename,
        document_type=document_type,
        s3_bucket=settings.S3_BUCKET_NAME,
        s3_key=s3_key,
        file_size_bytes=file_size,
        mime_type=file.content_type,
        uploaded_by_user_id=current_user.id
    )

    created_doc = await crud_document.create_document_metadata(db=db, doc_in=doc_metadata_in)

    await create_audit_log_entry(
        request, db, AuditAction.DOCUMENT_UPLOAD,
        user_id=current_user.id,
        target_resource_id=f"patient:{patient_id},doc:{created_doc.id}",
        details=f"Uploaded document '{file.filename}' of type '{document_type}'."
    )

    return created_doc


@router.get(
    "/patients/{patient_id}/documents/{document_id}/download-info",
    response_model=doc_schema.DocumentDownloadInfo,
)
async def get_document_download_info(
    *,
    request: Request,
    patient_id: int,
    document_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(require_role(UserRole.CLINICIAN)),
) -> Any:
    """
    Retrieves a short-lived, pre-signed URL to download a patient document.
    - Requires 'clinician' or 'admin' role.
    - Verifies the document belongs to the specified patient.
    - An audit log is created for this access event.
    """
    doc_metadata = await crud_document.get_document_metadata_by_id(db, doc_id=document_id)

    if not doc_metadata or doc_metadata.patient_id != patient_id:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Document not found or does not belong to the specified patient."
        )

    presigned_url = s3_service.create_presigned_url(s3_key=doc_metadata.s3_key)

    if not presigned_url:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Could not generate secure download link."
        )

    await create_audit_log_entry(
        request, db, AuditAction.DOCUMENT_ACCESS,
        user_id=current_user.id,
        target_resource_id=f"patient:{patient_id},doc:{document_id}",
        details=f"Accessed download link for document '{doc_metadata.document_name}'."
    )
    
    expiration_time = datetime.now(timezone.utc) + timedelta(seconds=settings.S3_PRESIGNED_URL_EXPIRATION_SECONDS)

    return doc_schema.DocumentDownloadInfo(download_url=presigned_url, expires_at=expiration_time)


@router.get(
    "/patients/{patient_id}/documents",
    response_model=List[doc_schema.DocumentMetadataInDB]
)
async def list_patient_documents(
    *,
    patient_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(require_role(UserRole.CLINICIAN)),
) -> Any:
    """
    Lists all document metadata for a given patient.
    - Requires 'clinician' or 'admin' role.
    - Does not return file content, only metadata.
    """
    documents = await crud_document.get_documents_for_patient(db=db, patient_id=patient_id)
    return documents

# /api/v1/api.py
# Description: API router that aggregates all endpoint routers.

from fastapi import APIRouter
from api.v1.endpoints import users, documents

api_router = APIRouter()
api_router.include_router(users.router, prefix="/users", tags=["Users & Authentication"])
api_router.include_router(documents.router, prefix="", tags=["Patient Documents"])

# /main.py
# Description: Main application entry point.

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from core.config import settings
from api.v1.api import api_router

app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_STR}/openapi.json"
)

# CORS (Cross-Origin Resource Sharing)
# For production, this should be a strict list of allowed origins.
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], # Insecure default for development. Change to specific frontend URLs.
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/", tags=["Health Check"])
def read_root():
    """Health check endpoint."""
    return {"status": "ok", "project": settings.PROJECT_NAME}

# To run this application:
# 1. Create a virtual environment: `python -m venv venv`
# 2. Activate it: `source venv/bin/activate`
# 3. Install dependencies: `pip install "fastapi[all]" "uvicorn[standard]" pydantic-settings sqlalchemy[asyncpg] jose-python passlib[bcrypt] boto3`
# 4. Set up a PostgreSQL database and an S3 bucket.
# 5. Create a .env file with your configuration (see /core/config.py).
# 6. Run the server: `uvicorn main:app --host 0.0.0.0 --port 8000 --reload`
```