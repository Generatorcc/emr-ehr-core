```python
# /core/config.py

import os
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    """
    Application-wide settings managed by Pydantic, loaded from environment variables.
    """
    PROJECT_NAME: str = "EMR Secure Backend"
    API_V1_STR: str = "/api/v1"

    # Database Configuration (PostgreSQL)
    # Example: postgresql://user:password@host:port/dbname
    DATABASE_URL: str = os.getenv("DATABASE_URL", "postgresql://emr_user:securepassword@localhost/emr_db")

    # JWT Security Configuration
    JWT_SECRET_KEY: str = os.getenv("JWT_SECRET_KEY", "a_very_secure_secret_key_that_is_at_least_32_bytes_long")
    # HS256 is a symmetric algorithm
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30

    # AWS S3 Configuration for Encrypted Storage
    AWS_ACCESS_KEY_ID: str = os.getenv("AWS_ACCESS_KEY_ID", "YOUR_AWS_ACCESS_KEY_ID")
    AWS_SECRET_ACCESS_KEY: str = os.getenv("AWS_SECRET_ACCESS_KEY", "YOUR_AWS_SECRET_ACCESS_KEY")
    AWS_REGION: str = os.getenv("AWS_REGION", "us-east-1")
    S3_BUCKET_NAME: str = os.getenv("S3_BUCKET_NAME", "emr-secure-clinical-documents")
    S3_PRESIGNED_URL_EXPIRATION_SECONDS: int = 300  # 5 minutes

    class Config:
        case_sensitive = True

settings = Settings()

# /db/models.py

import enum
from sqlalchemy import (
    create_engine, Column, Integer, String, DateTime,
    ForeignKey, Enum as EnumType, JSON
)
from sqlalchemy.orm import relationship
from sqlalchemy.ext.declarative import declarative_base
import datetime

Base = declarative_base()

class UserRole(str, enum.Enum):
    DOCTOR = "doctor"
    NURSE = "nurse"
    ADMIN = "admin"

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, nullable=False)
    role = Column(EnumType(UserRole), nullable=False)
    is_active = Column(Integer, default=1, nullable=False) # Use integer for wider DB support

class Patient(Base):
    __tablename__ = "patients"
    id = Column(Integer, primary_key=True, index=True)
    # Minimal PHI for demonstration; real EMR would have more encrypted fields
    # This is a stub for foreign key reference
    mrn = Column(String, unique=True, index=True, nullable=False) 

class ClinicalDocument(Base):
    __tablename__ = "clinical_documents"
    id = Column(Integer, primary_key=True, index=True)
    patient_id = Column(Integer, ForeignKey("patients.id"), nullable=False, index=True)
    uploader_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    document_name = Column(String, nullable=False)
    document_type = Column(String, nullable=False) # e.g., 'LAB_RESULT', 'RADIOLOGY_REPORT'
    s3_object_key = Column(String, unique=True, nullable=False)
    upload_timestamp = Column(DateTime, default=datetime.datetime.utcnow, nullable=False)
    file_hash_sha256 = Column(String, nullable=False) # For integrity verification

    patient = relationship("Patient")
    uploader = relationship("User")

class AuditLogAction(str, enum.Enum):
    LOGIN_SUCCESS = "LOGIN_SUCCESS"
    LOGIN_FAILURE = "LOGIN_FAILURE"
    DOCUMENT_UPLOAD = "DOCUMENT_UPLOAD"
    DOCUMENT_VIEW = "DOCUMENT_VIEW"
    ACCESS_DENIED = "ACCESS_DENIED"
    RESOURCE_NOT_FOUND = "RESOURCE_NOT_FOUND"

class AuditLogStatus(str, enum.Enum):
    SUCCESS = "success"
    FAILURE = "failure"

class AuditLog(Base):
    __tablename__ = "audit_logs"
    id = Column(Integer, primary_key=True, index=True)
    timestamp = Column(DateTime, default=datetime.datetime.utcnow, nullable=False)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=True) # Nullable for system actions or failed logins
    action = Column(EnumType(AuditLogAction), nullable=False)
    resource_type = Column(String, nullable=True) # e.g., 'Patient', 'ClinicalDocument'
    resource_id = Column(Integer, nullable=True)
    status = Column(EnumType(AuditLogStatus), nullable=False)
    ip_address = Column(String, nullable=False)
    details = Column(JSON, nullable=True) # For additional context

    user = relationship("User")


# /db/session.py

from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from core.config import settings

engine = create_engine(settings.DATABASE_URL, pool_pre_ping=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def get_db():
    """
    Dependency to get a database session.
    Ensures the session is closed after the request.
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# /api/schemas/user.py

from pydantic import BaseModel, Field
from db.models import UserRole

class UserBase(BaseModel):
    username: str = Field(..., min_length=3, max_length=50)
    full_name: str = Field(..., min_length=3, max_length=100)
    role: UserRole

class UserCreate(UserBase):
    password: str = Field(..., min_length=8)

class UserInDB(UserBase):
    id: int
    is_active: bool

    class Config:
        orm_mode = True

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: str | None = None


# /api/schemas/clinical_document.py

import datetime
from pydantic import BaseModel, Field

class ClinicalDocumentMetadata(BaseModel):
    id: int
    patient_id: int
    uploader_id: int
    document_name: str
    document_type: str
    upload_timestamp: datetime.datetime

    class Config:
        orm_mode = True

class ClinicalDocumentResponse(ClinicalDocumentMetadata):
    download_url: str = Field(..., description="Secure, time-limited URL to download the document")


# /services/audit_service.py

from sqlalchemy.orm import Session
from db.models import AuditLog, AuditLogAction, AuditLogStatus
from typing import Optional, Dict, Any

def create_audit_log(
    db: Session,
    *,
    action: AuditLogAction,
    status: AuditLogStatus,
    ip_address: str,
    user_id: Optional[int] = None,
    resource_type: Optional[str] = None,
    resource_id: Optional[int] = None,
    details: Optional[Dict[str, Any]] = None,
) -> AuditLog:
    """
    Creates and saves an audit log entry.
    """
    audit_entry = AuditLog(
        user_id=user_id,
        action=action,
        status=status,
        ip_address=ip_address,
        resource_type=resource_type,
        resource_id=resource_id,
        details=details or {},
    )
    db.add(audit_entry)
    db.commit()
    db.refresh(audit_entry)
    return audit_entry

# /core/security.py

from datetime import datetime, timedelta
from typing import Optional, List
from fastapi import Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext
from sqlalchemy.orm import Session
from pydantic import ValidationError

from core.config import settings
from db import session, models
from services.audit_service import create_audit_log
from db.models import AuditLogAction, AuditLogStatus

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{settings.API_V1_STR}/users/token")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.JWT_SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def get_user(db: Session, username: str) -> Optional[models.User]:
    return db.query(models.User).filter(models.User.username == username).first()

def get_current_user(
    request: Request,
    db: Session = Depends(session.get_db),
    token: str = Depends(oauth2_scheme)
) -> models.User:
    """
    Dependency to get the current authenticated user from a JWT token.
    Performs security checks and raises HTTPExceptions on failure.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.JWT_SECRET_KEY, algorithms=[settings.ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
    except (JWTError, ValidationError):
        raise credentials_exception
    
    user = get_user(db, username=username)
    if user is None:
        raise credentials_exception
    if not user.is_active:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")
    
    return user

class RoleRequired:
    """
    Dependency to check for user role.
    Usage: Depends(RoleRequired(["doctor", "admin"]))
    """
    def __init__(self, allowed_roles: List[str]):
        self.allowed_roles = allowed_roles

    def __call__(self, request: Request, user: models.User = Depends(get_current_user), db: Session = Depends(session.get_db)):
        if user.role.value not in self.allowed_roles:
            create_audit_log(
                db=db,
                user_id=user.id,
                action=AuditLogAction.ACCESS_DENIED,
                status=AuditLogStatus.FAILURE,
                ip_address=request.client.host,
                details={"reason": f"User role '{user.role.value}' not in allowed roles: {self.allowed_roles}"}
            )
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="The user does not have adequate permissions"
            )
        return user


# /services/s3_service.py

import logging
import boto3
from botocore.exceptions import ClientError
from fastapi import UploadFile
from core.config import settings
from typing import Optional

logger = logging.getLogger(__name__)

s3_client = boto3.client(
    "s3",
    aws_access_key_id=settings.AWS_ACCESS_KEY_ID,
    aws_secret_access_key=settings.AWS_SECRET_ACCESS_KEY,
    region_name=settings.AWS_REGION,
)

def upload_file_to_s3(file: UploadFile, object_key: str) -> bool:
    """
    Upload a file to an S3 bucket with server-side encryption.
    :param file: File to upload (FastAPI UploadFile object)
    :param object_key: S3 object key (path within the bucket)
    :return: True if file was uploaded, else False
    """
    try:
        s3_client.upload_fileobj(
            file.file,
            settings.S3_BUCKET_NAME,
            object_key,
            ExtraArgs={
                "ServerSideEncryption": "AES256",
                "ContentType": file.content_type
            }
        )
    except ClientError as e:
        logger.error(f"S3 upload failed for key {object_key}: {e}")
        return False
    return True

def create_presigned_url(object_key: str) -> Optional[str]:
    """
    Generate a presigned URL to share an S3 object.
    :param object_key: S3 object key
    :return: Presigned URL as string. If error, returns None.
    """
    try:
        response = s3_client.generate_presigned_url(
            'get_object',
            Params={
                'Bucket': settings.S3_BUCKET_NAME,
                'Key': object_key
            },
            ExpiresIn=settings.S3_PRESIGNED_URL_EXPIRATION_SECONDS
        )
    except ClientError as e:
        logger.error(f"Failed to generate presigned URL for key {object_key}: {e}")
        return None
    return response


# /db/crud.py

from sqlalchemy.orm import Session
from typing import Optional
import uuid
import hashlib

from . import models
from api.schemas import user as user_schemas
from core.security import get_password_hash

def get_patient_by_id(db: Session, patient_id: int) -> Optional[models.Patient]:
    return db.query(models.Patient).filter(models.Patient.id == patient_id).first()

def get_document_by_id(db: Session, document_id: int) -> Optional[models.ClinicalDocument]:
    return db.query(models.ClinicalDocument).filter(models.ClinicalDocument.id == document_id).first()

def create_clinical_document(
    db: Session,
    *,
    patient_id: int,
    uploader_id: int,
    document_name: str,
    document_type: str,
    file_hash: str,
) -> models.ClinicalDocument:
    s3_object_key = f"patients/{patient_id}/documents/{uuid.uuid4()}_{document_name}"
    
    db_document = models.ClinicalDocument(
        patient_id=patient_id,
        uploader_id=uploader_id,
        document_name=document_name,
        document_type=document_type,
        s3_object_key=s3_object_key,
        file_hash_sha256=file_hash,
    )
    db.add(db_document)
    db.commit()
    db.refresh(db_document)
    return db_document

def create_user(db: Session, user: user_schemas.UserCreate) -> models.User:
    hashed_password = get_password_hash(user.password)
    db_user = models.User(
        username=user.username,
        full_name=user.full_name,
        hashed_password=hashed_password,
        role=user.role,
        is_active=1
    )
    db.add(db_user)
    db.commit()
    db.refresh(db_user)
    return db_user

def get_file_sha256_hash(file: UploadFile) -> str:
    """Calculates SHA256 hash of a file without loading it all into memory."""
    hash_sha256 = hashlib.sha256()
    file.file.seek(0)
    for chunk in iter(lambda: file.file.read(4096), b""):
        hash_sha256.update(chunk)
    file.file.seek(0)
    return hash_sha256.hexdigest()

# /api/v1/endpoints/clinical_documents.py

from fastapi import APIRouter, Depends, HTTPException, status, UploadFile, File, Form, Request
from sqlalchemy.orm import Session
from typing import List

from db import session, crud, models
from core.security import RoleRequired
from services import s3_service, audit_service
from db.models import AuditLogAction, AuditLogStatus
from api.schemas.clinical_document import ClinicalDocumentMetadata, ClinicalDocumentResponse

router = APIRouter()

# Role-based access control dependencies
doctor_only = RoleRequired(["doctor"])
clinical_staff = RoleRequired(["doctor", "nurse"])

MAX_FILE_SIZE = 10 * 1024 * 1024  # 10 MB
ALLOWED_MIME_TYPES = ["application/pdf", "image/jpeg", "image/png"]

@router.post(
    "/patients/{patient_id}/documents",
    response_model=ClinicalDocumentMetadata,
    status_code=status.HTTP_201_CREATED,
    summary="Upload a Clinical Document",
    tags=["Clinical Documents"]
)
def upload_document(
    request: Request,
    patient_id: int,
    file: UploadFile = File(..., description="The clinical document to upload (PDF, JPEG, PNG). Max 10MB."),
    document_type: str = Form(..., description="Type of document, e.g., 'LAB_RESULT'"),
    db: Session = Depends(session.get_db),
    current_user: models.User = Depends(doctor_only),
):
    """
    Uploads a clinical document for a specific patient.

    - **Access**: Doctors only.
    - **Security**: File is stored in an encrypted S3 bucket.
    - **Auditing**: All upload attempts are logged.
    """
    patient = crud.get_patient_by_id(db, patient_id)
    if not patient:
        audit_service.create_audit_log(
            db, user_id=current_user.id, action=AuditLogAction.RESOURCE_NOT_FOUND,
            status=AuditLogStatus.FAILURE, ip_address=request.client.host,
            details={"resource_type": "Patient", "resource_id": patient_id}
        )
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Patient not found")

    if file.content_type not in ALLOWED_MIME_TYPES:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Invalid file type")
    
    if file.size > MAX_FILE_SIZE:
        raise HTTPException(status_code=status.HTTP_413_REQUEST_ENTITY_TOO_LARGE, detail="File size exceeds 10MB limit")

    file_hash = crud.get_file_sha256_hash(file)
    
    db_document = crud.create_clinical_document(
        db=db,
        patient_id=patient_id,
        uploader_id=current_user.id,
        document_name=file.filename,
        document_type=document_type,
        file_hash=file_hash
    )

    if not s3_service.upload_file_to_s3(file, db_document.s3_object_key):
        # Rollback database transaction if S3 upload fails
        db.delete(db_document)
        db.commit()
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Could not upload file to storage.")

    audit_service.create_audit_log(
        db, user_id=current_user.id, action=AuditLogAction.DOCUMENT_UPLOAD,
        status=AuditLogStatus.SUCCESS, ip_address=request.client.host,
        resource_type="ClinicalDocument", resource_id=db_document.id,
        details={"patient_id": patient_id, "filename": file.filename}
    )

    return db_document


@router.get(
    "/patients/{patient_id}/documents/{document_id}",
    response_model=ClinicalDocumentResponse,
    summary="Retrieve a Clinical Document",
    tags=["Clinical Documents"]
)
def get_document(
    request: Request,
    patient_id: int,
    document_id: int,
    db: Session = Depends(session.get_db),
    current_user: models.User = Depends(clinical_staff),
):
    """
    Retrieves metadata and a secure, time-limited download URL for a clinical document.

    - **Access**: Doctors and Nurses.
    - **Security**: Returns a presigned S3 URL, not the raw file.
    - **Auditing**: All access attempts are logged.
    """
    document = crud.get_document_by_id(db, document_id)

    if not document or document.patient_id != patient_id:
        audit_service.create_audit_log(
            db, user_id=current_user.id, action=AuditLogAction.RESOURCE_NOT_FOUND,
            status=AuditLogStatus.FAILURE, ip_address=request.client.host,
            details={"resource_type": "ClinicalDocument", "resource_id": document_id, "patient_id": patient_id}
        )
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Document not found for this patient")

    download_url = s3_service.create_presigned_url(document.s3_object_key)
    if not download_url:
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="Could not generate download link.")

    audit_service.create_audit_log(
        db, user_id=current_user.id, action=AuditLogAction.DOCUMENT_VIEW,
        status=AuditLogStatus.SUCCESS, ip_address=request.client.host,
        resource_type="ClinicalDocument", resource_id=document.id,
        details={"patient_id": patient_id}
    )

    return ClinicalDocumentResponse(
        **document.__dict__,
        download_url=download_url
    )

# /api/v1/endpoints/users.py

from fastapi import APIRouter, Depends, HTTPException, status, Request
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session

from db import session, crud, models
from core import security
from services import audit_service
from db.models import AuditLogAction, AuditLogStatus
from api.schemas import user as user_schemas

router = APIRouter()

@router.post("/token", response_model=user_schemas.Token, tags=["Authentication"])
def login_for_access_token(
    request: Request,
    db: Session = Depends(session.get_db),
    form_data: OAuth2PasswordRequestForm = Depends()
):
    """
    OAuth2 compatible token login, get an access token for future requests.
    """
    user = security.get_user(db, username=form_data.username)
    user_id_for_audit = user.id if user else None
    
    if not user or not security.verify_password(form_data.password, user.hashed_password):
        audit_service.create_audit_log(
            db, user_id=user_id_for_audit, action=AuditLogAction.LOGIN_FAILURE,
            status=AuditLogStatus.FAILURE, ip_address=request.client.host,
            details={"username": form_data.username}
        )
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token = security.create_access_token(data={"sub": user.username})
    
    audit_service.create_audit_log(
        db, user_id=user.id, action=AuditLogAction.LOGIN_SUCCESS,
        status=AuditLogStatus.SUCCESS, ip_address=request.client.host
    )
    
    return {"access_token": access_token, "token_type": "bearer"}


# /api/v1/api.py

from fastapi import APIRouter
from api.v1.endpoints import clinical_documents, users

api_router = APIRouter()
api_router.include_router(users.router, prefix="/users", tags=["Users"])
api_router.include_router(clinical_documents.router, tags=["Clinical Documents"])

# /main.py

from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from sqlalchemy.exc import SQLAlchemyError
import logging

from core.config import settings
from api.v1.api import api_router
from db.session import engine
from db import models

# Create all database tables on startup if they don't exist
# In a production environment, use Alembic for migrations instead.
models.Base.metadata.create_all(bind=engine)

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_STR}/openapi.json",
    docs_url="/docs",
    redoc_url="/redoc"
)

# Exception handler for unhandled errors to prevent information leakage
@app.exception_handler(Exception)
async def unhandled_exception_handler(request: Request, exc: Exception):
    logger.error(f"Unhandled exception for {request.method} {request.url}: {exc}", exc_info=True)
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={"detail": "An internal server error occurred. This incident has been logged."},
    )

# Exception handler for database errors
@app.exception_handler(SQLAlchemyError)
async def sqlalchemy_exception_handler(request: Request, exc: SQLAlchemyError):
    logger.error(f"Database error for {request.method} {request.url}: {exc}", exc_info=True)
    return JSONResponse(
        status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
        content={"detail": "A database error occurred. Please try again later."},
    )

app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/", include_in_schema=False)
def read_root():
    return {"status": "EMR Service is running."}

# To run this application:
# 1. Install dependencies:
#    pip install fastapi uvicorn pydantic pydantic-settings sqlalchemy psycopg2-binary passlib[bcrypt] python-jose[cryptography] python-multipart boto3
# 2. Set up a PostgreSQL database and configure the DATABASE_URL environment variable.
# 3. Configure AWS credentials and S3 bucket name in environment variables.
# 4. Run the server: uvicorn main:app --reload
```