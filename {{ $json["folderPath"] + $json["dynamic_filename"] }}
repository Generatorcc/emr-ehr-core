```python
# /config.py
# Description: Manages environment-specific application settings.

import os
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    """
    Application settings loaded from environment variables.
    """
    # Security
    SECRET_KEY: str = os.environ.get("SECRET_KEY", "a_very_secret_key_for_development_only")
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60

    # Database
    # Example: postgresql+asyncpg://user:password@host:port/dbname
    DATABASE_URL: str = os.environ.get("DATABASE_URL", "postgresql+asyncpg://emr_user:emr_pass@localhost/emr_db")

    class Config:
        case_sensitive = True

settings = Settings()

# /database.py
# Description: Handles database connections and session management.

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from config import settings

engine = create_async_engine(
    settings.DATABASE_URL,
    future=True,
    echo=False,  # Set to True for debugging SQL statements
    pool_pre_ping=True,
    pool_recycle=3600
)

AsyncSessionFactory = sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False,
    autoflush=False
)

Base = declarative_base()

# Dependency to get a database session
async def get_db_session() -> AsyncSession:
    """
    Yields a new database session for a single request.
    """
    async with AsyncSessionFactory() as session:
        try:
            yield session
        finally:
            await session.close()


# /models.py
# Description: Defines SQLAlchemy ORM models for database tables.

import uuid
from sqlalchemy import (
    Column, String, Integer, DateTime, Boolean, ForeignKey, JSON, Enum as SQLAlchemyEnum
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.sql import func
from database import Base
import enum

class AuditLogAction(str, enum.Enum):
    ACCESS_PHI = "ACCESS_PHI"
    CREATE = "CREATE"
    UPDATE = "UPDATE"
    DELETE = "DELETE"
    LOGIN_SUCCESS = "LOGIN_SUCCESS"
    LOGIN_FAIL = "LOGIN_FAIL"

class AuditLogOutcome(str, enum.Enum):
    SUCCESS = "SUCCESS"
    FAILURE = "FAILURE"

class AuditLog(Base):
    __tablename__ = 'audit_log'
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    timestamp = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    user_id = Column(UUID(as_uuid=True), nullable=False, index=True)
    user_ip_address = Column(String(45), nullable=False)
    action = Column(SQLAlchemyEnum(AuditLogAction), nullable=False)
    outcome = Column(SQLAlchemyEnum(AuditLogOutcome), nullable=False)
    target_resource_type = Column(String(100), nullable=True)
    target_resource_id = Column(String(255), nullable=True, index=True)
    details = Column(JSON, nullable=True) # Contains contextual information, e.g., patient_id accessed

class User(Base):
    __tablename__ = 'users'
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, nullable=False)
    role = Column(String, nullable=False) # e.g., 'physician', 'nurse', 'admin'
    is_active = Column(Boolean, default=True, nullable=False)

class Patient(Base):
    __tablename__ = 'patients'
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    # De-identified fields for general reference. PHI is encrypted or managed separately.
    mrn_hash = Column(String(256), unique=True, index=True, nullable=False) # Hash of Medical Record Number
    date_of_birth = Column(DateTime, nullable=False)

class LabPanel(Base):
    __tablename__ = 'lab_panels'
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    patient_id = Column(UUID(as_uuid=True), ForeignKey('patients.id'), nullable=False, index=True)
    panel_name = Column(String, nullable=False) # e.g., "Complete Blood Count"
    collection_datetime = Column(DateTime(timezone=True), nullable=False)
    reporting_physician_id = Column(UUID(as_uuid=True), ForeignKey('users.id'), nullable=False)

class LabResult(Base):
    __tablename__ = 'lab_results'
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    lab_panel_id = Column(UUID(as_uuid=True), ForeignKey('lab_panels.id'), nullable=False, index=True)
    test_name = Column(String, nullable=False) # e.g., "Hemoglobin"
    value = Column(String, nullable=False) # String to accommodate various result types
    units = Column(String, nullable=True)
    reference_range = Column(String, nullable=True)
    is_abnormal = Column(Boolean, default=False, nullable=False)

# /schemas.py
# Description: Pydantic models for data validation and serialization.

import uuid
from pydantic import BaseModel, Field
from datetime import datetime
from typing import List, Optional

# --- User & Auth Schemas ---

class TokenData(BaseModel):
    user_id: uuid.UUID

class User(BaseModel):
    id: uuid.UUID
    username: str
    full_name: str
    role: str
    is_active: bool

    class Config:
        from_attributes = True

# --- Lab Result Schemas ---

class LabResultResponse(BaseModel):
    id: uuid.UUID
    test_name: str
    value: str
    units: Optional[str] = None
    reference_range: Optional[str] = None
    is_abnormal: bool

    class Config:
        from_attributes = True

class LabPanelResponse(BaseModel):
    id: uuid.UUID
    patient_id: uuid.UUID
    panel_name: str
    collection_datetime: datetime
    reporting_physician_id: uuid.UUID
    results: List[LabResultResponse]

    class Config:
        from_attributes = True

# --- Audit Log Schemas ---

class AuditLogIn(BaseModel):
    user_id: uuid.UUID
    user_ip_address: str
    action: str
    outcome: str
    target_resource_type: Optional[str] = None
    target_resource_id: Optional[str] = None
    details: Optional[dict] = None

# /security.py
# Description: Handles authentication, authorization, and password management.

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from pydantic import ValidationError
import uuid

from config import settings
from database import get_db_session
from models import User as UserModel
from schemas import TokenData, User as UserSchema

oauth2_scheme = OAuth2PasswordBearer(tokenUrl="token")

async def get_current_user(
    token: str = Depends(oauth2_scheme),
    db: AsyncSession = Depends(get_db_session)
) -> UserSchema:
    """
    Decodes JWT token, validates user, and returns user data.
    """
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id_str = payload.get("sub")
        if user_id_str is None:
            raise credentials_exception
        token_data = TokenData(user_id=uuid.UUID(user_id_str))
    except (JWTError, ValidationError):
        raise credentials_exception

    result = await db.execute(select(UserModel).where(UserModel.id == token_data.user_id))
    user = result.scalar_one_or_none()

    if user is None:
        raise credentials_exception

    return UserSchema.from_orm(user)

async def get_current_active_user(current_user: UserSchema = Depends(get_current_user)) -> UserSchema:
    """
    Ensures the user retrieved from the token is currently active.
    """
    if not current_user.is_active:
        raise HTTPException(status_code=status.HTTP_403_FORBIDDEN, detail="Inactive user")
    return current_user

# /utils/audit.py
# Description: Centralized service for creating audit log entries.

from sqlalchemy.ext.asyncio import AsyncSession
from models import AuditLog, AuditLogAction, AuditLogOutcome
from schemas import AuditLogIn

async def create_audit_log(db: AsyncSession, log_entry: AuditLogIn):
    """
    Creates and saves a new audit log record to the database.
    """
    db_log = AuditLog(
        user_id=log_entry.user_id,
        user_ip_address=log_entry.user_ip_address,
        action=AuditLogAction[log_entry.action],
        outcome=AuditLogOutcome[log_entry.outcome],
        target_resource_type=log_entry.target_resource_type,
        target_resource_id=log_entry.target_resource_id,
        details=log_entry.details
    )
    db.add(db_log)
    await db.commit()
    await db.refresh(db_log)


# /crud/labs.py
# Description: Data access layer functions for lab results.

import uuid
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from sqlalchemy.orm import selectinload
from typing import Optional

from models import LabPanel, User, Patient

async def get_lab_panel_by_id(db: AsyncSession, panel_id: uuid.UUID) -> Optional[LabPanel]:
    """

    Retrieves a single lab panel and all its associated results.
    """
    result = await db.execute(
        select(LabPanel)
        .where(LabPanel.id == panel_id)
        .options(selectinload(LabPanel.results))
    )
    return result.scalar_one_or_none()

async def verify_user_access_to_patient(db: AsyncSession, user_id: uuid.UUID, patient_id: uuid.UUID) -> bool:
    """
    Verifies if a user has a relationship with a patient granting access.
    This is a critical HIPAA control point. Logic here would be complex in a real system,
    e.g., checking care teams, primary care physician links, or consent directives.
    For this example, we'll use a simplified check.
    """
    # Placeholder Logic: A physician can access any patient's record.
    # A production system would have a granular patient-provider relationship table.
    user_result = await db.execute(select(User.role).where(User.id == user_id))
    user_role = user_result.scalar_one_or_none()

    if user_role == 'physician':
        patient_result = await db.execute(select(Patient).where(Patient.id == patient_id))
        if patient_result.scalar_one_or_none():
            return True

    return False

# /api/v1/endpoints/labs.py
# Description: API endpoint for retrieving patient lab results.

import uuid
from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.ext.asyncio import AsyncSession

from schemas import LabPanelResponse, User
from database import get_db_session
from security import get_current_active_user
from crud import labs as crud_labs
from utils.audit import create_audit_log
from schemas import AuditLogIn

router = APIRouter()

@router.get(
    "/patients/{patient_id}/lab-panels/{panel_id}",
    response_model=LabPanelResponse,
    summary="Get a specific lab result panel for a patient",
    description="Retrieves the full details of a single lab panel, including all individual test results. Access is restricted and audited.",
    tags=["Labs"],
    status_code=status.HTTP_200_OK
)
async def get_patient_lab_panel(
    request: Request,
    patient_id: uuid.UUID,
    panel_id: uuid.UUID,
    db: AsyncSession = Depends(get_db_session),
    current_user: User = Depends(get_current_active_user)
):
    """
    Securely fetches a patient's lab panel.

    - **Authentication**: Requires a valid JWT token.
    - **Authorization**: Verifies the logged-in user has rights to access the specified patient's data.
    - **Auditing**: Logs every access attempt, success or failure.
    - **Data Integrity**: Returns a structured, validated response model.
    """
    # 1. Authorization Check
    has_access = await crud_labs.verify_user_access_to_patient(db, user_id=current_user.id, patient_id=patient_id)
    if not has_access:
        # Audit the failed access attempt
        await create_audit_log(db, AuditLogIn(
            user_id=current_user.id,
            user_ip_address=request.client.host,
            action="ACCESS_PHI",
            outcome="FAILURE",
            target_resource_type="LabPanel",
            target_resource_id=str(panel_id),
            details={"reason": "User not authorized for patient", "patient_id": str(patient_id)}
        ))
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User does not have permission to access this patient's records"
        )

    # 2. Data Retrieval
    lab_panel = await crud_labs.get_lab_panel_by_id(db, panel_id=panel_id)

    if not lab_panel or lab_panel.patient_id != patient_id:
        # Audit the failed access attempt
        await create_audit_log(db, AuditLogIn(
            user_id=current_user.id,
            user_ip_address=request.client.host,
            action="ACCESS_PHI",
            outcome="FAILURE",
            target_resource_type="LabPanel",
            target_resource_id=str(panel_id),
            details={"reason": "Lab panel not found for specified patient", "patient_id": str(patient_id)}
        ))
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Lab panel not found for this patient")

    # 3. Audit Successful Access
    await create_audit_log(db, AuditLogIn(
        user_id=current_user.id,
        user_ip_address=request.client.host,
        action="ACCESS_PHI",
        outcome="SUCCESS",
        target_resource_type="LabPanel",
        target_resource_id=str(panel_id),
        details={"patient_id": str(patient_id)}
    ))

    # 4. Return Structured Data
    return lab_panel

# /api/v1/api.py
# Description: Aggregates all API routers for version 1.

from fastapi import APIRouter
from api.v1.endpoints import labs

api_router = APIRouter()
api_router.include_router(labs.router, prefix="/labs")


# /main.py
# Description: Main application entry point.

from fastapi import FastAPI, Request, status
from fastapi.responses import JSONResponse
from fastapi.exceptions import RequestValidationError
from sqlalchemy.exc import SQLAlchemyError

from api.v1.api import api_router
from database import Base, engine

app = FastAPI(
    title="EMR Core Services API",
    description="Backend services for a HIPAA-compliant Electronic Medical Record system.",
    version="1.0.0",
    redoc_url=None, # Disable ReDoc in production
    # swagger_ui_oauth2_redirect_url="/docs/oauth2-redirect" # Uncomment if using Swagger UI with OAuth2
)

@app.on_event("startup")
async def startup_event():
    # This is for demonstration. In production, use Alembic for migrations.
    async with engine.begin() as conn:
        # await conn.run_sync(Base.metadata.drop_all) # Use for clean slate testing
        await conn.run_sync(Base.metadata.create_all)

# Global exception handlers
@app.exception_handler(SQLAlchemyError)
async def sqlalchemy_exception_handler(request: Request, exc: SQLAlchemyError):
    # Log the full exception for internal review
    # logger.error(f"Database error on request {request.url}: {exc}")
    return JSONResponse(
        status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
        content={"detail": "An internal database error occurred."},
    )

@app.exception_handler(RequestValidationError)
async def validation_exception_handler(request: Request, exc: RequestValidationError):
    return JSONResponse(
        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
        content={"detail": exc.errors()},
    )

app.include_router(api_router, prefix="/api/v1")

@app.get("/health", status_code=status.HTTP_200_OK, tags=["System"])
async def health_check():
    """
    System health check endpoint.
    """
    return {"status": "ok"}
```