```python
# === FILENAME: core/config.py ===
import os
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    """
    Application settings loaded from environment variables.
    """
    # Security
    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60

    # Database
    DATABASE_URL: str

    # S3 (for potential future use with attachments)
    S3_BUCKET_NAME: str
    S3_ACCESS_KEY: str
    S3_SECRET_KEY: str
    S3_REGION: str

    class Config:
        env_file = ".env"
        env_file_encoding = 'utf-8'

settings = Settings()

# === FILENAME: db/session.py ===
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker, Session
from core.config import settings

# The `connect_args` are for SQLite, which is not used in production.
# For PostgreSQL, these are not needed.
# For production PostgreSQL:
# engine = create_engine(settings.DATABASE_URL)
engine = create_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True
)

SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def get_db():
    """
    FastAPI dependency to get a database session.
    Ensures the session is closed after the request is finished.
    """
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()

# === FILENAME: db/base.py ===
from sqlalchemy.orm import DeclarativeBase
from sqlalchemy import MetaData

# Recommended naming convention for SQLAlchemy 2.0
# See: https://docs.sqlalchemy.org/en/20/orm/declarative_styles.html#creating-a-declarative-base
class Base(DeclarativeBase):
    metadata = MetaData()


# === FILENAME: db/models.py ===
import uuid
from sqlalchemy import (
    Column, String, Boolean, DateTime, ForeignKey, Text, JSON, Enum as SQLAlchemyEnum
)
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
import enum

from db.base import Base

class UserRole(enum.Enum):
    CLINICIAN = "clinician"
    ADMIN = "admin"
    READ_ONLY = "read_only"

class AuditAction(enum.Enum):
    CREATE_CLINICAL_NOTE = "CREATE_CLINICAL_NOTE"
    VIEW_CLINICAL_NOTE = "VIEW_CLINICAL_NOTE"
    UPDATE_CLINICAL_NOTE = "UPDATE_CLINICAL_NOTE"
    DELETE_CLINICAL_NOTE = "DELETE_CLINICAL_NOTE"
    PATIENT_RECORD_VIEW = "PATIENT_RECORD_VIEW"
    LOGIN_SUCCESS = "LOGIN_SUCCESS"
    LOGIN_FAILURE = "LOGIN_FAILURE"

class User(Base):
    __tablename__ = "users"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    username = Column(String(255), unique=True, index=True, nullable=False)
    hashed_password = Column(String(255), nullable=False)
    full_name = Column(String(255), nullable=False)
    role = Column(SQLAlchemyEnum(UserRole), nullable=False)
    is_active = Column(Boolean, default=True)

    authored_notes = relationship("ClinicalNote", back_populates="author")
    audit_logs = relationship("AuditLog", back_populates="user")

class Patient(Base):
    __tablename__ = "patients"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    mrn = Column(String(50), unique=True, index=True, nullable=False) # Medical Record Number
    full_name = Column(String(255), nullable=False)
    date_of_birth = Column(DateTime, nullable=False)
    
    clinical_notes = relationship("ClinicalNote", back_populates="patient", cascade="all, delete-orphan")

class ClinicalNote(Base):
    __tablename__ = "clinical_notes"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    patient_id = Column(UUID(as_uuid=True), ForeignKey("patients.id"), nullable=False, index=True)
    author_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False, index=True)
    
    content = Column(Text, nullable=False) # Assumes DB field-level encryption is configured
    note_type = Column(String(100), nullable=False, default="Progress Note") # e.g., SOAP, Progress, Discharge
    
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())
    signed_at = Column(DateTime(timezone=True), nullable=True) # For clinical signature workflows

    patient = relationship("Patient", back_populates="clinical_notes")
    author = relationship("User", back_populates="authored_notes")

class AuditLog(Base):
    __tablename__ = "audit_logs"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=True) # Nullable for system events
    action = Column(SQLAlchemyEnum(AuditAction), nullable=False)
    timestamp = Column(DateTime(timezone=True), server_default=func.now(), nullable=False)
    
    resource_type = Column(String(100), nullable=True)
    resource_id = Column(UUID(as_uuid=True), nullable=True)
    
    details = Column(JSON, nullable=True) # e.g., {"ip_address": "1.2.3.4", "user_agent": "..."}

    user = relationship("User", back_populates="audit_logs")


# === FILENAME: schemas/token.py ===
from pydantic import BaseModel
import uuid

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    user_id: uuid.UUID | None = None


# === FILENAME: schemas/user.py ===
from pydantic import BaseModel
import uuid
from db.models import UserRole

class UserBase(BaseModel):
    username: str
    full_name: str

class UserInDB(UserBase):
    id: uuid.UUID
    role: UserRole
    is_active: bool

    class Config:
        from_attributes = True


# === FILENAME: schemas/clinical_note.py ===
from pydantic import BaseModel, Field
import uuid
from datetime import datetime

class ClinicalNoteBase(BaseModel):
    note_type: str = Field(..., max_length=100, examples=["Progress Note"])
    content: str = Field(..., min_length=10)

class ClinicalNoteCreate(ClinicalNoteBase):
    pass

class ClinicalNoteResponse(ClinicalNoteBase):
    id: uuid.UUID
    patient_id: uuid.UUID
    author_id: uuid.UUID
    created_at: datetime
    updated_at: datetime | None = None
    signed_at: datetime | None = None

    class Config:
        from_attributes = True


# === FILENAME: core/security.py ===
from datetime import datetime, timedelta, timezone
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext
from sqlalchemy.orm import Session
import uuid

from core.config import settings
from db import models, session
from schemas import token as token_schema
from schemas import user as user_schema

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/v1/auth/token")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: timedelta | None = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def get_user(db: Session, user_id: uuid.UUID) -> models.User | None:
    return db.query(models.User).filter(models.User.id == user_id).first()

def get_current_user(
    db: Session = Depends(session.get_db), token: str = Depends(oauth2_scheme)
) -> models.User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id_str: str | None = payload.get("sub")
        if user_id_str is None:
            raise credentials_exception
        
        user_id = uuid.UUID(user_id_str)
        token_data = token_schema.TokenData(user_id=user_id)
    except (JWTError, ValueError):
        raise credentials_exception
    
    user = get_user(db, user_id=token_data.user_id)
    if user is None:
        raise credentials_exception
    return user

def get_current_active_user(
    current_user: models.User = Depends(get_current_user)
) -> models.User:
    if not current_user.is_active:
        raise HTTPException(status_code=400, detail="Inactive user")
    return current_user


# === FILENAME: db/crud_audit.py ===
from sqlalchemy.orm import Session
from db import models
from db.models import AuditAction
import uuid

def create_audit_log(
    db: Session,
    *,
    user_id: uuid.UUID,
    action: AuditAction,
    resource_type: str | None = None,
    resource_id: uuid.UUID | None = None,
    details: dict | None = None,
) -> models.AuditLog:
    db_obj = models.AuditLog(
        user_id=user_id,
        action=action,
        resource_type=resource_type,
        resource_id=resource_id,
        details=details
    )
    db.add(db_obj)
    db.commit()
    db.refresh(db_obj)
    return db_obj


# === FILENAME: db/crud_patient.py ===
from sqlalchemy.orm import Session
from db import models
import uuid

def get_patient(db: Session, patient_id: uuid.UUID) -> models.Patient | None:
    return db.query(models.Patient).filter(models.Patient.id == patient_id).first()

def check_user_patient_access(db: Session, *, user: models.User, patient_id: uuid.UUID) -> bool:
    """
    HIPAA Security: Checks if a user is authorized to access a patient's record.
    In a real system, this would query a complex authorization model
    (e.g., CareTeam assignments, patient-provider relationships).
    For this example, we'll allow access if the user is a 'clinician' and the patient exists.
    """
    if user.role != models.UserRole.CLINICIAN:
        return False
    
    patient = get_patient(db=db, patient_id=patient_id)
    if not patient:
        return False
    
    # Placeholder for real authorization logic.
    # e.g., return db.query(CareTeam).filter(CareTeam.patient_id == patient_id, CareTeam.user_id == user.id).first() is not None
    return True


# === FILENAME: db/crud_clinical_note.py ===
from sqlalchemy.orm import Session
from schemas import clinical_note as note_schema
from db import models
import uuid

def create_clinical_note(
    db: Session, *, note_in: note_schema.ClinicalNoteCreate, patient_id: uuid.UUID, author_id: uuid.UUID
) -> models.ClinicalNote:
    db_obj = models.ClinicalNote(
        **note_in.model_dump(),
        author_id=author_id,
        patient_id=patient_id
    )
    db.add(db_obj)
    db.commit()
    db.refresh(db_obj)
    return db_obj


# === FILENAME: api/v1/endpoints/clinical_notes.py ===
from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.orm import Session
import uuid

from db import session, models
from db.models import AuditAction
from db import crud_audit, crud_clinical_note, crud_patient
from schemas import clinical_note as note_schema
from core.security import get_current_active_user

router = APIRouter()

@router.post(
    "/patients/{patient_id}/notes",
    response_model=note_schema.ClinicalNoteResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Create a Clinical Note",
    description="Creates a new clinical note for a specified patient. Requires clinician role.",
    tags=["Clinical Notes"],
)
def create_clinical_note_for_patient(
    *,
    request: Request,
    patient_id: uuid.UUID,
    note_in: note_schema.ClinicalNoteCreate,
    db: Session = Depends(session.get_db),
    current_user: models.User = Depends(get_current_active_user),
):
    """
    Create a new clinical note associated with a patient.

    **HIPAA Compliance Checks:**
    1.  **Authentication**: Verified by `get_current_active_user` dependency.
    2.  **Authorization**: Explicitly checks if the authenticated user has rights
        to access the given `patient_id`'s record.
    3.  **Auditing**: Creates an audit log entry for the creation event.
    """
    # Authorization check: Does this user have the right to create a note for this patient?
    is_authorized = crud_patient.check_user_patient_access(db=db, user=current_user, patient_id=patient_id)
    if not is_authorized:
        # Note: Use 404 instead of 403 to prevent attackers from discovering valid patient IDs.
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Patient not found or access denied.",
        )

    # Proceed with creation if authorized
    note = crud_clinical_note.create_clinical_note(
        db=db, note_in=note_in, patient_id=patient_id, author_id=current_user.id
    )

    # Create an audit log for this PHI creation event
    crud_audit.create_audit_log(
        db=db,
        user_id=current_user.id,
        action=AuditAction.CREATE_CLINICAL_NOTE,
        resource_type="ClinicalNote",
        resource_id=note.id,
        details={"client_host": request.client.host, "patient_id": str(patient_id)}
    )

    return note


# === FILENAME: api/v1/api.py ===
from fastapi import APIRouter
from api.v1.endpoints import clinical_notes

api_router = APIRouter()
api_router.include_router(clinical_notes.router, prefix="/v1")


# === FILENAME: main.py ===
from fastapi import FastAPI
from api.v1.api import api_router
from db.base import Base
from db.session import engine

# This command should be run once via a migration tool like Alembic in production.
# For demonstration, we create tables on startup.
def create_tables():
    Base.metadata.create_all(bind=engine)

app = FastAPI(
    title="Secure EMR API",
    description="A production-grade, HIPAA-compliant EMR backend.",
    version="1.0.0",
    openapi_url="/api/v1/openapi.json",
    docs_url="/api/docs",
    redoc_url="/api/redoc"
)

# Uncomment the line below for a real deployment if not using a migration tool for setup
# create_tables()

app.include_router(api_router, prefix="/api")

@app.get("/", include_in_schema=False)
def read_root():
    return {"status": "EMR Backend Service is running"}

```