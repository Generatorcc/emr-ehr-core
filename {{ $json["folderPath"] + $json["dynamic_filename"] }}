```python
# /core/config.py

import os
from pydantic_settings import BaseSettings
from functools import lru_cache

class Settings(BaseSettings):
    """
    Application settings loaded from environment variables.
    """
    # Application
    PROJECT_NAME: str = "EMR Backend System"
    API_V1_STR: str = "/api/v1"

    # Security
    # In a real production environment, use a key management service (e.g., AWS KMS, Azure Key Vault)
    # openssl rand -hex 32
    SECRET_KEY: str
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60

    # Database
    DATABASE_URL: str

    # AWS S3 for document storage
    S3_BUCKET_NAME: str
    S3_ACCESS_KEY_ID: str
    S3_SECRET_ACCESS_KEY: str
    S3_REGION: str = "us-east-1"

    class Config:
        env_file = ".env"
        env_file_encoding = 'utf-8'

@lru_cache()
def get_settings():
    return Settings()

# ---
# /db/session.py

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker
from core.config import get_settings

settings = get_settings()

engine = create_async_engine(settings.DATABASE_URL, pool_pre_ping=True, echo=False)
AsyncSessionLocal = sessionmaker(
    engine, class_=AsyncSession, expire_on_commit=False
)

async def get_db() -> AsyncSession:
    """
    FastAPI dependency that provides a database session.
    """
    async with AsyncSessionLocal() as session:
        yield session

# ---
# /db/base.py

from sqlalchemy.ext.declarative import declarative_base

Base = declarative_base()

# ---
# /db/models.py

import uuid
from sqlalchemy import (
    Column, Integer, String, DateTime, ForeignKey, Boolean, Enum as SQLAlchemyEnum
)
from sqlalchemy.dialects.postgresql import UUID, JSONB
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
from enum import Enum
from .base import Base

class UserRole(str, Enum):
    PHYSICIAN = "physician"
    NURSE = "nurse"
    ADMIN = "admin"
    PATIENT = "patient"

class User(Base):
    __tablename__ = "users"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    email = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, index=True, nullable=False)
    role = Column(SQLAlchemyEnum(UserRole), nullable=False)
    is_active = Column(Boolean(), default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), onupdate=func.now())

    audit_logs = relationship("AuditLog", back_populates="user")

class Patient(Base):
    __tablename__ = "patients"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    first_name = Column(String, nullable=False)
    last_name = Column(String, nullable=False)
    date_of_birth = Column(DateTime(timezone=True), nullable=False)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

    documents = relationship("Document", back_populates="patient")

class PatientProviderAssociation(Base):
    __tablename__ = "patient_provider_associations"
    patient_id = Column(UUID(as_uuid=True), ForeignKey("patients.id"), primary_key=True)
    provider_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), primary_key=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())

class Document(Base):
    __tablename__ = "documents"
    id = Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    patient_id = Column(UUID(as_uuid=True), ForeignKey("patients.id"), nullable=False, index=True)
    uploader_user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    s3_bucket = Column(String, nullable=False)
    s3_key = Column(String, nullable=False, unique=True)
    file_name = Column(String, nullable=False)
    file_type = Column(String, nullable=False)
    file_hash_sha256 = Column(String, nullable=False)
    document_type = Column(String, nullable=False, index=True)
    upload_timestamp = Column(DateTime(timezone=True), server_default=func.now())

    patient = relationship("Patient", back_populates="documents")
    uploader = relationship("User")

class AuditLog(Base):
    __tablename__ = "audit_logs"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(UUID(as_uuid=True), ForeignKey("users.id"), nullable=False)
    action = Column(String, nullable=False, index=True)
    target_resource_type = Column(String, nullable=True)
    target_resource_id = Column(String, nullable=True)
    timestamp = Column(DateTime(timezone=True), server_default=func.now())
    details = Column(JSONB) # Store context like IP address, user agent, etc.

    user = relationship("User", back_populates="audit_logs")

# ---
# /schemas/token.py

from pydantic import BaseModel
from typing import Optional
from uuid import UUID

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    user_id: Optional[UUID] = None

# ---
# /schemas/user.py

from pydantic import BaseModel, EmailStr
from uuid import UUID
from datetime import datetime
from db.models import UserRole

class UserBase(BaseModel):
    email: EmailStr
    full_name: str
    role: UserRole

class UserInDB(UserBase):
    id: UUID
    is_active: bool
    created_at: datetime

    class Config:
        orm_mode = True

# ---
# /schemas/document.py

from pydantic import BaseModel
from uuid import UUID
from datetime import datetime

class DocumentResponse(BaseModel):
    id: UUID
    patient_id: UUID
    uploader_user_id: UUID
    file_name: str
    document_type: str
    upload_timestamp: datetime

    class Config:
        orm_mode = True

# ---
# /core/security.py

from datetime import datetime, timedelta
from typing import Optional
from uuid import UUID

from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from jose import JWTError, jwt
from passlib.context import CryptContext
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select

from core.config import get_settings
from db import models
from db.session import get_db
from schemas.token import TokenData
from schemas.user import UserInDB

settings = get_settings()

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{settings.API_V1_STR}/auth/token")

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    # Convert UUID to string for JWT payload
    if 'sub' in to_encode and isinstance(to_encode['sub'], UUID):
        to_encode['sub'] = str(to_encode['sub'])
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

async def get_user_by_id(db: AsyncSession, user_id: UUID) -> Optional[models.User]:
    result = await db.execute(select(models.User).filter(models.User.id == user_id))
    return result.scalars().first()

async def get_current_user(
    db: AsyncSession = Depends(get_db), token: str = Depends(oauth2_scheme)
) -> models.User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        user_id_str: str = payload.get("sub")
        if user_id_str is None:
            raise credentials_exception
        user_id = UUID(user_id_str)
        token_data = TokenData(user_id=user_id)
    except (JWTError, ValueError):
        raise credentials_exception
    
    user = await get_user_by_id(db, user_id=token_data.user_id)
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(
    current_user: models.User = Depends(get_current_user),
) -> models.User:
    if not current_user.is_active:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")
    return current_user

# ---
# /crud/audit_log.py

from sqlalchemy.ext.asyncio import AsyncSession
from uuid import UUID
from typing import Dict, Any

from db import models

async def create_audit_log_entry(
    db: AsyncSession,
    *,
    user_id: UUID,
    action: str,
    target_resource_type: str,
    target_resource_id: str,
    details: Dict[str, Any]
) -> models.AuditLog:
    """
    Creates a new audit log entry in the database.
    """
    audit_log = models.AuditLog(
        user_id=user_id,
        action=action,
        target_resource_type=target_resource_type,
        target_resource_id=target_resource_id,
        details=details
    )
    db.add(audit_log)
    await db.commit()
    await db.refresh(audit_log)
    return audit_log

# ---
# /crud/document.py

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from uuid import UUID

from db import models

async def create_document(
    db: AsyncSession,
    *,
    patient_id: UUID,
    uploader_user_id: UUID,
    s3_bucket: str,
    s3_key: str,
    file_name: str,
    file_type: str,
    file_hash_sha256: str,
    document_type: str
) -> models.Document:
    """
    Creates a new document metadata record in the database.
    """
    document = models.Document(
        patient_id=patient_id,
        uploader_user_id=uploader_user_id,
        s3_bucket=s3_bucket,
        s3_key=s3_key,
        file_name=file_name,
        file_type=file_type,
        file_hash_sha256=file_hash_sha256,
        document_type=document_type
    )
    db.add(document)
    await db.commit()
    await db.refresh(document)
    return document

async def check_provider_patient_relationship(
    db: AsyncSession, *, provider_id: UUID, patient_id: UUID
) -> bool:
    """
    Verifies if a provider is associated with a given patient.
    """
    query = select(models.PatientProviderAssociation).filter_by(
        provider_id=provider_id, patient_id=patient_id
    )
    result = await db.execute(query)
    return result.scalars().first() is not None

# ---
# /services/s3_service.py

import logging
import boto3
from botocore.exceptions import ClientError
from fastapi import UploadFile
from typing import BinaryIO

from core.config import get_settings

logger = logging.getLogger(__name__)
settings = get_settings()

class S3Service:
    def __init__(self):
        self.s3_client = boto3.client(
            "s3",
            aws_access_key_id=settings.S3_ACCESS_KEY_ID,
            aws_secret_access_key=settings.S3_SECRET_ACCESS_KEY,
            region_name=settings.S3_REGION,
        )
        self.bucket_name = settings.S3_BUCKET_NAME

    async def upload_file(self, file_obj: BinaryIO, object_name: str) -> bool:
        """
        Uploads a file to an S3 bucket with server-side encryption.
        """
        try:
            self.s3_client.upload_fileobj(
                file_obj,
                self.bucket_name,
                object_name,
                ExtraArgs={"ServerSideEncryption": "AES256"}
            )
        except ClientError as e:
            logger.error(f"S3 Upload Error: {e}")
            return False
        return True

s3_service = S3Service()

# ---
# /api/v1/endpoints/document_upload.py

import uuid
import hashlib
from fastapi import APIRouter, Depends, UploadFile, File, Form, HTTPException, status
from sqlalchemy.ext.asyncio import AsyncSession
from uuid import UUID

from db.session import get_db
from db import models
from core.security import get_current_active_user
from crud import document as crud_document, audit_log as crud_audit_log
from schemas.document import DocumentResponse
from services.s3_service import s3_service

router = APIRouter()

MAX_FILE_SIZE = 10 * 1024 * 1024  # 10 MB
ALLOWED_CONTENT_TYPES = ["application/pdf", "image/jpeg", "image/png", "text/plain"]

@router.post(
    "/patients/{patient_id}/documents",
    response_model=DocumentResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Upload a medical document for a patient",
    description="Uploads a document and associates it with a patient record. Requires authenticated provider with access to the patient.",
)
async def upload_document(
    patient_id: UUID,
    document_type: str = Form(..., description="Type of the document (e.g., 'Lab Report', 'Imaging Result')."),
    file: UploadFile = File(..., description="The medical document file to upload."),
    db: AsyncSession = Depends(get_db),
    current_user: models.User = Depends(get_current_active_user),
):
    """
    Handles the secure upload of a medical document.
    
    - **Authorization**: Verifies the uploading user is a provider associated with the patient.
    - **Validation**: Checks file size and content type.
    - **Integrity**: Calculates a SHA256 hash of the file.
    - **Storage**: Uploads the file to an encrypted S3 bucket.
    - **Auditing**: Logs the upload event for compliance.
    """
    if current_user.role not in [models.UserRole.PHYSICIAN, models.UserRole.NURSE]:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User does not have privileges to upload documents.",
        )

    is_authorized = await crud_document.check_provider_patient_relationship(
        db, provider_id=current_user.id, patient_id=patient_id
    )
    if not is_authorized:
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="User is not authorized to access this patient's records.",
        )

    if file.content_type not in ALLOWED_CONTENT_TYPES:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid file type. Allowed types are: {', '.join(ALLOWED_CONTENT_TYPES)}",
        )

    # Read file content and check size
    contents = await file.read()
    if len(contents) > MAX_FILE_SIZE:
        raise HTTPException(
            status_code=status.HTTP_413_REQUEST_ENTITY_TOO_LARGE,
            detail=f"File size exceeds the limit of {MAX_FILE_SIZE // 1024 // 1024} MB.",
        )
    await file.seek(0) # Reset file pointer after reading

    # Calculate file hash for integrity
    file_hash = hashlib.sha256(contents).hexdigest()

    # Generate a secure, unique key for S3
    s3_object_key = f"patients/{patient_id}/documents/{uuid.uuid4()}_{file.filename}"

    # Upload to S3
    upload_success = await s3_service.upload_file(file.file, s3_object_key)
    if not upload_success:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to upload document to storage.",
        )

    # Create document metadata in database
    db_document = await crud_document.create_document(
        db=db,
        patient_id=patient_id,
        uploader_user_id=current_user.id,
        s3_bucket=s3_service.bucket_name,
        s3_key=s3_object_key,
        file_name=file.filename,
        file_type=file.content_type,
        file_hash_sha256=file_hash,
        document_type=document_type,
    )
    
    # Create audit log entry
    await crud_audit_log.create_audit_log_entry(
        db=db,
        user_id=current_user.id,
        action="DOCUMENT_UPLOAD",
        target_resource_type="DOCUMENT",
        target_resource_id=str(db_document.id),
        details={
            "patient_id": str(patient_id),
            "filename": file.filename,
            "document_type": document_type,
            "s3_key": s3_object_key,
        },
    )

    return db_document

# ---
# /api/v1/api.py

from fastapi import APIRouter
from api.v1.endpoints import document_upload

api_router = APIRouter()
api_router.include_router(document_upload.router, prefix="/documents", tags=["Documents"])


# ---
# /main.py

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware
from core.config import get_settings
from api.v1.api import api_router

settings = get_settings()

app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_STR}/openapi.json",
    docs_url=f"{settings.API_V1_STR}/docs",
    redoc_url=None # Disable ReDoc
)

# Set all CORS enabled origins
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"], # In production, restrict this to your frontend domain
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/", include_in_schema=False)
def root():
    return {"message": "EMR Backend System is operational."}

# To run this application:
# 1. Create a .env file with the required settings (SECRET_KEY, DATABASE_URL, S3 keys).
# 2. Install dependencies: pip install "fastapi[all]" sqlalchemy asyncpg pydantic-settings python-jose "passlib[bcrypt]" boto3
# 3. Set up a PostgreSQL database and an S3 bucket.
# 4. Use alembic or another tool to create the database tables from /db/models.py.
# 5. Run with uvicorn: uvicorn main:app --reload
```