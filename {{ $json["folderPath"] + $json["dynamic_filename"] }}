```python
# main.py
# Main application entry point.
from fastapi import FastAPI, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.orm import Session
from datetime import timedelta

from api.v1.api import api_router
from core.config import settings
from db.session import get_db, engine
from db import base
from security import auth
from schemas.user import User
from schemas.token import Token
from crud import base as crud_base

# Create all database tables
base.Base.metadata.create_all(bind=engine)

app = FastAPI(
    title="EMR-Core API",
    description="Backend services for the National EMR Platform.",
    version="1.0.0",
    openapi_url=f"{settings.API_V1_STR}/openapi.json",
)

@app.post("/token", response_model=Token, tags=["Authentication"])
def login_for_access_token(
    db: Session = Depends(get_db),
    form_data: OAuth2PasswordRequestForm = Depends()
):
    """
    Standard OAuth2 password flow to obtain a JWT access token.
    """
    user = auth.authenticate_user(db, form_data.username, form_data.password)
    if not user:
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    if not user.is_active:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail="Inactive user"
        )
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = auth.create_access_token(
        data={"sub": user.username, "role": user.role},
        expires_delta=access_token_expires
    )
    return {"access_token": access_token, "token_type": "bearer"}


app.include_router(api_router, prefix=settings.API_V1_STR)

# /api/v1/api.py
# API router aggregator.
from fastapi import APIRouter
from api.v1.endpoints import notes

api_router = APIRouter()
api_router.include_router(notes.router, prefix="/records", tags=["Medical Records"])


# /api/v1/endpoints/notes.py
# Endpoint logic for accessing patient medical notes.
from fastapi import APIRouter, Depends, HTTPException, status, Request
from sqlalchemy.orm import Session

from db.session import get_db
from models.medical import User as UserModel
from schemas import note as note_schema
from schemas import audit as audit_schema
from crud import base as crud_base
from security.auth import get_current_active_user, UserRole

router = APIRouter()

@router.get(
    "/patients/{patient_id}/notes/{note_id}",
    response_model=note_schema.PatientNoteResponse,
    summary="Fetch a specific patient medical note",
    status_code=status.HTTP_200_OK,
    dependencies=[Depends(get_current_active_user(required_role=UserRole.CLINICIAN))]
)
def read_patient_note(
    *,
    db: Session = Depends(get_db),
    patient_id: int,
    note_id: int,
    request: Request,
    current_user: UserModel = Depends(get_current_active_user(required_role=UserRole.CLINICIAN)),
):
    """
    Retrieves a specific medical note for a given patient.

    Access is restricted to authenticated users with the 'clinician' role.
    All access events are logged for HIPAA auditing purposes.
    """
    db_note = crud_base.get_patient_note(db=db, note_id=note_id, patient_id=patient_id)

    if not db_note:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="Patient note not found."
        )

    # HIPAA Audit Logging: Record every access to PHI.
    audit_log_entry = audit_schema.AuditLogCreate(
        user_id=current_user.id,
        patient_id=patient_id,
        action="VIEW_PATIENT_NOTE",
        ip_address=request.client.host if request.client else "unknown",
        details=f"Clinician '{current_user.username}' viewed note_id '{note_id}' for patient_id '{patient_id}'.",
    )
    crud_base.create_audit_log(db=db, log_entry=audit_log_entry)

    # In a real system, content would be decrypted here.
    # For this example, we assume `content_encrypted_ref` is a handle
    # to an encrypted object store (e.g., S3 with SSE-KMS).
    # The decrypted content would populate the response model.
    decrypted_content = f"[DECRYPTED CONTENT FOR REF: {db_note.content_encrypted_ref}]"

    return note_schema.PatientNoteResponse(
        id=db_note.id,
        patient_id=db_note.patient_id,
        author_id=db_note.author_id,
        note_type=db_note.note_type,
        content=decrypted_content,
        created_at=db_note.created_at,
        updated_at=db_note.updated_at
    )


# /core/config.py
# Application configuration settings.
import os
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    API_V1_STR: str = "/api/v1"
    SECRET_KEY: str = os.getenv("SECRET_KEY", "a_very_secret_key_for_development_only")
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 30
    DATABASE_URL: str = os.getenv("DATABASE_URL", "postgresql://user:password@localhost/emrdb")

    class Config:
        case_sensitive = True

settings = Settings()


# /db/session.py
# Database session management.
from sqlalchemy import create_engine
from sqlalchemy.orm import sessionmaker
from core.config import settings

engine = create_engine(settings.DATABASE_URL, pool_pre_ping=True)
SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=engine)

def get_db():
    db = SessionLocal()
    try:
        yield db
    finally:
        db.close()


# /db/base.py
# Base model for SQLAlchemy ORM.
from sqlalchemy.orm import declarative_base
Base = declarative_base()


# /models/medical.py
# SQLAlchemy ORM models for the EMR system.
from sqlalchemy import (
    Column, Integer, String, DateTime, Boolean, ForeignKey, Text, Enum as SQLAlchemyEnum
)
from sqlalchemy.orm import relationship
from sqlalchemy.sql import func
import enum

from db.base import Base

class UserRole(str, enum.Enum):
    ADMIN = "admin"
    CLINICIAN = "clinician"
    PATIENT = "patient"

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    role = Column(SQLAlchemyEnum(UserRole), nullable=False)
    is_active = Column(Boolean, default=True)
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    audit_logs = relationship("AuditLog", back_populates="user")

class Patient(Base):
    __tablename__ = "patients"
    id = Column(Integer, primary_key=True, index=True)
    first_name_encrypted = Column(String, nullable=False) # Encrypted at application level
    last_name_encrypted = Column(String, nullable=False)  # Encrypted at application level
    dob_encrypted = Column(String, nullable=False)       # Encrypted at application level
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    notes = relationship("PatientNote", back_populates="patient")
    audit_logs = relationship("AuditLog", back_populates="patient")

class PatientNote(Base):
    __tablename__ = "patient_notes"
    id = Column(Integer, primary_key=True, index=True)
    patient_id = Column(Integer, ForeignKey("patients.id"), nullable=False)
    author_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    note_type = Column(String, nullable=False, default="Progress Note")
    content_encrypted_ref = Column(Text, nullable=False) # Reference to content in secure storage
    created_at = Column(DateTime(timezone=True), server_default=func.now())
    updated_at = Column(DateTime(timezone=True), server_default=func.now(), onupdate=func.now())
    patient = relationship("Patient", back_populates="notes")
    author = relationship("User")

class AuditLog(Base):
    __tablename__ = "audit_logs"
    id = Column(Integer, primary_key=True, index=True)
    user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
    patient_id = Column(Integer, ForeignKey("patients.id"), nullable=True) # Can be null for system-level actions
    action = Column(String, nullable=False) # e.g., 'LOGIN', 'VIEW_PATIENT_CHART', 'CREATE_NOTE'
    timestamp = Column(DateTime(timezone=True), server_default=func.now())
    ip_address = Column(String, nullable=False)
    details = Column(Text, nullable=True) # Context about the action
    user = relationship("User", back_populates="audit_logs")
    patient = relationship("Patient", back_populates="audit_logs")


# /schemas/note.py
# Pydantic models for patient notes.
from pydantic import BaseModel
from datetime import datetime

class PatientNoteBase(BaseModel):
    note_type: str
    content: str

class PatientNoteCreate(PatientNoteBase):
    patient_id: int
    author_id: int

class PatientNoteResponse(BaseModel):
    id: int
    patient_id: int
    author_id: int
    note_type: str
    content: str
    created_at: datetime
    updated_at: datetime

    class Config:
        from_attributes = True


# /schemas/audit.py
# Pydantic models for audit logs.
from pydantic import BaseModel
from typing import Optional

class AuditLogCreate(BaseModel):
    user_id: int
    action: str
    ip_address: str
    patient_id: Optional[int] = None
    details: Optional[str] = None


# /schemas/user.py
# Pydantic models for users.
from pydantic import BaseModel
from models.medical import UserRole

class UserBase(BaseModel):
    username: str

class UserCreate(UserBase):
    password: str
    role: UserRole

class User(UserBase):
    id: int
    is_active: bool
    role: UserRole

    class Config:
        from_attributes = True

# /schemas/token.py
# Pydantic models for authentication tokens.
from pydantic import BaseModel
from typing import Optional

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None
    role: Optional[str] = None


# /security/auth.py
# Authentication, authorization, and password management.
from datetime import datetime, timedelta, timezone
from typing import Optional, Callable
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.orm import Session

from core.config import settings
from db.session import get_db
from models.medical import User, UserRole
from crud import base as crud_base
from schemas.token import TokenData

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/token")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=15)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

def authenticate_user(db: Session, username: str, password: str) -> Optional[User]:
    user = crud_base.get_user_by_username(db, username=username)
    if not user:
        return None
    if not verify_password(password, user.hashed_password):
        return None
    return user

def get_current_user(
    db: Session = Depends(get_db), token: str = Depends(oauth2_scheme)
) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username, role=payload.get("role"))
    except JWTError:
        raise credentials_exception
    user = crud_base.get_user_by_username(db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user

def get_current_active_user(required_role: UserRole) -> Callable[[User], User]:
    def role_checker(current_user: User = Depends(get_current_user)) -> User:
        if not current_user.is_active:
            raise HTTPException(status_code=400, detail="Inactive user")
        if current_user.role != required_role and current_user.role != UserRole.ADMIN:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail=f"Operation not permitted. Requires '{required_role.value}' role."
            )
        return current_user
    return role_checker


# /crud/base.py
# Core CRUD operations for database models.
from sqlalchemy.orm import Session
from typing import Optional

from models import medical as models
from schemas import audit as audit_schema
from security import auth

def get_user_by_username(db: Session, username: str) -> Optional[models.User]:
    return db.query(models.User).filter(models.User.username == username).first()

def get_patient_note(db: Session, note_id: int, patient_id: int) -> Optional[models.PatientNote]:
    return db.query(models.PatientNote).filter(
        models.PatientNote.id == note_id,
        models.PatientNote.patient_id == patient_id
    ).first()

def create_audit_log(db: Session, log_entry: audit_schema.AuditLogCreate) -> models.AuditLog:
    db_log = models.AuditLog(**log_entry.model_dump())
    db.add(db_log)
    db.commit()
    db.refresh(db_log)
    return db_log
```