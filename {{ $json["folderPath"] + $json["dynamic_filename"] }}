```python
# /src/core/config.py

import os
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    """
    Application settings loaded from environment variables.
    """
    PROJECT_NAME: str = "EMR-Backend-System"
    API_V1_STR: str = "/api/v1"

    # Security settings
    SECRET_KEY: str = "a_very_secure_secret_key_that_must_be_changed"
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60
    
    # Database settings
    DATABASE_URL: str = "postgresql+asyncpg://user:password@localhost/emr_db"

    class Config:
        case_sensitive = True
        env_file = ".env"

settings = Settings()

# ---
# /src/core/database.py

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from typing import AsyncGenerator

from src.core.config import settings

engine = create_async_engine(settings.DATABASE_URL, pool_pre_ping=True, echo=False)
AsyncSessionLocal = sessionmaker(
    autocommit=False, 
    autoflush=False, 
    bind=engine, 
    class_=AsyncSession,
    expire_on_commit=False
)

Base = declarative_base()

async def get_db() -> AsyncGenerator[AsyncSession, None]:
    """
    Dependency to get a database session.
    Ensures the session is closed after the request.
    """
    async with AsyncSessionLocal() as session:
        yield session

# ---
# /src/models/audit_log.py

import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import INET, JSONB
from sqlalchemy.orm import relationship
from datetime import datetime, timezone

from src.core.database import Base

class AuditLog(Base):
    """
    Database model for HIPAA audit logs.
    Captures all significant events, especially PHI access.
    """
    __tablename__ = "audit_logs"

    id = sa.Column(sa.Integer, primary_key=True, index=True)
    timestamp = sa.Column(sa.DateTime(timezone=True), default=lambda: datetime.now(timezone.utc), nullable=False)
    user_id = sa.Column(sa.Integer, sa.ForeignKey("users.id"), nullable=False, index=True)
    event_type = sa.Column(sa.String, nullable=False, index=True)
    outcome = sa.Column(sa.Enum("SUCCESS", "FAILURE", name="event_outcome_enum"), nullable=False)
    source_ip = sa.Column(INET, nullable=True)
    endpoint = sa.Column(sa.String, nullable=False)
    affected_resource_id = sa.Column(sa.String, nullable=True, index=True)
    details = sa.Column(JSONB, nullable=True)

    user = relationship("User", back_populates="audit_logs")


# ---
# /src/models/user.py

import sqlalchemy as sa
from sqlalchemy.orm import relationship
from enum import Enum

from src.core.database import Base

class UserRole(str, Enum):
    CLINICIAN = "clinician"
    ADMIN = "admin"
    PATIENT = "patient"

class User(Base):
    """
    Database model for system users (e.g., clinicians, administrators).
    """
    __tablename__ = "users"

    id = sa.Column(sa.Integer, primary_key=True, index=True)
    username = sa.Column(sa.String, unique=True, index=True, nullable=False)
    hashed_password = sa.Column(sa.String, nullable=False)
    full_name = sa.Column(sa.String, nullable=False)
    role = sa.Column(sa.Enum(UserRole, name="user_role_enum"), nullable=False)
    is_active = sa.Column(sa.Boolean, default=True)

    audit_logs = relationship("AuditLog", back_populates="user")
    lab_results_ordered = relationship("LabResult", back_populates="ordering_provider")
    patient_associations = relationship("ProviderPatientLink", back_populates="provider")


# ---
# /src/models/patient.py

import sqlalchemy as sa
from sqlalchemy.orm import relationship
from sqlalchemy.dialects.postgresql import UUID
import uuid

from src.core.database import Base

class Patient(Base):
    """
    Database model for patients.
    Uses a non-sequential, non-PHI primary key.
    """
    __tablename__ = "patients"

    id = sa.Column(UUID(as_uuid=True), primary_key=True, default=uuid.uuid4)
    # Note: PHI like name, DOB are stored in a separate, more restricted table
    # or encrypted fields in a real-world scenario.
    # For this example, we link via the non-PHI UUID.
    
    lab_results = relationship("LabResult", back_populates="patient")
    provider_associations = relationship("ProviderPatientLink", back_populates="patient")


# ---
# /src/models/lab_result.py

import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship
from datetime import datetime, timezone

from src.core.database import Base

class LabResult(Base):
    """
    Database model for patient lab results.
    """
    __tablename__ = "lab_results"

    id = sa.Column(sa.Integer, primary_key=True, index=True)
    patient_id = sa.Column(UUID(as_uuid=True), sa.ForeignKey("patients.id"), nullable=False, index=True)
    test_name = sa.Column(sa.String, nullable=False)
    result_value = sa.Column(sa.String, nullable=False)
    units = sa.Column(sa.String, nullable=True)
    reference_range = sa.Column(sa.String, nullable=True)
    observation_datetime = sa.Column(sa.DateTime(timezone=True), nullable=False)
    ordering_provider_id = sa.Column(sa.Integer, sa.ForeignKey("users.id"), nullable=False)
    created_at = sa.Column(sa.DateTime(timezone=True), default=lambda: datetime.now(timezone.utc))

    patient = relationship("Patient", back_populates="lab_results")
    ordering_provider = relationship("User", back_populates="lab_results_ordered")


# ---
# /src/models/provider_patient_link.py

import sqlalchemy as sa
from sqlalchemy.dialects.postgresql import UUID
from sqlalchemy.orm import relationship

from src.core.database import Base

class ProviderPatientLink(Base):
    """
    Association table to securely link providers (Users) to patients.
    This enforces the authorization boundary.
    """
    __tablename__ = "provider_patient_link"

    provider_id = sa.Column(sa.Integer, sa.ForeignKey("users.id"), primary_key=True)
    patient_id = sa.Column(UUID(as_uuid=True), sa.ForeignKey("patients.id"), primary_key=True)

    provider = relationship("User", back_populates="patient_associations")
    patient = relationship("Patient", back_populates="provider_associations")


# ---
# /src/schemas/audit_log.py

from pydantic import BaseModel
from datetime import datetime
from typing import Any, Optional

class AuditLogCreate(BaseModel):
    user_id: int
    event_type: str
    outcome: str
    source_ip: Optional[str] = None
    endpoint: str
    affected_resource_id: Optional[str] = None
    details: Optional[dict[str, Any]] = None

# ---
# /src/schemas/user.py

from pydantic import BaseModel, constr
from src.models.user import UserRole

class UserBase(BaseModel):
    username: str
    full_name: str
    role: UserRole

class User(UserBase):
    id: int
    is_active: bool

    class Config:
        from_attributes = True

class UserInDB(User):
    hashed_password: str

# ---
# /src/schemas/token.py

from pydantic import BaseModel
from typing import Optional

class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: Optional[str] = None


# ---
# /src/schemas/lab_result.py

from pydantic import BaseModel
from datetime import datetime
from typing import Optional

class LabResultResponse(BaseModel):
    """
    Secure response model for lab results.
    Does not expose internal IDs like patient_id or ordering_provider_id.
    """
    test_name: str
    result_value: str
    units: Optional[str] = None
    reference_range: Optional[str] = None
    observation_datetime: datetime

    class Config:
        from_attributes = True


# ---
# /src/services/audit_logger.py

from sqlalchemy.ext.asyncio import AsyncSession
from fastapi import Request

from src.models.audit_log import AuditLog
from src.schemas.audit_log import AuditLogCreate

async def create_audit_log(db: AsyncSession, *, log_entry: AuditLogCreate) -> AuditLog:
    """
    Creates and saves an audit log entry to the database.
    """
    db_obj = AuditLog(**log_entry.model_dump())
    db.add(db_obj)
    await db.commit()
    await db.refresh(db_obj)
    return db_obj

class AuditLogger:
    """
    A dependency class to handle logging within API endpoints.
    """
    def __init__(self, request: Request, db: AsyncSession):
        self.request = request
        self.db = db

    async def log(self, user_id: int, event_type: str, outcome: str, resource_id: Optional[str] = None, details: Optional[dict] = None):
        client_host = self.request.client.host if self.request.client else None
        log_entry = AuditLogCreate(
            user_id=user_id,
            event_type=event_type,
            outcome=outcome,
            source_ip=client_host,
            endpoint=self.request.url.path,
            affected_resource_id=str(resource_id) if resource_id else None,
            details=details or {}
        )
        await create_audit_log(self.db, log_entry=log_entry)

# ---
# /src/core/security.py

from datetime import datetime, timedelta, timezone
from typing import Optional
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer
from sqlalchemy.ext.asyncio import AsyncSession
import sqlalchemy as sa

from src.core.config import settings
from src.core.database import get_db
from src.models.user import User
from src.schemas.token import TokenData

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl=f"{settings.API_V1_STR}/auth/token")

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: Optional[timedelta] = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.now(timezone.utc) + expires_delta
    else:
        expire = datetime.now(timezone.utc) + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

async def get_user(db: AsyncSession, username: str) -> Optional[User]:
    result = await db.execute(sa.select(User).filter(User.username == username))
    return result.scalars().first()

async def get_current_user(token: str = Depends(oauth2_scheme), db: AsyncSession = Depends(get_db)) -> User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_data = TokenData(username=username)
    except JWTError:
        raise credentials_exception
    
    user = await get_user(db, username=token_data.username)
    if user is None:
        raise credentials_exception
    return user

async def get_current_active_user(current_user: User = Depends(get_current_user)) -> User:
    if not current_user.is_active:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")
    return current_user

# ---
# /src/crud/crud_lab_result.py

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select
from uuid import UUID

from src.models.lab_result import LabResult
from src.models.user import User, UserRole
from src.models.provider_patient_link import ProviderPatientLink

async def is_user_authorized_for_patient(db: AsyncSession, *, user: User, patient_id: UUID) -> bool:
    """
    Checks if a user is authorized to view a patient's data.
    Authorization Rules:
    1. An Admin can view any patient.
    2. A Clinician can only view patients they are explicitly linked to.
    """
    if user.role == UserRole.ADMIN:
        return True
    
    if user.role == UserRole.CLINICIAN:
        query = select(ProviderPatientLink).filter_by(provider_id=user.id, patient_id=patient_id)
        result = await db.execute(query)
        link = result.scalars().first()
        return link is not None
        
    return False

async def get_patient_lab_results(db: AsyncSession, *, patient_id: UUID) -> list[LabResult]:
    """
    Retrieves all lab results for a specific patient, ordered by date.
    """
    query = (
        select(LabResult)
        .filter(LabResult.patient_id == patient_id)
        .order_by(LabResult.observation_datetime.desc())
    )
    result = await db.execute(query)
    return result.scalars().all()

# ---
# /src/api/v1/endpoints/auth.py

from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession
from datetime import timedelta

from src.core import security
from src.core.config import settings
from src.core.database import get_db
from src.schemas.token import Token
from src.services.audit_logger import AuditLogger

router = APIRouter()

@router.post("/token", response_model=Token)
async def login_for_access_token(
    db: AsyncSession = Depends(get_db),
    form_data: OAuth2PasswordRequestForm = Depends()
):
    """
    Standard OAuth2 password flow for token generation.
    """
    user = await security.get_user(db, username=form_data.username)
    if not user or not security.verify_password(form_data.password, user.hashed_password):
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    
    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    access_token = security.create_access_token(
        data={"sub": user.username}, expires_delta=access_token_expires
    )
    
    # Manually create AuditLogger for this specific event
    logger = AuditLogger(request=form_data, db=db) 
    await logger.log(user_id=user.id, event_type="USER_LOGIN", outcome="SUCCESS")

    return {"access_token": access_token, "token_type": "bearer"}


# ---
# /src/api/v1/endpoints/lab_results.py

from fastapi import APIRouter, Depends, HTTPException, status, Request
from uuid import UUID
from typing import List

from src.core.database import get_db, AsyncSession
from src.core.security import get_current_active_user
from src.models.user import User, UserRole
from src.schemas.lab_result import LabResultResponse
from src.crud import crud_lab_result
from src.services.audit_logger import AuditLogger

router = APIRouter()

@router.get(
    "/{patient_id}/lab-results",
    response_model=List[LabResultResponse],
    dependencies=[Depends(get_current_active_user)],
    summary="Retrieve Patient Lab Results",
    status_code=status.HTTP_200_OK,
)
async def read_patient_lab_results(
    patient_id: UUID,
    request: Request,
    db: AsyncSession = Depends(get_db),
    current_user: User = Depends(get_current_active_user),
):
    """
    Retrieves a list of lab results for a specified patient.

    Access is strictly controlled:
    - User must be authenticated and active.
    - User must be authorized to view the specified patient's data.
    - All access attempts (successful or failed) are logged for HIPAA auditing.
    """
    logger = AuditLogger(request, db)

    is_authorized = await crud_lab_result.is_user_authorized_for_patient(
        db=db, user=current_user, patient_id=patient_id
    )

    if not is_authorized:
        await logger.log(
            user_id=current_user.id,
            event_type="PHI_ACCESS_DENIED",
            outcome="FAILURE",
            resource_id=patient_id,
            details={"reason": f"User role '{current_user.role}' not authorized for patient."}
        )
        raise HTTPException(
            status_code=status.HTTP_403_FORBIDDEN,
            detail="Not authorized to access this patient's records",
        )

    lab_results = await crud_lab_result.get_patient_lab_results(db=db, patient_id=patient_id)
    
    await logger.log(
        user_id=current_user.id,
        event_type="PHI_ACCESS_GRANTED",
        outcome="SUCCESS",
        resource_id=patient_id,
        details={"results_count": len(lab_results)}
    )

    if not lab_results:
         # Note: returning 200 with empty list is also valid. 404 can leak info.
         # However, in a known-patient context, 404 for sub-resource is acceptable.
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail="No lab results found for this patient.",
        )

    return lab_results


# ---
# /src/api/v1/api.py

from fastapi import APIRouter
from src.api.v1.endpoints import auth, lab_results

api_router = APIRouter()
api_router.include_router(auth.router, prefix="/auth", tags=["Authentication"])
api_router.include_router(lab_results.router, prefix="/patients", tags=["Patients & Labs"])

# ---
# /src/main.py

from fastapi import FastAPI
from fastapi.middleware.cors import CORSMiddleware

from src.core.config import settings
from src.api.v1.api import api_router

app = FastAPI(
    title=settings.PROJECT_NAME,
    openapi_url=f"{settings.API_V1_STR}/openapi.json"
)

# CORS Middleware
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # In production, restrict to specific frontend domains
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

app.include_router(api_router, prefix=settings.API_V1_STR)

@app.get("/", tags=["Root"])
async def read_root():
    """
    Root endpoint providing basic system status.
    """
    return {"status": "EMR System Online", "version": "1.0.0"}

```