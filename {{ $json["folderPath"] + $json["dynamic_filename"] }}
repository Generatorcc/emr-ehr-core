```python
# /emr_backend/config.py

import os
from pydantic_settings import BaseSettings

class Settings(BaseSettings):
    """
    Application settings loaded from environment variables.
    """
    DATABASE_URL: str = os.getenv("DATABASE_URL", "postgresql+asyncpg://user:password@localhost/emr")
    SECRET_KEY: str = os.getenv("SECRET_KEY", "a_very_secret_key_that_should_be_changed")
    ALGORITHM: str = "HS256"
    ACCESS_TOKEN_EXPIRE_MINUTES: int = 60
    AUDIT_LOG_FILE_PATH: str = "/var/log/emr/audit.log"

    class Config:
        env_file = ".env"
        env_file_encoding = 'utf-8'

settings = Settings()
```

```python
# /emr_backend/database.py

from sqlalchemy.ext.asyncio import create_async_engine, AsyncSession
from sqlalchemy.orm import sessionmaker, declarative_base
from .config import settings

engine = create_async_engine(
    settings.DATABASE_URL,
    pool_pre_ping=True,
    echo=False  # Set to True for debugging SQL statements
)

AsyncSessionLocal = sessionmaker(
    engine,
    class_=AsyncSession,
    expire_on_commit=False
)

Base = declarative_base()

async def get_db() -> AsyncSession:
    """
    Dependency to get a database session.
    Ensures the session is always closed after the request.
    """
    async with AsyncSessionLocal() as session:
        yield session
```

```python
# /emr_backend/enums.py

from enum import Enum

class UserRole(str, Enum):
    """
    Enumeration for user roles to enforce Role-Based Access Control (RBAC).
    """
    PHYSICIAN = "physician"
    NURSE = "nurse"
    ADMINISTRATOR = "administrator"
    SYSTEM = "system"

class AuditAction(str, Enum):
    """

    Enumeration for actions recorded in the audit log, compliant with HIPAA standards.
    """
    # Authentication Events
    LOGIN_SUCCESS = "LOGIN_SUCCESS"
    LOGIN_FAILURE = "LOGIN_FAILURE"
    LOGOUT = "LOGOUT"
    TOKEN_REFRESH = "TOKEN_REFRESH"

    # PHI Access Events
    PATIENT_RECORD_VIEW = "PATIENT_RECORD_VIEW"
    PATIENT_RECORD_CREATE = "PATIENT_RECORD_CREATE"
    PATIENT_RECORD_UPDATE = "PATIENT_RECORD_UPDATE"
    PATIENT_RECORD_DELETE = "PATIENT_RECORD_DELETE" # Logical delete/deactivation

    # System/Configuration Events
    USER_CREATED = "USER_CREATED"
    USER_DEACTIVATED = "USER_DEACTIVATED"
    PERMISSIONS_CHANGED = "PERMISSIONS_CHANGED"
```

```python
# /emr_backend/logging_config.py

import logging
import sys
from .config import settings
from .enums import AuditAction

class AuditLogger:
    """
    Dedicated logger for HIPAA audit trails.
    Logs are formatted as structured JSON for easy parsing by security systems (SIEM).
    """
    def __init__(self):
        self.logger = logging.getLogger("audit")
        if not self.logger.handlers:
            self.logger.setLevel(logging.INFO)
            # In production, use WatchedFileHandler or similar for log rotation.
            # For this example, StreamHandler is sufficient.
            handler = logging.StreamHandler(sys.stdout)
            formatter = logging.Formatter(
                '{"timestamp": "%(asctime)s", "level": "%(levelname)s", "audit": %(message)s}',
                '%Y-%m-%dT%H:%M:%S%z'
            )
            handler.setFormatter(formatter)
            self.logger.addHandler(handler)
            self.logger.propagate = False

    def log(
        self,
        actor_id: int,
        action: AuditAction,
        target_id: int | None = None,
        details: dict | None = None
    ):
        """
        Creates a structured audit log entry.
        """
        log_entry = {
            "actor_id": actor_id,
            "action": action.value,
            "target_id": target_id,
            "details": details or {}
        }
        import json
        self.logger.info(json.dumps(log_entry))

audit_logger = AuditLogger()
```

```python
# /emr_backend/models.py

import datetime
from sqlalchemy import (
    Boolean, Column, DateTime, Enum, ForeignKey, Integer, String, Text,
    event, DDL
)
from sqlalchemy.orm import relationship
from .database import Base
from .enums import UserRole

# Enable the pgcrypto extension for UUID generation in PostgreSQL
event.listen(
    Base.metadata,
    'before_create',
    DDL("CREATE EXTENSION IF NOT EXISTS pgcrypto")
)

class User(Base):
    __tablename__ = "users"
    id = Column(Integer, primary_key=True, index=True)
    username = Column(String, unique=True, index=True, nullable=False)
    hashed_password = Column(String, nullable=False)
    full_name = Column(String, nullable=False)
    role = Column(Enum(UserRole), nullable=False)
    is_active = Column(Boolean, default=True)

    created_notes = relationship("ClinicalNote", back_populates="author")

class Patient(Base):
    __tablename__ = "patients"
    id = Column(Integer, primary_key=True, index=True)
    mrn = Column(String, unique=True, index=True, nullable=False, server_default=DDL("gen_random_uuid()::text"))
    first_name = Column(String, nullable=False)
    last_name = Column(String, nullable=False)
    date_of_birth = Column(DateTime, nullable=False)
    
    notes = relationship("ClinicalNote", back_populates="patient", cascade="all, delete-orphan")

class ClinicalNote(Base):
    __tablename__ = "clinical_notes"
    id = Column(Integer, primary_key=True, index=True)
    content = Column(Text, nullable=False) # Assumes encryption-at-rest at the database layer
    created_at = Column(DateTime, default=datetime.datetime.utcnow)
    updated_at = Column(DateTime, default=datetime.datetime.utcnow, onupdate=datetime.datetime.utcnow)
    
    patient_id = Column(Integer, ForeignKey("patients.id"), nullable=False)
    author_id = Column(Integer, ForeignKey("users.id"), nullable=False)

    patient = relationship("Patient", back_populates="notes")
    author = relationship("User", back_populates="created_notes")
```

```python
# /emr_backend/schemas.py

import datetime
from pydantic import BaseModel, Field
from .enums import UserRole

# User Schemas
class UserBase(BaseModel):
    username: str
    full_name: str
    role: UserRole

class UserCreate(UserBase):
    password: str

class UserInDB(UserBase):
    id: int
    is_active: bool

    class Config:
        from_attributes = True

class User(UserInDB):
    pass

# Token Schemas
class Token(BaseModel):
    access_token: str
    token_type: str

class TokenData(BaseModel):
    username: str | None = None
    scopes: list[str] = []

# Patient Schemas
class PatientBase(BaseModel):
    first_name: str
    last_name: str
    date_of_birth: datetime.date

class PatientCreate(PatientBase):
    pass

class Patient(PatientBase):
    id: int
    mrn: str

    class Config:
        from_attributes = True


# Clinical Note Schemas
class NoteBase(BaseModel):
    content: str = Field(..., min_length=10, description="Content of the clinical note.")

class NoteCreate(NoteBase):
    pass

class NoteUpdate(NoteBase):
    pass

class NoteAuthor(BaseModel):
    id: int
    full_name: str
    role: UserRole

    class Config:
        from_attributes = True

class Note(NoteBase):
    id: int
    patient_id: int
    created_at: datetime.datetime
    updated_at: datetime.datetime
    author: NoteAuthor

    class Config:
        from_attributes = True
```

```python
# /emr_backend/crud.py

from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy.future import select
from . import models, schemas
from .auth import get_password_hash

# User CRUD
async def get_user_by_username(db: AsyncSession, username: str) -> models.User | None:
    result = await db.execute(select(models.User).filter(models.User.username == username))
    return result.scalars().first()

async def create_user(db: AsyncSession, user: schemas.UserCreate) -> models.User:
    hashed_password = get_password_hash(user.password)
    db_user = models.User(
        username=user.username,
        hashed_password=hashed_password,
        full_name=user.full_name,
        role=user.role
    )
    db.add(db_user)
    await db.commit()
    await db.refresh(db_user)
    return db_user

# Patient CRUD
async def get_patient_by_id(db: AsyncSession, patient_id: int) -> models.Patient | None:
    result = await db.execute(select(models.Patient).filter(models.Patient.id == patient_id))
    return result.scalars().first()

# Clinical Note CRUD
async def get_notes_for_patient(db: AsyncSession, patient_id: int, skip: int = 0, limit: int = 100) -> list[models.ClinicalNote]:
    result = await db.execute(
        select(models.ClinicalNote)
        .filter(models.ClinicalNote.patient_id == patient_id)
        .order_by(models.ClinicalNote.created_at.desc())
        .offset(skip)
        .limit(limit)
    )
    return result.scalars().all()

async def create_patient_note(db: AsyncSession, note: schemas.NoteCreate, patient_id: int, author_id: int) -> models.ClinicalNote:
    db_note = models.ClinicalNote(
        **note.model_dump(),
        patient_id=patient_id,
        author_id=author_id
    )
    db.add(db_note)
    await db.commit()
    await db.refresh(db_note)
    return db_note
```

```python
# /emr_backend/auth.py

from datetime import datetime, timedelta
from jose import JWTError, jwt
from passlib.context import CryptContext
from fastapi import Depends, HTTPException, status
from fastapi.security import OAuth2PasswordBearer, SecurityScopes

from . import crud, schemas, models
from .config import settings
from .database import get_db
from .enums import UserRole
from sqlalchemy.ext.asyncio import AsyncSession

pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(
    tokenUrl="api/v1/token",
    scopes={
        "notes:read": "Read clinical notes.",
        "notes:write": "Create and update clinical notes.",
        "patient:read": "Read patient demographic data.",
        "admin": "Full administrative access.",
    }
)

def verify_password(plain_password: str, hashed_password: str) -> bool:
    return pwd_context.verify(plain_password, hashed_password)

def get_password_hash(password: str) -> str:
    return pwd_context.hash(password)

def create_access_token(data: dict, expires_delta: timedelta | None = None) -> str:
    to_encode = data.copy()
    if expires_delta:
        expire = datetime.utcnow() + expires_delta
    else:
        expire = datetime.utcnow() + timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire})
    encoded_jwt = jwt.encode(to_encode, settings.SECRET_KEY, algorithm=settings.ALGORITHM)
    return encoded_jwt

async def get_current_user(
    security_scopes: SecurityScopes,
    token: str = Depends(oauth2_scheme),
    db: AsyncSession = Depends(get_db)
) -> models.User:
    credentials_exception = HTTPException(
        status_code=status.HTTP_401_UNAUTHORIZED,
        detail="Could not validate credentials",
        headers={"WWW-Authenticate": "Bearer"},
    )
    try:
        payload = jwt.decode(token, settings.SECRET_KEY, algorithms=[settings.ALGORITHM])
        username: str = payload.get("sub")
        if username is None:
            raise credentials_exception
        token_scopes = payload.get("scopes", [])
        token_data = schemas.TokenData(scopes=token_scopes, username=username)
    except JWTError:
        raise credentials_exception

    user = await crud.get_user_by_username(db, username=token_data.username)
    if user is None:
        raise credentials_exception
        
    for scope in security_scopes.scopes:
        if scope not in token_data.scopes:
            raise HTTPException(
                status_code=status.HTTP_403_FORBIDDEN,
                detail="Not enough permissions",
                headers={"WWW-Authenticate": "Bearer"},
            )
    return user

async def get_current_active_user(
    current_user: models.User = Depends(get_current_user)
) -> models.User:
    if not current_user.is_active:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")
    return current_user

def get_role_scopes(role: UserRole) -> list[str]:
    """Maps a user role to a set of OAuth2 scopes."""
    scope_map = {
        UserRole.PHYSICIAN: ["notes:read", "notes:write", "patient:read"],
        UserRole.NURSE: ["notes:read", "notes:write", "patient:read"],
        UserRole.ADMINISTRATOR: ["admin", "notes:read", "patient:read"],
        UserRole.SYSTEM: []
    }
    return scope_map.get(role, [])
```

```python
# /emr_backend/api/v1/endpoints/token.py

from datetime import timedelta
from fastapi import APIRouter, Depends, HTTPException, status
from fastapi.security import OAuth2PasswordRequestForm
from sqlalchemy.ext.asyncio import AsyncSession

from .... import crud, schemas
from ....auth import create_access_token, verify_password, get_role_scopes
from ....config import settings
from ....database import get_db
from ....logging_config import audit_logger, AuditAction

router = APIRouter()

@router.post("/token", response_model=schemas.Token)
async def login_for_access_token(
    form_data: OAuth2PasswordRequestForm = Depends(),
    db: AsyncSession = Depends(get_db)
):
    """
    Provides a JWT access token for valid user credentials.
    This endpoint is the foundation of the EMR's security model.
    """
    user = await crud.get_user_by_username(db, username=form_data.username)
    if not user or not verify_password(form_data.password, user.hashed_password):
        audit_logger.log(
            actor_id=-1, # Unknown user
            action=AuditAction.LOGIN_FAILURE,
            details={"username": form_data.username}
        )
        raise HTTPException(
            status_code=status.HTTP_401_UNAUTHORIZED,
            detail="Incorrect username or password",
            headers={"WWW-Authenticate": "Bearer"},
        )
    if not user.is_active:
        raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="Inactive user")

    access_token_expires = timedelta(minutes=settings.ACCESS_TOKEN_EXPIRE_MINUTES)
    scopes = get_role_scopes(user.role)
    access_token = create_access_token(
        data={"sub": user.username, "scopes": scopes}, expires_delta=access_token_expires
    )
    
    audit_logger.log(
        actor_id=user.id,
        action=AuditAction.LOGIN_SUCCESS
    )
    
    return {"access_token": access_token, "token_type": "bearer"}
```

```python
# /emr_backend/api/v1/endpoints/notes.py

from fastapi import APIRouter, Depends, HTTPException, Security, status
from sqlalchemy.ext.asyncio import AsyncSession

from .... import crud, models, schemas
from ....auth import get_current_active_user
from ....database import get_db
from ....logging_config import audit_logger, AuditAction

router = APIRouter()

@router.post(
    "/patients/{patient_id}/notes",
    response_model=schemas.Note,
    status_code=status.HTTP_201_CREATED,
    summary="Create a Clinical Note",
    description="Creates a new clinical note for a specific patient. Requires `notes:write` scope.",
)
async def create_note_for_patient(
    patient_id: int,
    note: schemas.NoteCreate,
    db: AsyncSession = Depends(get_db),
    current_user: models.User = Security(get_current_active_user, scopes=["notes:write"])
):
    patient = await crud.get_patient_by_id(db, patient_id=patient_id)
    if not patient:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Patient not found")

    created_note = await crud.create_patient_note(db=db, note=note, patient_id=patient_id, author_id=current_user.id)
    
    audit_logger.log(
        actor_id=current_user.id,
        action=AuditAction.PATIENT_RECORD_CREATE,
        target_id=patient_id,
        details={"note_id": created_note.id, "entity": "ClinicalNote"}
    )
    
    return created_note

@router.get(
    "/patients/{patient_id}/notes",
    response_model=list[schemas.Note],
    summary="Retrieve Clinical Notes",
    description="Retrieves all clinical notes for a specific patient. Requires `notes:read` scope.",
)
async def read_patient_notes(
    patient_id: int,
    db: AsyncSession = Depends(get_db),
    current_user: models.User = Security(get_current_active_user, scopes=["notes:read"])
):
    patient = await crud.get_patient_by_id(db, patient_id=patient_id)
    if not patient:
        raise HTTPException(status_code=status.HTTP_404_NOT_FOUND, detail="Patient not found")

    notes = await crud.get_notes_for_patient(db=db, patient_id=patient_id)
    
    audit_logger.log(
        actor_id=current_user.id,
        action=AuditAction.PATIENT_RECORD_VIEW,
        target_id=patient_id,
        details={"entity": "ClinicalNote", "record_count": len(notes)}
    )

    return notes
```

```python
# /emr_backend/api/v1/api.py

from fastapi import APIRouter
from .endpoints import notes, token

api_router = APIRouter()
api_router.include_router(token.router, tags=["Authentication"])
api_router.include_router(notes.router, prefix="/v1", tags=["Clinical Notes"])
```

```python
# /emr_backend/main.py

from fastapi import FastAPI, Request
from fastapi.responses import JSONResponse
from sqlalchemy.exc import SQLAlchemyError

from .api.v1.api import api_router
from .database import Base, engine

app = FastAPI(
    title="EMR Backend Service",
    description="Backend for a HIPAA-compliant Electronic Medical Record system.",
    version="1.0.0",
    redoc_url=None # Disable ReDoc in production environments
)

@app.on_event("startup")
async def startup_event():
    # In a production environment, use Alembic for migrations.
    # This is for demonstration purposes to create tables.
    async with engine.begin() as conn:
        await conn.run_sync(Base.metadata.create_all)

app.include_router(api_router, prefix="/api")

@app.exception_handler(SQLAlchemyError)
async def sqlalchemy_exception_handler(request: Request, exc: SQLAlchemyError):
    # Prevent leaking database-specific error details to the client
    return JSONResponse(
        status_code=500,
        content={"detail": "An internal database error occurred."},
    )

@app.get("/", summary="Health Check", tags=["System"])
def read_root():
    """
    Provides a simple health check endpoint for monitoring systems.
    """
    return {"status": "ok"}
```